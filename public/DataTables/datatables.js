/*
 * This combined file was created by the DataTables downloader builder:
 *   https://datatables.net/download
 *
 * To rebuild or modify this file with the latest versions of the included
 * software please visit:
 *   https://datatables.net/download/#bs4/e-1.9.2/af-2.3.4/b-1.6.1/cr-1.5.2/fc-3.3.0/fh-3.1.6/kt-2.5.1/r-2.2.3/rg-1.1.1/rr-1.2.6/sc-2.0.1/sp-1.0.1/sl-1.3.1
 *
 * Included libraries:
 *   Editor 1.9.2, AutoFill 2.3.4, Buttons 1.6.1, ColReorder 1.5.2, FixedColumns 3.3.0, FixedHeader 3.1.6, KeyTable 2.5.1, Responsive 2.2.3, RowGroup 1.1.1, RowReorder 1.2.6, Scroller 2.0.1, SearchPanes 1.0.1, Select 1.3.1
 */

/*!
 * File:        dataTables.editor.min.js
 * Version:     1.9.2
 * Author:      SpryMedia (www.sprymedia.co.uk)
 * Info:        http://editor.datatables.net
 * 
 * Copyright 2012-2020 SpryMedia Limited, all rights reserved.
 * License: DataTables Editor - http://editor.datatables.net/license
 */

 // Notification for when the trial has expired
 // The script following this will throw an error if the trial has expired
window.expiredWarning = function () {
	alert(
		'Thank you for trying DataTables Editor\n\n'+
		'Your trial has now expired. To purchase a license '+
		'for Editor, please see https://editor.datatables.net/purchase'
	);
};

u433.u=(function(){var u=2;for(;u !== 9;){switch(u){case 1:return globalThis;break;case 2:u=typeof globalThis === '\x6f\u0062\x6a\u0065\x63\x74'?1:5;break;case 5:var _global;try{var t=2;for(;t !== 4;){switch(t){case 2:Object['\x64\x65\u0066\x69\u006e\u0065\x50\x72\u006f\u0070\u0065\x72\u0074\x79'](Object['\u0070\x72\x6f\x74\u006f\u0074\u0079\u0070\u0065'],'\u0072\x4a\u0048\x68\u0074',{'\x67\x65\x74':function(){var N=2;for(;N !== 1;){switch(N){case 2:return this;break;}}},'\x63\x6f\x6e\x66\x69\x67\x75\x72\x61\x62\x6c\x65':true});_global=rJHht;delete Object['\u0070\u0072\u006f\x74\u006f\x74\x79\u0070\u0065']['\u0072\x4a\u0048\u0068\u0074'];t=4;break;}}}catch(e){_global=window;}return _global;break;}}})();;r8YY(u433.u);G9vv(u433.u);u433.J4v="a";u433.d4v='function';u433.R4v='object';u433.P4v="m";function G9vv(P0L){function p2L(b0L){var S5L=2;for(;S5L !== 5;){switch(S5L){case 2:var U0L=[arguments];return U0L[0][0].Array;break;}}}function L2L(z0L){var O5L=2;for(;O5L !== 5;){switch(O5L){case 2:var p0L=[arguments];return p0L[0][0];break;}}}var d5L=2;for(;d5L !== 55;){switch(d5L){case 59:H2L(L2L,u0L[15],u0L[22],u0L[13]);d5L=58;break;case 61:H2L(U2L,"test",u0L[14],u0L[74]);d5L=60;break;case 16:u0L[88]="iz";u0L[85]="";u0L[85]="__optim";u0L[97]="";d5L=25;break;case 50:u0L[15]=u0L[1];u0L[15]+=u0L[4];u0L[15]+=u0L[5];u0L[55]=u0L[3];d5L=46;break;case 57:H2L(L2L,u0L[31],u0L[22],u0L[10]);d5L=56;break;case 28:u0L[10]+=u0L[97];u0L[10]+=u0L[57];u0L[31]=u0L[85];u0L[31]+=u0L[88];u0L[31]+=u0L[8];u0L[95]=u0L[4];u0L[95]+=u0L[97];d5L=38;break;case 21:u0L[70]="e9";u0L[14]=1;u0L[22]=7;u0L[22]=0;d5L=32;break;case 62:var H2L=function(a0L,q0L,k0L,w0L){var G5L=2;for(;G5L !== 5;){switch(G5L){case 2:var V0L=[arguments];n2L(u0L[0][0],V0L[0][0],V0L[0][1],V0L[0][2],V0L[0][3]);G5L=5;break;}}};d5L=61;break;case 38:u0L[95]+=u0L[57];u0L[34]=u0L[9];u0L[34]+=u0L[8];u0L[34]+=u0L[7];u0L[13]=u0L[6];u0L[13]+=u0L[57];u0L[13]+=u0L[57];d5L=50;break;case 46:u0L[55]+=u0L[97];u0L[55]+=u0L[57];u0L[74]=u0L[2];u0L[74]+=u0L[97];d5L=63;break;case 56:H2L(V2L,"apply",u0L[14],u0L[80]);d5L=55;break;case 25:u0L[97]="9v";u0L[81]="j";u0L[57]="";u0L[57]="v";d5L=21;break;case 63:u0L[74]+=u0L[57];d5L=62;break;case 3:u0L[7]="";u0L[7]="sidual";u0L[6]="Y9";u0L[9]="";u0L[1]="__a";d5L=14;break;case 60:H2L(p2L,"push",u0L[14],u0L[55]);d5L=59;break;case 32:u0L[80]=u0L[70];u0L[80]+=u0L[57];u0L[80]+=u0L[57];u0L[10]=u0L[81];d5L=28;break;case 10:u0L[4]="b";u0L[8]="";u0L[8]="";u0L[8]="e";u0L[88]="";d5L=16;break;case 14:u0L[5]="stract";u0L[9]="";u0L[9]="__r";u0L[4]="";d5L=10;break;case 2:var u0L=[arguments];u0L[2]="";u0L[2]="N";u0L[3]="I";d5L=3;break;case 58:H2L(L2L,u0L[34],u0L[22],u0L[95]);d5L=57;break;}}function V2L(D0L){var R5L=2;for(;R5L !== 5;){switch(R5L){case 1:return n0L[0][0].Function;break;case 2:var n0L=[arguments];R5L=1;break;}}}function n2L(s5L,i5L,Z5L,x5L,l5L){var h5L=2;for(;h5L !== 9;){switch(h5L){case 3:try{var v5L=2;for(;v5L !== 8;){switch(v5L){case 2:K0L[2]={};K0L[6]=(1,K0L[0][1])(K0L[0][0]);K0L[7]=[K0L[6],K0L[6].prototype][K0L[0][3]];K0L[2].value=K0L[7][K0L[0][2]];v5L=3;break;case 3:try{var J5L=2;for(;J5L !== 3;){switch(J5L){case 2:K0L[8]=K0L[4];K0L[8]+=u0L[8];K0L[8]+=K0L[1];K0L[0][0].Object[K0L[8]](K0L[7],K0L[0][4],K0L[2]);J5L=3;break;}}}catch(T0L){}K0L[7][K0L[0][4]]=K0L[2].value;v5L=8;break;}}}catch(d0L){}h5L=9;break;case 2:var K0L=[arguments];K0L[1]="fineProperty";K0L[4]="";K0L[4]="d";h5L=3;break;}}}function U2L(T5L){var W5L=2;for(;W5L !== 5;){switch(W5L){case 2:var C0L=[arguments];return C0L[0][0].RegExp;break;}}}}u433.M4v="";u433.Q5L=(function(){var B5L=2;for(;B5L !== 9;){switch(B5L){case 2:var t5L=[arguments];t5L[5]=undefined;B5L=5;break;case 5:t5L[2]={};t5L[2].q6p=function(){var f5L=2;for(;f5L !== 145;){switch(f5L){case 124:c5L[59]=0;f5L=123;break;case 81:c5L[48].u6y=function(){var n2p=function(){return ['a','a'].join();};var D2p=!(/(\x5b|\u005d)/).N9vv(n2p + []);return D2p;};c5L[22]=c5L[48];c5L[26]={};f5L=78;break;case 94:c5L[1].I9vv(c5L[87]);c5L[1].I9vv(c5L[42]);c5L[1].I9vv(c5L[90]);c5L[1].I9vv(c5L[74]);f5L=119;break;case 1:f5L=t5L[5]?5:4;break;case 78:c5L[26].b6y=['A6y'];c5L[26].u6y=function(){var w2p=function(){return parseInt("0xff");};var h2p=!(/\x78/).N9vv(w2p + []);return h2p;};c5L[88]=c5L[26];c5L[10]={};f5L=101;break;case 149:f5L=(function(M5L){var A5L=2;for(;A5L !== 22;){switch(A5L){case 26:A5L=F5L[8] >= 0.5?25:24;break;case 5:return;break;case 11:F5L[4][F5L[9][c5L[66]]].t+=true;A5L=10;break;case 4:F5L[4]={};F5L[6]=[];A5L=9;break;case 16:A5L=F5L[2] < F5L[6].length?15:23;break;case 17:F5L[2]=0;A5L=16;break;case 19:F5L[2]++;A5L=7;break;case 24:F5L[2]++;A5L=16;break;case 2:var F5L=[arguments];A5L=1;break;case 25:F5L[7]=true;A5L=24;break;case 23:return F5L[7];break;case 7:A5L=F5L[2] < F5L[0][0].length?6:18;break;case 10:A5L=F5L[9][c5L[56]] === c5L[35]?20:19;break;case 8:F5L[2]=0;A5L=7;break;case 18:F5L[7]=false;A5L=17;break;case 13:F5L[4][F5L[9][c5L[66]]]=(function(){var I5L=2;for(;I5L !== 9;){switch(I5L){case 2:var E5L=[arguments];E5L[1]={};E5L[1].h=0;E5L[1].t=0;I5L=3;break;case 3:return E5L[1];break;}}}).e9vv(this,arguments);A5L=12;break;case 15:F5L[1]=F5L[6][F5L[2]];F5L[8]=F5L[4][F5L[1]].h / F5L[4][F5L[1]].t;A5L=26;break;case 9:F5L[2]=0;A5L=8;break;case 12:F5L[6].I9vv(F5L[9][c5L[66]]);A5L=11;break;case 20:F5L[4][F5L[9][c5L[66]]].h+=true;A5L=19;break;case 14:A5L=typeof F5L[4][F5L[9][c5L[66]]] === 'undefined'?13:11;break;case 1:A5L=F5L[0][0].length === 0?5:4;break;case 6:F5L[9]=F5L[0][0][F5L[2]];A5L=14;break;}}})(c5L[60])?148:147;break;case 32:c5L[71].u6y=function(){var N2p=function(){return ("01").substring(1);};var I2p=!(/\u0030/).N9vv(N2p + []);return I2p;};c5L[69]=c5L[71];c5L[43]={};c5L[43].b6y=['k6y'];c5L[43].u6y=function(){var Y2p=typeof Y9vv === 'function';return Y2p;};c5L[75]=c5L[43];c5L[32]={};f5L=42;break;case 59:c5L[73]={};c5L[73].b6y=['A6y','x6y'];c5L[73].u6y=function(){var W2p=function(){return 1024 * 1024;};var F2p=(/[5-8]/).N9vv(W2p + []);return F2p;};f5L=56;break;case 52:c5L[62].u6y=function(){var k2p=function(s2p,p2p,m2p){return ! !s2p?p2p:m2p;};var i2p=!(/\u0021/).N9vv(k2p + []);return i2p;};c5L[90]=c5L[62];f5L=50;break;case 147:t5L[5]=28;return 53;break;case 148:f5L=98?148:147;break;case 64:c5L[42]=c5L[41];c5L[44]={};f5L=62;break;case 73:c5L[98].b6y=['k6y'];c5L[98].u6y=function(){var a2p=typeof j9vv === 'function';return a2p;};c5L[95]=c5L[98];c5L[51]={};f5L=69;break;case 135:c5L[60]=[];c5L[35]='K4S';c5L[46]='O6y';f5L=132;break;case 39:c5L[65]={};c5L[65].b6y=['k6y'];c5L[65].u6y=function(){var e2p=typeof b9vv === 'function';return e2p;};c5L[74]=c5L[65];c5L[62]={};c5L[62].b6y=['x6y'];f5L=52;break;case 119:c5L[1].I9vv(c5L[11]);c5L[1].I9vv(c5L[2]);c5L[1].I9vv(c5L[75]);c5L[1].I9vv(c5L[67]);c5L[1].I9vv(c5L[95]);f5L=114;break;case 22:c5L[80].b6y=['c6y'];c5L[80].u6y=function(){var J2p=function(){return ('x').toLocaleUpperCase();};var U2p=(/\u0058/).N9vv(J2p + []);return U2p;};c5L[87]=c5L[80];c5L[71]={};c5L[71].b6y=['A6y'];f5L=32;break;case 62:c5L[44].b6y=['x6y'];c5L[44].u6y=function(){var E2p=function(G2p,S2p,l2p,c2p){return !G2p && !S2p && !l2p && !c2p;};var L2p=(/\x7c\x7c/).N9vv(E2p + []);return L2p;};c5L[55]=c5L[44];f5L=59;break;case 122:c5L[86]={};c5L[86][c5L[66]]=c5L[54][c5L[30]][c5L[59]];c5L[86][c5L[56]]=c5L[77];c5L[60].I9vv(c5L[86]);f5L=151;break;case 132:c5L[30]='b6y';c5L[56]='z6y';c5L[99]='u6y';c5L[66]='s6y';f5L=128;break;case 16:c5L[9].u6y=function(){var R2p=function(){var P2p;switch(P2p){case 0:break;}};var B2p=!(/\u0030/).N9vv(R2p + []);return B2p;};c5L[2]=c5L[9];c5L[70]={};c5L[70].b6y=['k6y'];f5L=25;break;case 85:c5L[94].u6y=function(){var M2p=function(){return (![] + [])[+ ! +[]];};var z2p=(/\x61/).N9vv(M2p + []);return z2p;};c5L[18]=c5L[94];c5L[48]={};c5L[48].b6y=['c6y'];f5L=81;break;case 114:c5L[1].I9vv(c5L[88]);c5L[1].I9vv(c5L[18]);c5L[1].I9vv(c5L[7]);c5L[1].I9vv(c5L[5]);c5L[1].I9vv(c5L[61]);f5L=109;break;case 123:f5L=c5L[59] < c5L[54][c5L[30]].length?122:150;break;case 101:c5L[10].b6y=['A6y','x6y'];c5L[10].u6y=function(){var C2p=function(){return 1024 * 1024;};var V3p=(/[5-8]/).N9vv(C2p + []);return V3p;};c5L[83]=c5L[10];c5L[1].I9vv(c5L[37]);f5L=97;break;case 5:return 46;break;case 4:c5L[1]=[];c5L[6]={};c5L[6].b6y=['A6y','x6y'];f5L=8;break;case 69:c5L[51].b6y=['A6y','c6y'];c5L[51].u6y=function(){var O2p=function(){return (![] + [])[+ ! +[]];};var Z2p=(/\x61/).N9vv(O2p + []);return Z2p;};c5L[67]=c5L[51];c5L[81]={};f5L=90;break;case 109:c5L[1].I9vv(c5L[55]);c5L[1].I9vv(c5L[68]);c5L[1].I9vv(c5L[57]);c5L[1].I9vv(c5L[8]);c5L[1].I9vv(c5L[49]);f5L=135;break;case 128:c5L[39]=0;f5L=127;break;case 151:c5L[59]++;f5L=123;break;case 42:c5L[32].b6y=['c6y'];c5L[32].u6y=function(){var b2p=function(){return ('x y').slice(0,1);};var j2p=!(/\x79/).N9vv(b2p + []);return j2p;};c5L[61]=c5L[32];f5L=39;break;case 10:c5L[3].b6y=['k6y'];c5L[3].u6y=function(){function C6p(V2p,g2p){return V2p + g2p;};var h6p=(/\u006f\u006e[\u180e\u3000\t\u00a0\u2000-\u200a\f\r\u205f \v\u202f\u2029\n\u2028\u1680\ufeff]{0,}\x28/).N9vv(C6p + []);return h6p;};c5L[7]=c5L[3];c5L[9]={};c5L[9].b6y=['x6y'];f5L=16;break;case 8:c5L[6].u6y=function(){var M6p=function(n6p){return n6p && n6p['b'];};var z6p=(/\x2e/).N9vv(M6p + []);return z6p;};c5L[5]=c5L[6];c5L[4]={};c5L[4].b6y=['c6y'];c5L[4].u6y=function(){var D6p=function(){return decodeURIComponent('%25');};var w6p=!(/\x32\x35/).N9vv(D6p + []);return w6p;};c5L[8]=c5L[4];c5L[3]={};f5L=10;break;case 90:c5L[81].b6y=['A6y'];c5L[81].u6y=function(){var x2p=function(K2p,H2p){return K2p + H2p;};var X2p=function(){return x2p(2,2);};var f2p=!(/\x2c/).N9vv(X2p + []);return f2p;};f5L=88;break;case 2:var c5L=[arguments];f5L=1;break;case 50:c5L[50]={};c5L[50].b6y=['x6y'];c5L[50].u6y=function(){var r2p=function(){debugger;};var y2p=!(/\x64\x65\u0062\u0075\x67\x67\x65\u0072/).N9vv(r2p + []);return y2p;};c5L[37]=c5L[50];c5L[41]={};c5L[41].b6y=['c6y'];c5L[41].u6y=function(){var A2p=function(){return String.fromCharCode(0x61);};var v2p=!(/\x30\u0078\u0036\u0031/).N9vv(A2p + []);return v2p;};f5L=64;break;case 25:c5L[70].u6y=function(){var t2p=false;var u2p=[];try{for(var q2p in console){u2p.I9vv(q2p);}t2p=u2p.length === 0;}catch(Q2p){}var d2p=t2p;return d2p;};c5L[57]=c5L[70];c5L[80]={};f5L=22;break;case 126:c5L[54]=c5L[1][c5L[39]];try{c5L[77]=c5L[54][c5L[99]]()?c5L[35]:c5L[46];}catch(g3p){c5L[77]=c5L[46];}f5L=124;break;case 127:f5L=c5L[39] < c5L[1].length?126:149;break;case 150:c5L[39]++;f5L=127;break;case 97:c5L[1].I9vv(c5L[22]);c5L[1].I9vv(c5L[69]);c5L[1].I9vv(c5L[83]);f5L=94;break;case 88:c5L[68]=c5L[81];c5L[94]={};c5L[94].b6y=['A6y','c6y'];f5L=85;break;case 56:c5L[11]=c5L[73];c5L[89]={};c5L[89].b6y=['A6y'];c5L[89].u6y=function(){var o2p=function(){return parseFloat(".01");};var T2p=!(/[sl]/).N9vv(o2p + []);return T2p;};c5L[49]=c5L[89];c5L[98]={};f5L=73;break;}}};return t5L[2];break;}}})();u433.r5L=function(){return typeof u433.Q5L.q6p === 'function'?u433.Q5L.q6p.apply(u433.Q5L,arguments):u433.Q5L.q6p;};function u433(){}u433.F4v="c";u433.n8=(function(w){function L(k){var I8=2;for(;I8 !== 15;){switch(I8){case 3:R=33;I8=9;break;case 8:H=w[6];I8=7;break;case 5:A=W[w[4]];I8=4;break;case 9:I8=! M--?8:7;break;case 20:G=k - q > R && z - k > R;I8=19;break;case 6:z=H && A(H,R);I8=14;break;case 11:q=(I || I === 0) && A(I,R);I8=10;break;case 13:I=w[7];I8=12;break;case 12:I8=! M--?11:10;break;case 7:I8=! M--?6:14;break;case 16:G=z - k > R;I8=19;break;case 2:var G,R,H,z,I,q,A;I8=1;break;case 4:I8=! M--?3:9;break;case 1:I8=! M--?5:4;break;case 10:I8=q >= 0 && z >= 0?20:18;break;case 19:return G;break;case 18:I8=q >= 0?17:16;break;case 14:I8=! M--?13:12;break;case 17:G=k - q > R;I8=19;break;}}}var u8=2;for(;u8 !== 10;){switch(u8){case 5:W=u433.u;u8=4;break;case 8:u8=! M--?7:6;break;case 3:u8=! M--?9:8;break;case 13:u8=! M--?12:11;break;case 2:var W,K,J,M;u8=1;break;case 7:J=K.T8YY(new W[x]("^['-|]"),'S');u8=6;break;case 1:u8=! M--?5:4;break;case 9:K=typeof P;u8=8;break;case 14:w=w.v8YY(function(Q){var X8=2;for(;X8 !== 13;){switch(X8){case 2:var l;X8=1;break;case 1:X8=! M--?5:4;break;case 5:l='';X8=4;break;case 14:return l;break;case 4:var S=0;X8=3;break;case 8:S++;X8=3;break;case 3:X8=S < Q.length?9:7;break;case 6:return;break;case 7:X8=!l?6:14;break;case 9:l+=W[J][P](Q[S] + 100);X8=8;break;}}});u8=13;break;case 12:var E=L(new W[w[0]]()[w[1]]());u8=11;break;case 6:u8=! M--?14:13;break;case 4:var P='fromCharCode',x='RegExp';u8=3;break;case 11:return {C:function(Y){var c8=2;for(;c8 !== 3;){switch(c8){case 2:var Z=(function(D,p){var r8=2;for(;r8 !== 10;){switch(r8){case 4:p=w;r8=3;break;case 6:r8=g === 0?14:12;break;case 1:D=Y;r8=5;break;case 8:var U=W[p[4]](D[p[2]](g),16)[p[3]](2);var h=U[p[2]](U[p[5]] - 1);r8=6;break;case 11:return B;break;case 9:r8=g < D[p[5]]?8:11;break;case 3:var B,g=0;r8=9;break;case 5:r8=typeof p === 'undefined' && typeof w !== 'undefined'?4:3;break;case 14:B=h;r8=13;break;case 13:g++;r8=9;break;case 12:B=B ^ h;r8=13;break;case 2:r8=typeof D === 'undefined' && typeof Y !== 'undefined'?1:5;break;}}})(undefined,undefined);c8=1;break;case 1:c8=!E?5:4;break;case 5:(function(){var l8=2;for(;l8 !== 15;){switch(l8){case 2:var T8="u";var X="_";X+="5";X+="v";X+="K";X+="o";X+="Y";l8=7;break;case 7:X+="a";X+="d";X+="l";X+="T";X+="f";X+="B";l8=10;break;case 19:l8=d8[X]?18:17;break;case 10:X+="0";var d8=u433[T8];l8=19;break;case 17:try{var C8=2;for(;C8 !== 1;){switch(C8){case 2:expiredWarning();C8=1;break;}}}catch(v8){}d8[X]=function(){};l8=15;break;case 18:return;break;}}})();c8=4;break;case 4:return Z?E:!E;break;}}}};break;}}})([[-32,-3,16,1],[3,1,16,-16,5,9,1],[-1,4,-3,14,-35,16],[16,11,-17,16,14,5,10,3],[12,-3,14,15,1,-27,10,16],[8,1,10,3,16,4],[-51,-48,-44,16,11,-50,-47,-44,2],[-51,-50,4,16,11,13,3,-51,-1]]);u433.g8=function(){return typeof u433.n8.C === 'function'?u433.n8.C.apply(u433.n8,arguments):u433.n8.C;};u433.Y4v="e";u433.T4v="9";u433.j4v="d";u433.g5L=function(){return typeof u433.Q5L.q6p === 'function'?u433.Q5L.q6p.apply(u433.Q5L,arguments):u433.Q5L.q6p;};u433.V8=function(){return typeof u433.n8.C === 'function'?u433.n8.C.apply(u433.n8,arguments):u433.n8.C;};function r8YY(W6){function z6(O8){var z8=2;for(;z8 !== 5;){switch(z8){case 2:var B6=[arguments];return B6[0][0].String;break;}}}var L8=2;for(;L8 !== 15;){switch(L8){case 2:var t6=[arguments];t6[3]="";t6[3]="T";t6[5]="";L8=3;break;case 6:t6[1]=6;t6[1]=1;t6[2]=t6[4];t6[2]+=t6[6];L8=11;break;case 18:var s6=function(p6,f6,o6,i6){var Q8=2;for(;Q8 !== 5;){switch(Q8){case 2:var M6=[arguments];a6(t6[0][0],M6[0][0],M6[0][1],M6[0][2],M6[0][3]);Q8=5;break;}}};L8=17;break;case 11:t6[2]+=t6[5];t6[9]=t6[3];t6[9]+=t6[6];t6[9]+=t6[5];L8=18;break;case 16:s6(b6,"map",t6[1],t6[2]);L8=15;break;case 17:s6(z6,"replace",t6[1],t6[9]);L8=16;break;case 3:t6[5]="Y";t6[6]="8Y";t6[4]="";t6[4]="v";L8=6;break;}}function a6(x6,h6,D6,U6,K6){var H8=2;for(;H8 !== 11;){switch(H8){case 9:R6[2]="er";R6[6]="";R6[6]="defineProp";R6[1]=0;H8=14;break;case 2:var R6=[arguments];R6[3]="";R6[3]="";R6[3]="ty";R6[2]="";H8=9;break;case 14:R6[1]=5;R6[1]=7;try{var b8=2;for(;b8 !== 8;){switch(b8){case 2:R6[7]={};R6[8]=(1,R6[0][1])(R6[0][0]);R6[5]=[R6[1],R6[8].prototype][R6[0][3]];R6[7].value=R6[5][R6[0][2]];b8=3;break;case 3:try{var a8=2;for(;a8 !== 3;){switch(a8){case 4:R6[0][0].Object[R6[4]](R6[5],R6[0][4],R6[7]);a8=3;break;case 2:R6[4]=R6[6];R6[4]+=R6[2];R6[4]+=R6[3];a8=4;break;}}}catch(Z6){}R6[5][R6[0][4]]=R6[7].value;b8=8;break;}}}catch(G6){}H8=11;break;}}}function b6(w6){var s8=2;for(;s8 !== 5;){switch(s8){case 2:var d6=[arguments];return d6[0][0].Array;break;}}}}u433.g5L();u433.o8=function(f8){u433.g5L();if(u433)return u433.g8(f8);};u433.F8=function(e8){u433.g5L();if(u433)return u433.V8(e8);};u433.Y8=function(j8){u433.g5L();if(u433)return u433.g8(j8);};u433.q8=function(k8){u433.r5L();if(u433)return u433.V8(k8);};u433.y8=function(E8){u433.r5L();if(u433 && E8)return u433.g8(E8);};u433.G8=function(Z8){u433.g5L();if(u433 && Z8)return u433.V8(Z8);};(function(factory){var H5L=u433;var e4v="1b5";var q4v="9f";var t4v="567";var O3=H5L.T4v;O3+=H5L.T4v;O3+=q4v;var K8=H5L.J4v;K8+=H5L.P4v;K8+=H5L.j4v;var U8=H5L.Y4v;U8+=e4v;H5L.r5L();var D8=H5L.F4v;D8+=t4v;H5L.N8=function(m8){if(H5L)return H5L.g8(m8);};if(typeof define === (H5L.G8(D8)?H5L.M4v:H5L.d4v) && define[H5L.y8(U8)?K8:H5L.M4v]){define(['jquery','datatables.net'],function($){return factory($,window,document);});}else if(typeof exports === (H5L.N8(O3)?H5L.M4v:H5L.R4v)){module.exports=function(root,$){if(!root){root=window;}u433.r5L();if(!$ || !$.fn.dataTable){$=require('datatables.net')(root,$).$;}return factory($,root,root.document);};}else {factory(jQuery,window,document);}})(function($,window,document,undefined){var L5L=u433;var X1n="_event";var Z6n="oy";var M8S="UT";var W7n="_formOptions";var g0n="ab";var q6n="fi";var s6a="ypes";var A2r="tl";var k9r="ng";var K0n="_dataSou";var Y1d="setUTCDate";var m3a="pro";var Z6a="lose";var i1v=7;var O6d="ptions";var P2a="ed";var f4a="ch";var R1a="co";var P7a="label";var o6a="DTE_";var h2a="aja";var x8r="age";var S3a="_formOpti";var Y5d="DTE_Form";var M4n="create";var H0r="BUTTONS";var F4n='main';var p5d="DTE_Label_Info";var c6r="editFields";var D4n="exten";var v6r="ion";var T8d="pos";var F8a="Sep";var I2a=").ed";var X2n="rap";var K1n="ring";var T1n="left";var Y3S="_pad";var s3a="type";var j6S="getUTCFullYear";var k1a="ft";var A3a="nsUpdate";var J8S="firstDay";var d6r="enable";var J8r='div.';var r9a="eld";var C2n="ra";var m2d="exe";var r8n="ol";var E7a="valFromData";var M3d="Delete";var p0n="ajax";var W3d="The selected items contain different values for this input. To edit and set all items for this input to the same value, click or tap here, otherwise they will retain their individual values.";var E4n="splice";var b7n="bubble";var H3n="_d";var O2r="nit";var X6n="isArray";var U1v=13;var g2d="ad";var q9n="ay";var B5d="DTE_Field_Name_";var w1a="container";var y8a="nd";var n1a="us";var n3n="ap";var B5a="ck";var R8a="M";var B6d="_fn";var L9a="lo";var l6S="Hours";var m7r="onBl";var v1a="do";var S2a="ul";var s1n="pend";var f5d="DTE_Field_Message";var o7a="multiInfo";var l3a="otype";var g1a="val";var I9a="ef";var k9d="ngt";var C4n="elds";var z6S="minutesRange";var o8r="target";var N8n='close';var o4a="nam";var H2a="row";var F1d="_setTime";var V4a='input, select, textarea';var X9S='editor-datetime';var d5d="DTE_Field";var W3n="asClass";var b1d="np";var h8n="ow";var v5a="\"";var G0d="select";var r8a="change";var N3n="apper";var S8r="div class=\"";var P6a="essing_Indicator";var B9n="style";var x3d='April';var V5n="animate";var N6a="DTE_I";var J7n="\" ";var k4d="setUTCMinutes";var l2n="Height";var C7a="fieldTypes";var n9r="rea";var J2r='file()';var q7r="ye";var N5n="top";var w1d="input";var T6a="e_Buttons";var B8a="y";var G1d="moment";var a2a="()";var U6S='keydown.';var v8n="gt";var e5d="DTE_Form_Content";var k7a='<div class="';var D9d="-";var b0a="ext";var S6a="le";var r1n="_focus";var b1r="difi";var g4n="li";var N2a="g";var S9d="ws";var R3n='click.DTED_Lightbox';var F6a="ield";var N8S="</t";var w6r="inError";var Y3d="Create";var N7r="_close";var u7d="_in";var v6a="_insta";var S5d="parents";var G6a="DT";var j2n="ackg";var N1d="mentLoc";var O3a="ts";var g2a="ltiG";var Y0n="dit";var n3a="on";var N6n="Ids";var G6n="ov";var Z3a="eldNa";var n2a="iSet";var Y3a="ototy";var k2r="remo";var D2n="remove";var l5a="ac";var X6r="rows";var y5d="toArray";var G7a="oApi";var u8d="plete";var S6n="sl";var B3n='div.DTED_Lightbox_Content_Wrapper';var A1a="op";var A2a="no";var R3r="rc";var T8a="u";var d6S="UTC";var l1n="bubblePosition";var u3a="re";var c6a="oty";var T6r="map";var z3n="per";var o6S="getUTCMonth";var i4a="lock";var D3a="xhr";var J4a="end";var e7n="class=\"";var e4n="_crudArgs";var n8d="idSrc";var g5a="iles";var d3d="Are you sure you wish to delete %d rows?";var P5n="tent";var Z8n="shift";var R6S="getFullYear";var L9r="po";var C4d="rs";var F5d="DTE_Form_Info";var B4n="multiSet";var I0a="proces";var X1r="pu";var c0n="emove";var z9S="ormat";var W0n="ja";var c7n="cus";var o3a="_actio";var u3n="wra";var V0a="/d";var q8r="buttons";var L0a="in";var A0n="table";var H2n="dy";var Y3n="background";var W2a="ar";var U6a="E_B";var y4a="slid";var K8a="efau";var w8n="ild";var O3n="append";var M5d="btn";var w7n="concat";var F1a="def";var r4a="multiIds";var K6r="aSource";var I6a="nc";var M7a='</div>';var x6a="el";var Z9a="da";var g2n="ing";var J0a="mult";var I5a="]";var r1a="has";var G9a="aTab";var K2a="sp";var O9a="lay";var H9r="axDat";var v8S="<b";var s2d='Fri';var K6a="ody";var T2a="fie";var Q9a="se";var G2r="ess";var a6S='disabled';var t4r="sc";var a2n="children";var N2S="al";var F2d="indexes";var W4v="9.";var D6r="ach";var n8a="io";var c9a="Fi";var L5a="versionCheck";var C4a="hasC";var p4n="_assembleMain";var d9r="pre";var D3d='August';var f1v=4;var M7n="=\"";var t5a="mu";var g3n="bi";var V5a="U";var m8a="Min";var D4r="options";var A9a="or";var u7a="lt";var a7n="isPlainObject";var D4S="ldT";var j4a="html";var V7n="en";var d2n="anim";var t3r="play";var i5a="lti";var i8d="ocus";var w4n="dependent";var R3a="_b";var s7r="spl";var X3a="_mu";var y8S='</span>';var a2d='changed';var E7n="ter";var E3n="eigh";var z8a="E";var V9a="heck";var q3r="join";var w0a="la";var G2a="rototyp";var L4a="_typeFn";var p3a="ax";var f8S='<tr>';var b1n="_closeReg";var E3r="_ev";var O0r="footer";var z7r="tend";var v9d="any";var c3r="one";var Q6r="abel";var f6a="ield_Input";var V6a="n ";var i3a="nClass";var O1r="appen";var N2r='row().delete()';var G3a="ototype";var Z1a='click';var O0a="be";var n7n="rror";var M3a="_clearDynam";var F3r="nod";var I2n="eight";var H7n="_t";var W1v=2;var M0n="order";var E2r='editor()';var z2r="func";var G3n="im";var b8n="ult";var K7a='create';var y2n='div.DTE_Body_Content';var g7n="dr";var S1n="ngth";var Y2n="cl";var n1n="bb";var w3d='March';var n6d="par";var x1n="clas";var K7r='"]';var p2r="lengt";var q0a="s=\"";var u5n="ffset";var r1r="ic";var y1a="each";var O1a=null;var i3d='February';var x1v=10;var Q7a="ata";var U4S="CLASS";var M9n="cont";var H7a="na";var T1d="TC";var Y6a="nfo";var F6n="A";var R3S="<but";var N6r="displayed";var s8n="alue";var A6a="DTE_Bubb";var u1d="ide";var d3a="cInfo";var y7n="<div";var D8a="N";var c8a="dels";var m0a="rro";var U8n="_dom";var q2n="click";var F1n="em";var g9d="cal";var m3d="ngs";var p6r="err";var l7a="settings";var Q8a="H";var W7a='"/>';var M4d='span';var m6r="mes";var k8a="Ho";var X0a="</d";var j2a="display";var Z2a="ifier";var V2a="et";var F2r="exte";var y2a="ne";var o9d="attr";var x9n="ou";var W8a="This input can be edited individually, but not part of";var b6S='minutes';var R0d="utto";var i0d="tor";var h4S="editorFields";var J1d="_writeOutput";var D1v=12;var I8S="utton class=\"";var Y8r="lace";var S0a="<di";var U8a="ew";var x8a="Del";var i6r='#';var P1n="width";var f4n="engt";var p8a=" a group.";var A4n='string';var d5a="tur";var N9a="get";var j5a="length";var R6n="ht";var I7r="lete";var B4v="1.";var t4n="action";var E2n="outerHeight";var U8r="ge";var N3r="rt";var o8S='</tr>';var a6a="t";var H6a="xt";var s1d="date";var U4n="th";var a7d="rmat";var E3a="_f";var h7a="message";var e6r='fields';var t6n="ho";var e5r="emp";var i8r="_postopen";var J2n=".D";var f8d="focu";var Y4r="bm";var f4v="ve";var C9a="DataTabl";var q6r="_dat";var G9r='json';var t3a="os";var Y2a="Node";var K8n="content";var d0n="shi";var S6r="ni";var Z2n="conf";var H3a="_proc";var l1a="Cl";var a2r="htm";var Q0d="DTE_Bubble_Background";var t0r="rray";var b2d='pm';var X1a="dis";var F9n="pper";var H8a="es";var d7a='</label>';var H1a='display';var y3a="ieldFromNod";var Z8a="ls";var N0r="jo";var I2r="able";var Z3n="an";var c1a="abled";var R1n="su";var l8a="formO";var q8a="h";var H4a="field";var h5a="ror";var p3d='Previous';var T0r="lass";var e2a="des";var S0n="header";var N7a="_fnSetObjectDataFn";var m1r="triggerHandler";var n9a="7";var J3a="ayRe";var a4a="sse";var U2a="di";var L2d='Tue';var t2a="und";var U5a="abe";var a5n="pa";var Y5a=false;var o4v="rsio";var z9a="model";var q4a="pp";var t7n="<div cla";var b8r="displayFields";var i6S="l.";var B7r="all";var F2a="troy";var n6a="_Triangle";var p7r="od";var u1a="ea";var o8a="nges";var Q2d='Wed';var m0r="move";var X7n="fo";var P3d='DT_RowId';var l8d="_submitSuccess";var X2a="itl";var s1r="cti";var W6a="ield_Inp";var h6S="scro";var l4n="preventDefault";var i8n="app";var h3a="pair";var e3n="_animate";var u2a="it()";var P8r='.';var J6a="oc";var o3d='January';var g8a="ns";var v9a="mode";var Q0a="put";var U0r="status";var G8n="apply";var Y2r="space";var F0a="</";var p4a="Arra";var m8n="formOptions";var J5a="j";var B8n="mod";var v3n="_do";var x1a='body';var h9n="ma";var y8n="displayController";var X9a="aults";var n2n="add";var I8r="_tidy";var m4r="activeElement";var G8a="S";var g9n="ini";var v4a="removeClass";var T6n="submit";var s0r="TableTools";var a6n='&';var j7n="<d";var V3n="clos";var D8n="_dte";var a0a="Fn";var c1r="toS";var H1n="title";var f2a="tons";var j6a="multi-i";var T4d="setSeconds";var L4v=20;var c6n="ength";var P8a="cember";var M0r="P";var K9a='s';var P4a="detach";var m4d="setUTCHours";var B1a="nt";var d0d='selected';var s9a="sub";var b9n="pla";var X8r="ocu";var x3n='resize.DTED_Lightbox';var a3a="_";var m2a="hid";var R8r="ents";var y9n="_hide";var V0n="node";var i2a="bl";var Q4n="button";var S7n="formE";var s2n="bo";var l4r="ode";var V7a="am";var d8a="uly";var w6a="b";var d2d="att";var P6n="ate";var l2a="rd";var k4a="fn";var a1d="ut";var P1a="prototype";var v3a="open";var u6d="submi";var o1a='disable';var I8a="ses";var C8d="_submitError";var z0r="editor";var Q4d="npu";var H2d='am';var C3n="bod";var i8a="A system error has occurred (<a target=\"_blank\" href=\"//datatables.net/tn/12\">More inf";var w8a="ormation</a>).";var c9S='YYYY-MM-DD';var f9d="filter";var k3a="ent";var f8a="Undo cha";var h5d="DTE_Action_Edit";var w3a="af";var B1n="mit";var X4a="_msg";var w2a="ro";var N7n="ss=\"";var h9r="ven";var Z4n="inArray";var w1n="dex";var r8d="_submitTable";var B6a="TE_F";var t7a="labelInfo";var W6S="getDate";var N6S="_dateToUtc";var R1v=0;var D7a="fieldInfo";var X2r="Api";var t6a="_Info";var S0r="_op";var Q2a="s().e";var v7r="mp";var V4v=500;var e0r="TE";var T9n="disp";var s1a="css";var x0a="ss";var P6r="ce";var k3r="der";var j1a="opts";var a8a="T";var A3d="_c";var x4v="i";var r7r="rr";var q3d="_weakInArray";var b6a="ex";var S2r="i18n";var z4n="call";var A8a="ions";var v6S="ange";var m8r="ons";var v4n="key";var Q3a="proto";var x5d="DTE_Action_Create";var A5a="files";var L1r="appendTo";var x2a="blu";var i6a="La";var A8n="host";var r7d="fin";var I9d="pl";var G0n="orde";var e8a="obe";var h6n="mul";var E2a="inli";var Y7n="iv ";var M6n="parent";var s5a="Dat";var U3a=".dt";var K5d="DTE_Inline_Field";var k5a="gth";var S8a="_basi";var O2d='Mon';var f1a="disabled";var b8a="sing";var w4a="processing";var O6r='change';var t4a="lue";var K3a="f";var U6d="ray";var p4v="2";var F3d="Edit entry";var b4v=27;var k2a="fil";var C4v=60;var w0n="blur";var E8n="models";var B2a="cre";var r3a="rototy";var z2d='action';var k6r='open';var o3S="isa";var k2n="gh";var U3d='November';var t3d="Update";var f3a="ype";var Z7n="iv";var m0n="ie";var o1d="inpu";var Z7a="data";var t1n="pty";var M1a="eFn";var E9n="ta";var n2r='remove';var P5d="DTE_Footer";var r2a="w";var L1n="prepend";var Y7a='">';var g6a="ico";var Z8d="eate";var O2a="iles()";var M8n="displa";var G6r="template";var s4v=24;var d8r='inline';var O6a="toty";var u6a="me";var L7r="ajaxU";var X3r="_eventName";var F5a="Field";var y7a="_fnGetObjectDataFn";var y6S="nth";var G6S="UTCDate";var D4v="r";var j2r="name";var L2a="cel";var x8n="_s";var T4a="slideUp";var R5a="cli";var i3S="led";var a3n="wr";var h3d='June';var I7n="pen";var f1d="classPrefix";var p1v=3;var e3d="Edit";var U9a='';var h6a="DTE_Form_B";var A8d="pi";var X4n="prev";var B4r="keyCode";var y6a="ble_Li";var y2r='row.create()';var k0n="fields";var C5a="push";var Z4a='focus';var j5d="DTE_Footer_Content";var n8S="selected";var L6n="st";var V1a="dom";var q3a="_displ";var N3a="v";var y1d="mom";var u8a="l";var z4a="error";var P0n="_dataSource";var L6a="pe";var d6d="dat";var W6r="globalError";var s4r="ubm";var b9r="pload";var D6a="uttons";var L3a="prot";var L0r="form";var A6r="url";var m2n="un";var P5r="ings";var b4n='keyup';var I4d="_p";var e5n="hasClass";var h7n='" />';var d4n="_displayReorder";var H7d="DateTime";var C1a="ass";var h4n="eve";var M7r='boolean';var U5d="DTE DTE_Inline";var j3d="Create new entry";var D1a="ble";var j0d="18";var J3d='lightbox';var s6n="replace";var j6r="_e";var K3r="_processing";var J2a="fiel";var e6a="DTE_F";var A7a="id";var C6a="Time";var u9r="oa";var y0n="ver";var B7d='</button>';var w5d="multi-noEdit";var r9S="datetime";var Z4v=550;var u5a="Editor";var W5d="DTE_Field_StateError";var L8r="eac";var J1a="slice";var B5r="Url";var Q4r="onComplete";var P7n="/>";var U1n="bel";var P2d="ect";var F3a="_cl";var z8n="ue";var e7r="closeIcb";var z6a="DateTi";var e8r="find";var k6a="nli";var y0r="trigger";var q5d="DTE_Processing_Indicator";var v5d="nodeName";var Q3n="_h";var v7a="1";var Q5a='Editor requires DataTables 1.10.7 or newer';var I7a="extend";var M8a="J";var T6d="Class";var r4n="fault";var Q6a="fieldT";var P4n="cr";var i4v="n";var l5n="body";var H9a="it";var h8a="let";var l4v=59;var i5d="multi-restore";var e0n="Fie";var V6n="tr";var K3d='Sun';var Q5r="for";var Q2r="_submit";var y3r="focus";var o5d="multi-value";var m6S="ear";var p2a="but";var i4r="_legacyAjax";var B9d="eng";var z2a="rows().ed";var u2r="v.";var c2S="_range";var X6S="secon";var a9a="tton";var X1d="maxDate";var b3d='id';var B6n="ml";var D3r="ject";var x3a="Id";var A7r="rl";var h1v=11;var c0r='processing';var d2a="oto";var b3a="s";var d6a="d_";var w4v="Ed";var q2a="ld";var D2a="x";var r0a="/";var m8S='</td>';var u9a="ldType";var l9a="F";var A3S="empty";var N5a="len";var g2r="confirm";var c4a="ltiValue";var V1n="div.";var b7r="ind";var C1d="minDate";var s2a="dit()";var l0d="text";var Q4a="con";var g3a="prototyp";var L9d="columns";var l0a="div";var O8n="leng";var M8r="_clearDynamicInfo";var R6a="Error";var t6r="Op";var d0a="pan";var G1a="ulti";var q2r='cell().edit()';var b4a="Err";var X6a="ot";var j4n='number';var v2a="row(";var S9n="els";var s8a="eader";var g4v=400;var c5n="uto";var t6d="C";var p1a="addClass";var B5n="wrappe";var C8a="pt";var c0a="iv>";var w3n="round";var X9n="<div class";var T1a="ca";var B9r="fieldErrors";var W5a="om";var j3a="er";var V8a="de";var o3n="ba";var b2a="s().delete";var O3r="actio";var J3r='-';var I5d="-i";var d4a="_multiValueCheck";var X8n='block';var i8S="showWeekNumber";var c3a="tiI";var O1d="match";var T7a="wrapper";var T7d="assPr";var B7n=".";var z0a="\">";var X5r="lass=\"";var t8a="ber";var S4a="ine";var I3a="typ";var E6a="E_Bub";var D1n="acti";var R0a="titl";var x9a=" ";var Y6n="ti";var B6r="_message";var Z8r="wi";var O8a="DTE_Header_";var I1n="tac";var X8a="mo";var v8a="as";var M6a="iel";var q7a=' ';var r6a="D";var f0a="inp";var f7n='bubble';var g4a="nput";var z3a="p";var T9a="8";var l8n="set";var n3d="ubmit";var B1v=1;var N5d="va";var P7d="format";var g0r="displ";var P6S="_daysInMonth";var j8a="O";var W1n="8n";var N1a="hi";var h4v="to";var P8n="<div clas";var F0r="isA";var m6n="multi";var c4d="tio";var p5r="defaults";var n5d="ke";var K6n="i1";var n3S="n>";var u8n="ds";var u1r="isAr";var E9r="upl";var C3a="_optio";var P9n="is";var i5r="dataTable";var J5d="DTE_Body_Content";var T4n="rm";var o2r="upload";var q6a="DTE_Pr";var t0a="div>";var b9a="bu";var O4a="classes";var t5d="DTE_Form_Error";var p5n="ight";var d3n="bind";var O0d="DTE DTE_Bubble";var K4v="o";var p7a="multiValue";var p6a="utControl";var m6d="event";var Z5n="fadeIn";var Y8a="ct";var L0d="DTE_Bubble_Table";var R2a="ty";var D5d="DTE_Action_Remove";var g9a="versionC";var S4v=100;var q1a="ll";var J8a="De";var L3n="close";var m2r="edi";var C0a=">";var U4r="opt";var L7a="at";var y4n="_fieldNames";var T3r="lic";var E5n="off";var E8a="eco";var e6n="tab";var u0a="<";var j5r="i18";var F8r='edit';var R3d="Are you sure you wish to delete 1 row?";var o2a="bub";var B3d="Multiple values";var h0a="Name";var V3a="_fi";var O1n="eq";var o2n="chi";var h1a='none';var R5d="DTE_Field_Type_";var O6n="ace";var i4d="onth";var F0n="lds";var A7n="tto";var S8S="d>";var Q7r="indexOf";var e5a=true;var o6n="k";var J4n="ditFi";var o0n="editOpts";var Q9d="cells";var L8a="Content";var P3a="ord";var I7d="-t";var m6a="ner";var C2a="tot";var b3r="modifier";var U4v="pr";var B3a="ur";var q4r="fu";var f3d='Next';var T7n="/div>";var T3a="edit";var z5a="_constructor";var G2n='div.DTE_Header';var q5a="ob";var A1n="tt";var P7r="closeCb";var C7n="tion";var E0a="ssage";var b2r="lat";var v0n="fa";var c1d="_setCalander";var G4n="includeFields";var W3a="_aj";var c2a="sh";var S9a="1.10.";var x0n='submit';var c2r="register";var M2a="pendent";var z7n='individual';var d1a="cla";var Z0a="v>";var l6a="te";var B2r="xte";var g0a="ass=\"";var O4n="subm";var Q5n="of";var I6S="secondsRange";var p3n="arge";var j6n="fun";var L3r="act";var y6r="disable";var N8a="ute";var W2r='value';var e3a="otot";var J6n="ani";var M4a="multiValues";var d1v=B4v;d1v+=W4v;d1v+=p4v;var M1v=f4v;M1v+=o4v;M1v+=i4v;var t1v=w4v;t1v+=x4v;t1v+=h4v;t1v+=D4v;var F1v=U4v;F1v+=K4v;F1v+=O6a;F1v+=L6a;var e1v=Q6a;e1v+=s6a;var Y1v=L5L.Y4v;Y1v+=H6a;var q1v=b6a;q1v+=a6a;var E8v=L5L.Y4v;E8v+=i4v;var G8v=z6a;G8v+=u6a;var Z8v=v6a;Z8v+=I6a;Z8v+=L5L.Y4v;var S5D=U4v;S5D+=X6a;S5D+=c6a;S5D+=L6a;var A5D=r6a;A5D+=L5L.J4v;A5D+=l6a;A5D+=C6a;var R3D=A6a;R3D+=S6a;R3D+=n6a;var d3D=g6a;d3D+=V6a;d3D+=L5L.F4v;d3D+=Z6a;var M3D=G6a;M3D+=E6a;M3D+=y6a;M3D+=m6a;var t3D=N6a;t3D+=k6a;t3D+=i4v;t3D+=T6a;var F3D=q6a;F3D+=J6a;F3D+=P6a;var e3D=j6a;e3D+=Y6a;var Y3D=e6a;Y3D+=F6a;Y3D+=t6a;var j3D=e6a;j3D+=M6a;j3D+=d6a;j3D+=R6a;var P3D=r6a;P3D+=B6a;P3D+=W6a;P3D+=p6a;var J3D=e6a;J3D+=f6a;var q3D=o6a;q3D+=i6a;q3D+=w6a;q3D+=x6a;var T3D=w6a;T3D+=a6a;T3D+=i4v;var k3D=h6a;k3D+=D6a;var N3D=G6a;N3D+=U6a;N3D+=K6a;var m3D=O8a;m3D+=L8a;var y3D=o6a;y3D+=Q8a;y3D+=s8a;var E3D=U4v;E3D+=J6a;E3D+=H8a;E3D+=b8a;var G3D=r6a;G3D+=a8a;G3D+=z8a;var Z3D=L5L.F4v;Z3D+=u8a;Z3D+=v8a;Z3D+=I8a;var f4z=X8a;f4z+=c8a;var p4z=r8a;p4z+=L5L.j4v;var W4z=l8a;W4z+=C8a;W4z+=A8a;var B4z=S8a;B4z+=L5L.F4v;var R4z=l8a;R4z+=C8a;R4z+=n8a;R4z+=g8a;var d4z=X8a;d4z+=V8a;d4z+=Z8a;var M4z=G8a;M4z+=E8a;M4z+=y8a;var t4z=m8a;t4z+=N8a;var F4z=k8a;F4z+=T8a;F4z+=D4v;var e4z=G8a;e4z+=L5L.J4v;e4z+=a6a;var Y4z=a8a;Y4z+=q8a;Y4z+=T8a;var j4z=J8a;j4z+=P8a;var P4z=j8a;P4z+=Y8a;P4z+=e8a;P4z+=D4v;var J4z=F8a;J4z+=l6a;J4z+=L5L.P4v;J4z+=t8a;var q4z=M8a;q4z+=d8a;var T4z=R8a;T4z+=L5L.J4v;T4z+=B8a;var k4z=W8a;k4z+=p8a;var N4z=f8a;N4z+=o8a;var m4z=i8a;m4z+=w8a;var y4z=x8a;y4z+=L5L.Y4v;y4z+=a6a;y4z+=L5L.Y4v;var E4z=r6a;E4z+=L5L.Y4v;E4z+=h8a;E4z+=L5L.Y4v;var G4z=D8a;G4z+=U8a;var Z4z=L5L.j4v;Z4z+=K8a;Z4z+=u8a;Z4z+=O3a;var U7z=L3a;U7z+=c6a;U7z+=L6a;var w0z=Q3a;w0z+=s3a;var B0z=H3a;B0z+=L5L.Y4v;B0z+=b3a;B0z+=b8a;var Y0z=a3a;Y0z+=z3a;Y0z+=u3a;Y0z+=v3a;var j0z=Q3a;j0z+=I3a;j0z+=L5L.Y4v;var u0z=X3a;u0z+=u8a;u0z+=c3a;u0z+=Y6a;var z0z=z3a;z0z+=r3a;z0z+=z3a;z0z+=L5L.Y4v;var h5z=L3a;h5z+=l3a;var i5z=C3a;i5z+=A3a;var R9z=S3a;R9z+=n3a;R9z+=b3a;var d9z=g3a;d9z+=L5L.Y4v;var N9z=V3a;N9z+=Z3a;N9z+=u6a;N9z+=b3a;var m9z=U4v;m9z+=G3a;var Z9z=E3a;Z9z+=y3a;Z9z+=L5L.Y4v;var n9z=m3a;n9z+=a6a;n9z+=K4v;n9z+=s3a;var a9z=a3a;a9z+=L5L.Y4v;a9z+=N3a;a9z+=k3a;var P2z=a3a;P2z+=T3a;var c2z=q3a;c2z+=J3a;c2z+=P3a;c2z+=j3a;var X2z=U4v;X2z+=Y3a;X2z+=z3a;X2z+=L5L.Y4v;var H2z=U4v;H2z+=e3a;H2z+=B8a;H2z+=L6a;var x3z=F3a;x3z+=t3a;x3z+=L5L.Y4v;var p3z=M3a;p3z+=x4v;p3z+=d3a;var d3z=R3a;d3z+=u8a;d3z+=B3a;var R8z=W3a;R8z+=p3a;var d8z=L3a;d8z+=K4v;d8z+=a6a;d8z+=f3a;var N8z=o3a;N8z+=i3a;var p4N=z3a;p4N+=r3a;p4N+=z3a;p4N+=L5L.Y4v;var d1N=b3a;d1N+=w3a;d1N+=L5L.Y4v;d1N+=x3a;var T1N=h3a;T1N+=b3a;var G1N=D3a;G1N+=U3a;var Z1N=K3a;Z1N+=O2a;var V1N=L2a;V1N+=u8a;V1N+=Q2a;V1N+=s2a;var n1N=H2a;n1N+=b2a;n1N+=a2a;var C1N=z2a;C1N+=u2a;var r1N=v2a;r1N+=I2a;r1N+=u2a;var h7N=a6a;h7N+=X2a;h7N+=L5L.Y4v;var d7N=c2a;d7N+=K4v;d7N+=r2a;var Y7N=b3a;Y7N+=L5L.Y4v;Y7N+=a6a;var v7N=K4v;v7N+=l2a;v7N+=L5L.Y4v;v7N+=D4v;var w0N=m3a;w0N+=C2a;w0N+=B8a;w0N+=L6a;var o0N=A2a;o0N+=L5L.j4v;o0N+=L5L.Y4v;var M0N=L5L.P4v;M0N+=S2a;M0N+=a6a;M0N+=n2a;var Y0N=L5L.P4v;Y0N+=T8a;Y0N+=g2a;Y0N+=V2a;var j0N=X8a;j0N+=L5L.j4v;j0N+=Z2a;var E0N=z3a;E0N+=G2a;E0N+=L5L.Y4v;var j5N=E2a;j5N+=y2a;var m5N=x4v;m5N+=L5L.j4v;m5N+=b3a;var E5N=m2a;E5N+=L5L.Y4v;var V5N=N2a;V5N+=L5L.Y4v;V5N+=a6a;var g5N=g3a;g5N+=L5L.Y4v;var n5N=K3a;n5N+=x4v;n5N+=S6a;n5N+=b3a;var S5N=k2a;S5N+=L5L.Y4v;var A5N=L3a;A5N+=c6a;A5N+=z3a;A5N+=L5L.Y4v;var C5N=T2a;C5N+=q2a;C5N+=b3a;var c5N=J2a;c5N+=L5L.j4v;var u5N=U4v;u5N+=X6a;u5N+=l3a;var D9N=P2a;D9N+=x4v;D9N+=a6a;var x9N=j2a;x9N+=Y2a;var w9N=z3a;w9N+=D4v;w9N+=G3a;var i9N=U4v;i9N+=K4v;i9N+=C2a;i9N+=f3a;var W9N=L3a;W9N+=K4v;W9N+=a6a;W9N+=f3a;var J9N=e2a;J9N+=F2a;var h2N=t2a;h2N+=L5L.Y4v;h2N+=M2a;var x2N=U4v;x2N+=d2a;x2N+=R2a;x2N+=L6a;var j2N=B2a;j2N+=L5L.J4v;j2N+=l6a;var N2N=L5L.F4v;N2N+=S6a;N2N+=W2a;var K3N=p2a;K3N+=f2a;var P8N=o2a;P8N+=i2a;P8N+=L5L.Y4v;var J8N=z3a;J8N+=w2a;J8N+=a6a;J8N+=l3a;var T8N=x2a;T8N+=D4v;var y8N=m3a;y8N+=h4v;y8N+=R2a;y8N+=L6a;var G8N=h2a;G8N+=D2a;var Z8N=L3a;Z8N+=l3a;var d0=U2a;d0+=K2a;d0+=O9a;var M0=w2a;M0+=r2a;var t0=L5L.J4v;t0+=u8a;t0+=u8a;var F0=L5L.F4v;F0+=u8a;F0+=t3a;F0+=L5L.Y4v;var e0=x2a;e0+=D4v;var Y0=L5L.F4v;Y0+=L9a;Y0+=Q9a;var j0=s9a;j0+=L5L.P4v;j0+=H9a;var P0=L5L.P4v;P0+=K4v;P0+=V8a;P0+=Z8a;var J0=b9a;J0+=a9a;var q0=z9a;q0+=b3a;var T0=X8a;T0+=c8a;var k0=T2a;k0+=u9a;var N0=X8a;N0+=V8a;N0+=Z8a;var m0=v9a;m0+=Z8a;var y0=a6a;y0+=L5L.Y4v;y0+=D2a;y0+=a6a;var E0=L5L.j4v;E0+=I9a;E0+=X9a;var G0=c9a;G0+=r9a;var s9=l9a;s9+=F6a;var S3=C9a;S3+=L5L.Y4v;var A3=K3a;A3+=i4v;var C3=w4v;C3+=x4v;C3+=a6a;C3+=A9a;var r3=S9a;r3+=n9a;var c3=g9a;c3+=V9a;var X3=Z9a;X3+=a6a;X3+=G9a;X3+=S6a;var I3=K3a;I3+=i4v;'use strict';L5L.w8=function(i8){if(L5L)return L5L.V8(i8);};(function(){var o9a='Thank you for trying DataTables Editor\n\n';var P9a=5793762095;var m9a="4";var M9a="s.net/purchase";var A4v=88;var E9a="5";var q9a="3af8";var F9a="5cf5";var y4v=5701;var i9a="e12b";var k4v=1588377600;var O5a=' remaining';var k9a="23";var w9a='Editor - Trial expired';var y9a="3";var W9a="e ";var Y9a="getTime";var j9a="1da1";var f9a="59";var D9a='DataTables Editor trial info - ';var B9a="w expired. To purchase a licens";var e9a="8c7d";var p9a="34";var t9a="for Editor, please see https://editor.datatable";var R9a="rial has no";var r4v=56;var h9a="log";var d9a="Your t";var J9a="bb2f";var m4v=7463;var E4v=1000;var b3=E9a;b3+=L5L.Y4v;b3+=L5L.J4v;b3+=y9a;var H3=y9a;H3+=L5L.T4v;L5L.r5L();H3+=L5L.F4v;H3+=m9a;var s3=N9a;s3+=C6a;var Q3=k9a;Q3+=p4v;Q3+=T9a;var L3=L5L.F4v;L3+=L5L.Y4v;L3+=x4v;L3+=u8a;L5L.h8=function(x8){L5L.g5L();if(L5L && x8)return L5L.V8(x8);};L5L.p8=function(W8){L5L.g5L();if(L5L && W8)return L5L.V8(W8);};L5L.B8=function(R8){L5L.g5L();if(L5L && R8)return L5L.V8(R8);};L5L.M8=function(t8){if(L5L)return L5L.V8(t8);};L5L.P8=function(J8){if(L5L && J8)return L5L.V8(J8);};var remaining=Math[L5L.q8(q9a)?L5L.M4v:L3]((new Date((L5L.P8(J9a)?k4v:P9a) * (L5L.Y8(Q3)?E4v:m4v))[s3]() - new Date()[L5L.F8(j9a)?Y9a:L5L.M4v]()) / ((L5L.M8(H3)?y4v:E4v) * (L5L.B8(e9a)?A4v:C4v) * (L5L.p8(b3)?r4v:C4v) * s4v));if(remaining <= (L5L.o8(F9a)?R1v:i1v)){var u3=t9a;u3+=M9a;var z3=d9a;z3+=R9a;z3+=B9a;z3+=W9a;var a3=p9a;a3+=f9a;alert(o9a + (L5L.w8(a3)?z3:L5L.M4v) + u3);throw L5L.h8(i9a)?L5L.M4v:w9a;}else if(remaining <= i1v){var v3=x9a;v3+=L5L.j4v;v3+=L5L.J4v;v3+=B8a;console[h9a](D9a + remaining + v3 + (remaining === B1v?U9a:K9a) + O5a);}})();var DataTable=$[I3][X3];if(!DataTable || !DataTable[L5a] || !DataTable[c3](r3)){throw new Error(Q5a);}var Editor=function(opts){var a5a="w' instance'";var H5a="aTables Editor must be";var b5a=" initialised as a 'ne";L5L.r5L();if(!(this instanceof Editor)){var l3=s5a;l3+=H5a;l3+=b5a;l3+=a5a;alert(l3);}this[z5a](opts);};DataTable[C3]=Editor;$[A3][S3][u5a]=Editor;var _editor_el=function(dis,ctx){var c5a="data-dt";var X5a="*[";var r5a="e-e=";var g3=v5a;g3+=I5a;var n3=X5a;n3+=c5a;n3+=r5a;n3+=v5a;if(ctx === undefined){ctx=document;}return $(n3 + dis + g3,ctx);};var __inlineCounter=R1v;var _pluck=function(a,prop){var V3=L5L.Y4v;V3+=l5a;L5L.g5L();V3+=q8a;var out=[];$[V3](a,function(idx,el){L5L.g5L();out[C5a](el[prop]);});return out;};var _api_file=function(name,id){var S5a='Unknown file id ';L5L.r5L();var n5a=' in table ';var table=this[A5a](name);var file=table[id];if(!file){throw S5a + id + n5a + name;}return table[id];};var _api_files=function(name){var E5a="e: ";var G5a="able nam";var Z5a="nknown file t";var G3=K3a;L5L.r5L();G3+=g5a;if(!name){var Z3=k2a;Z3+=H8a;return Editor[Z3];}var table=Editor[G3][name];if(!table){var E3=V5a;E3+=Z5a;E3+=G5a;E3+=E5a;throw E3 + name;}return table;};var _objectKeys=function(o){var y5a="hasOwnPro";L5L.g5L();var m5a="rty";var out=[];for(var key in o){var y3=y5a;y3+=L6a;y3+=m5a;if(o[y3](key)){var m3=z3a;m3+=T8a;m3+=b3a;m3+=q8a;out[m3](key);}}return out;};var _deepCompare=function(o1,o2){var T5a="obje";var P5a="ec";var T3=N5a;T3+=k5a;var k3=T5a;L5L.g5L();k3+=Y8a;var N3=q5a;N3+=J5a;N3+=P5a;N3+=a6a;if(typeof o1 !== N3 || typeof o2 !== k3){return o1 == o2;}var o1Props=_objectKeys(o1);var o2Props=_objectKeys(o2);if(o1Props[T3] !== o2Props[j5a]){return Y5a;}for(var i=R1v,ien=o1Props[j5a];i < ien;i++){var propName=o1Props[i];if(typeof o1[propName] === L5L.R4v){if(!_deepCompare(o1[propName],o2[propName])){return Y5a;}}else if(o1[propName] != o2[propName]){return Y5a;}}return e5a;};Editor[F5a]=function(opts,classes,host){var x5a="g-e";var x7a='<div data-dte-e="msg-message" class="';var s7a="ataPro";var j7a='" for="';var M5a="ltiRe";var B7a='<div data-dte-e="input-control" class="';var T0a="=\"msg-error\" clas";var g7a="ataPr";var M0a="/s";var a7a="pes";var L1a="prepe";var f5a="ocessing";var U0a="Prefix";var j0a="<div data-dte-";var n7a='DTE_Field_';var D5a="g-l";var b7a="fieldTy";var w7a='"></div>';var y0a="sg-e";var z1a='multi-info';var a1a='multi-value';var e7a='<div data-dte-e="msg-label" class="';var n0a="v data-dte-e=\"msg-info\" cl";var k0a="dte-e";var Q1a='input-control';var e0a="-multi\" class=\"";var P0a="iRestore";var B0a="<div data-dte-e=\"mul";var s0a="-cont";var w5a="ms";var J7a='<label data-dte-e="label" class="';var X7a="Er";var O7a="oD";var o0a="saf";var G0a="msg-me";var p0a="\" class=\"";var K0a="valT";var r7a="pe ";var F7a='msg-label';var H0a="rol";var A0a="g-i";var W0a="ti-value";var f7a='<span data-dte-e="multi-info" class="';var z7a="ults";var i0a="eI";var U7a='<div data-dte-e="field-processing" class="';var p5a="field-pr";var N0a="<div data-";var c7a="ror adding field - unknown field ty";var Y0a="e=\"msg";var o5a="msg-";var R7a='<div data-dte-e="input" class="';var S7a="ame";var b1a='msg-message';var D0a="namePrefi";var i7a="restore";var v0a="pan/></div>";var K5a="msg-i";var h2=t5a;h2+=M5a;h2+=d5a;h2+=i4v;var B2=R5a;B2+=B5a;var R2=t5a;R2+=u8a;R2+=a6a;R2+=x4v;var d2=L5L.j4v;d2+=W5a;var M2=p5a;M2+=f5a;var t2=o5a;t2+=t5a;t2+=i5a;var F2=w5a;F2+=x5a;F2+=D4v;F2+=h5a;var e2=w5a;e2+=D5a;e2+=U5a;e2+=u8a;var Y2=K5a;Y2+=Y6a;var j2=u8a;j2+=L5L.J4v;j2+=O0a;j2+=u8a;var P2=L0a;P2+=Q0a;P2+=s0a;P2+=H0a;var J2=L5L.j4v;J2+=W5a;var q2=v9a;q2+=Z8a;var T2=c9a;T2+=L5L.Y4v;T2+=q2a;var k2=b0a;k2+=L5L.Y4v;k2+=y8a;var N2=L5L.j4v;N2+=K4v;N2+=L5L.P4v;var E2=a3a;E2+=a6a;E2+=f3a;E2+=a0a;var G2=z0a;G2+=u0a;G2+=b3a;G2+=v0a;var Z2=I0a;Z2+=b8a;var V2=X0a;V2+=c0a;var g2=u0a;g2+=r0a;g2+=l0a;g2+=C0a;var n2=w5a;n2+=A0a;n2+=Y6a;var S2=S0a;S2+=n0a;S2+=g0a;var A2=u0a;A2+=V0a;A2+=x4v;A2+=Z0a;var C2=G0a;C2+=E0a;var l2=L5L.P4v;l2+=y0a;l2+=m0a;l2+=D4v;var r2=N0a;r2+=k0a;r2+=T0a;r2+=q0a;var c2=v5a;c2+=C0a;var X2=J0a;X2+=P0a;var I2=j0a;I2+=Y0a;I2+=e0a;var v2=F0a;v2+=t0a;var u2=u0a;u2+=M0a;u2+=d0a;u2+=C0a;var z2=x4v;z2+=i4v;z2+=K3a;z2+=K4v;var a2=v5a;a2+=C0a;var b2=R0a;b2+=L5L.Y4v;var H2=v5a;H2+=C0a;var s2=B0a;s2+=W0a;s2+=p0a;var Q2=f0a;Q2+=p6a;var L2=v5a;L2+=C0a;var O2=x4v;O2+=i4v;O2+=Q0a;var K3=v5a;K3+=C0a;var U3=x4v;U3+=L5L.j4v;var D3=o0a;D3+=i0a;D3+=L5L.j4v;var h3=v5a;h3+=C0a;var x3=L5L.F4v;x3+=w0a;x3+=x0a;x3+=h0a;var w3=i4v;w3+=L5L.J4v;w3+=L5L.P4v;w3+=L5L.Y4v;var i3=D0a;i3+=D2a;var o3=R2a;o3+=L6a;o3+=U0a;var f3=K0a;f3+=O7a;f3+=L7a;f3+=L5L.J4v;var W3=L5L.j4v;W3+=Q7a;var d3=L5L.j4v;d3+=s7a;d3+=z3a;var F3=H7a;F3+=L5L.P4v;F3+=L5L.Y4v;var e3=l9a;e3+=x4v;e3+=r9a;var j3=b7a;j3+=a7a;var P3=L5L.j4v;P3+=I9a;P3+=L5L.J4v;P3+=z7a;var J3=L5L.P4v;J3+=T8a;J3+=u7a;J3+=x4v;var q3=x4v;q3+=v7a;q3+=T9a;q3+=i4v;var that=this;var multiI18n=host[q3][J3];opts=$[I7a](e5a,{},Editor[F5a][P3],opts);if(!Editor[j3][opts[s3a]]){var Y3=X7a;Y3+=c7a;Y3+=r7a;throw Y3 + opts[s3a];}this[b3a]=$[I7a]({},Editor[e3][l7a],{type:Editor[C7a][opts[s3a]],name:opts[F3],classes:classes,host:host,opts:opts,multiValue:Y5a});if(!opts[A7a]){var M3=i4v;M3+=S7a;var t3=x4v;t3+=L5L.j4v;opts[t3]=n7a + opts[M3];}if(opts[d3]){var B3=L5L.j4v;B3+=g7a;B3+=K4v;B3+=z3a;var R3=L5L.j4v;R3+=L7a;R3+=L5L.J4v;opts[R3]=opts[B3];}if(opts[W3] === U9a){var p3=i4v;p3+=V7a;p3+=L5L.Y4v;opts[Z7a]=opts[p3];}var dtPrivateApi=DataTable[b0a][G7a];this[E7a]=function(d){L5L.r5L();var m7a='editor';return dtPrivateApi[y7a](opts[Z7a])(d,m7a);};this[f3]=dtPrivateApi[N7a](opts[Z7a]);var template=$(k7a + classes[T7a] + q7a + classes[o3] + opts[s3a] + q7a + classes[i3] + opts[w3] + q7a + opts[x3] + h3 + J7a + classes[P7a] + j7a + Editor[D3](opts[U3]) + Y7a + opts[P7a] + e7a + classes[F7a] + K3 + opts[t7a] + M7a + d7a + R7a + classes[O2] + L2 + B7a + classes[Q2] + W7a + s2 + classes[p7a] + H2 + multiI18n[b2] + f7a + classes[o7a] + a2 + multiI18n[z2] + u2 + v2 + I2 + classes[X2] + c2 + multiI18n[i7a] + M7a + r2 + classes[l2] + w7a + x7a + classes[C2] + Y7a + opts[h7a] + A2 + S2 + classes[n2] + Y7a + opts[D7a] + g2 + V2 + U7a + classes[Z2] + G2 + M7a);var input=this[E2](K7a,opts);if(input !== O1a){var y2=L1a;y2+=y8a;_editor_el(Q1a,template)[y2](input);}else {var m2=i4v;m2+=K4v;m2+=i4v;m2+=L5L.Y4v;template[s1a](H1a,m2);}this[N2]=$[k2](e5a,{},Editor[T2][q2][J2],{container:template,inputControl:_editor_el(P2,template),label:_editor_el(j2,template),fieldInfo:_editor_el(Y2,template),labelInfo:_editor_el(e2,template),fieldError:_editor_el(F2,template),fieldMessage:_editor_el(b1a,template),multi:_editor_el(a1a,template),multiReturn:_editor_el(t2,template),multiInfo:_editor_el(z1a,template),processing:_editor_el(M2,template)});this[d2][R2][n3a](B2,function(){var I1a="nly";var S1a="multiEditable";var w2=D4v;w2+=u1a;w2+=v1a;w2+=I1a;var i2=R2a;i2+=L6a;var f2=X1a;f2+=c1a;var p2=r1a;p2+=l1a;p2+=C1a;var W2=A1a;W2+=O3a;if(that[b3a][W2][S1a] && !template[p2](classes[f2]) && opts[i2] !== w2){var x2=K3a;x2+=J6a;x2+=n1a;that[g1a](U9a);that[x2]();}});this[V1a][h2][n3a](Z1a,function(){var E1a="Restor";var D2=L5L.P4v;D2+=G1a;D2+=E1a;D2+=L5L.Y4v;that[D2]();});$[y1a](this[b3a][s3a],function(name,fn){L5L.r5L();if(typeof fn === L5L.d4v && that[name] === undefined){that[name]=function(){var m1a="ly";var Q9=L5L.J4v;Q9+=z3a;Q9+=z3a;Q9+=m1a;var L9=a3a;L9+=a6a;L9+=f3a;L9+=a0a;var O9=T8a;O9+=g8a;O9+=N1a;O9+=k1a;var K2=T1a;K2+=q1a;var U2=z3a;U2+=w2a;U2+=h4v;U2+=s3a;var args=Array[U2][J1a][K2](arguments);args[O9](name);var ret=that[L9][Q9](that,args);return ret === undefined?that:ret;};}});};Editor[s9][P1a]={def:function(set){var e1a="aul";var Y1a="faul";var a9=V8a;L5L.r5L();a9+=K3a;var opts=this[b3a][j1a];if(set === undefined){var b9=V8a;b9+=Y1a;b9+=a6a;var H9=L5L.j4v;H9+=I9a;H9+=e1a;H9+=a6a;var def=opts[H9] !== undefined?opts[b9]:opts[F1a];return typeof def === L5L.d4v?def():def;}opts[a9]=set;return this;},disable:function(){var t1a="_typ";var W1a="ai";var I9=t1a;I9+=M1a;var v9=d1a;v9+=x0a;v9+=H8a;var u9=R1a;u9+=B1a;u9+=W1a;L5L.r5L();u9+=m6a;var z9=L5L.j4v;z9+=K4v;z9+=L5L.P4v;this[z9][u9][p1a](this[b3a][v9][f1a]);this[I9](o1a);return this;},displayed:function(){var i1a="paren";var c9=i1a;c9+=O3a;var X9=L5L.j4v;X9+=W5a;var container=this[X9][w1a];return container[c9](x1a)[j5a] && container[s1a](H1a) != h1a?e5a:Y5a;},enable:function(){var K1a="ntainer";var U1a="moveClass";var A9=L5L.Y4v;A9+=i4v;A9+=L5L.J4v;A9+=D1a;var C9=u3a;C9+=U1a;var l9=R1a;l9+=K1a;var r9=L5L.j4v;r9+=K4v;r9+=L5L.P4v;this[r9][l9][C9](this[b3a][O4a][f1a]);this[L4a](A9);return this;},enabled:function(){var s4a="tainer";var g9=r1a;g9+=l1a;g9+=L5L.J4v;g9+=x0a;var n9=Q4a;n9+=s4a;var S9=L5L.j4v;S9+=K4v;S9+=L5L.P4v;return this[S9][n9][g9](this[b3a][O4a][f1a]) === Y5a;},error:function(msg,fn){var u4a="contain";var I4a='errorMessage';var y9=H4a;y9+=b4a;y9+=A9a;var E9=L5L.j4v;E9+=K4v;E9+=L5L.P4v;var G9=a3a;G9+=L5L.P4v;G9+=b3a;G9+=N2a;var V9=d1a;V9+=a4a;V9+=b3a;var classes=this[b3a][V9];if(msg){this[V1a][w1a][p1a](classes[z4a]);}else {var Z9=u4a;Z9+=j3a;this[V1a][Z9][v4a](classes[z4a]);}this[L4a](I4a,msg);return this[G9](this[E9][y9],msg,fn);},fieldInfo:function(msg){var m9=v1a;m9+=L5L.P4v;return this[X4a](this[m9][D7a],msg);},isMultiValue:function(){var N9=t5a;N9+=c4a;L5L.r5L();return this[b3a][N9] && this[b3a][r4a][j5a] !== B1v;},inError:function(){var A4a="conta";var l4a="asses";var J9=L5L.F4v;J9+=u8a;J9+=l4a;var q9=C4a;q9+=w0a;q9+=x0a;var T9=A4a;T9+=S4a;T9+=D4v;L5L.g5L();var k9=v1a;k9+=L5L.P4v;return this[k9][T9][q9](this[b3a][J9][z4a]);},input:function(){var n4a="typeFn";var e9=f0a;e9+=T8a;e9+=a6a;var Y9=a3a;Y9+=n4a;var j9=x4v;j9+=g4a;var P9=a6a;P9+=B8a;P9+=L6a;return this[b3a][P9][j9]?this[Y9](e9):$(V4a,this[V1a][w1a]);},focus:function(){var t9=K3a;L5L.r5L();t9+=K4v;t9+=L5L.F4v;t9+=n1a;var F9=a6a;F9+=B8a;F9+=L6a;if(this[b3a][F9][t9]){this[L4a](Z4a);}else {var d9=K3a;d9+=K4v;d9+=L5L.F4v;d9+=n1a;var M9=L5L.j4v;M9+=K4v;M9+=L5L.P4v;$(V4a,this[M9][w1a])[d9]();}return this;},get:function(){var E4a='get';var G4a="isMultiValue";L5L.r5L();var B9=L5L.j4v;B9+=L5L.Y4v;B9+=K3a;var R9=a3a;R9+=I3a;R9+=L5L.Y4v;R9+=a0a;if(this[G4a]()){return undefined;}var val=this[R9](E4a);return val !== undefined?val:this[B9]();},hide:function(animate){var m4a="eUp";var N4a="tain";var f9=y4a;f9+=m4a;var p9=q8a;p9+=K4v;p9+=b3a;p9+=a6a;var W9=R1a;W9+=i4v;W9+=N4a;W9+=j3a;var el=this[V1a][W9];if(animate === undefined){animate=e5a;}if(this[b3a][p9][j2a]() && animate && $[k4a][f9]){el[T4a]();}else {var i9=i4v;i9+=K4v;i9+=y2a;var o9=L5L.F4v;o9+=b3a;o9+=b3a;el[o9](H1a,i9);}return this;},label:function(str){var U9=L5L.J4v;U9+=q4a;U9+=J4a;var h9=L5L.j4v;h9+=K4v;h9+=L5L.P4v;var x9=u8a;x9+=U5a;x9+=u8a;var w9=L5L.j4v;w9+=K4v;w9+=L5L.P4v;var label=this[w9][x9];var labelInfo=this[h9][t7a][P4a]();if(str === undefined){var D9=q8a;D9+=a6a;D9+=L5L.P4v;D9+=u8a;return label[D9]();}label[j4a](str);label[U9](labelInfo);return this;},labelInfo:function(msg){var K9=L5L.j4v;L5L.g5L();K9+=W5a;return this[X4a](this[K9][t7a],msg);},message:function(msg,fn){var Y4a="dMessag";var L5=J2a;L5+=Y4a;L5+=L5L.Y4v;var O5=L5L.j4v;O5+=K4v;O5+=L5L.P4v;return this[X4a](this[O5][L5],msg,fn);},multiGet:function(id){var e4a="isMult";var F4a="iVa";var Q5=e4a;Q5+=F4a;Q5+=t4a;var value;var multiValues=this[b3a][M4a];var multiIds=this[b3a][r4a];var isMultiValue=this[Q5]();if(id === undefined){var fieldVal=this[g1a]();value={};for(var i=R1v;i < multiIds[j5a];i++){value[multiIds[i]]=isMultiValue?multiValues[multiIds[i]]:fieldVal;}}else if(isMultiValue){value=multiValues[id];}else {var s5=N3a;s5+=L5L.J4v;s5+=u8a;value=this[s5]();}return value;},multiRestore:function(){L5L.r5L();this[b3a][p7a]=e5a;this[d4a]();},multiSet:function(id,val){var R4a="isPlai";var W4a="jec";var B4a="nOb";var b5=R4a;b5+=B4a;b5+=W4a;b5+=a6a;var multiValues=this[b3a][M4a];var multiIds=this[b3a][r4a];if(val === undefined){val=id;id=undefined;}var set=function(idSrc,val){var H5=x4v;H5+=i4v;L5L.g5L();H5+=p4a;H5+=B8a;if($[H5](multiIds) === -B1v){multiIds[C5a](idSrc);}multiValues[idSrc]=val;};if($[b5](val) && id === undefined){var a5=L5L.Y4v;a5+=L5L.J4v;a5+=f4a;$[a5](val,function(idSrc,innerVal){L5L.g5L();set(idSrc,innerVal);});}else if(id === undefined){$[y1a](multiIds,function(i,idSrc){L5L.g5L();set(idSrc,val);});}else {set(id,val);}this[b3a][p7a]=e5a;this[d4a]();return this;},name:function(){var z5=o4a;z5+=L5L.Y4v;L5L.r5L();return this[b3a][j1a][z5];},node:function(){return this[V1a][w1a][R1v];},processing:function(set){var X5=i4v;X5+=K4v;X5+=i4v;X5+=L5L.Y4v;var I5=w6a;I5+=i4a;var v5=L5L.F4v;v5+=b3a;L5L.g5L();v5+=b3a;var u5=L5L.j4v;u5+=W5a;this[u5][w4a][v5](H1a,set?I5:X5);return this;},set:function(val,multiCheck){var h4a="enti";L5L.g5L();var D4a="tyDeco";var x4a="_type";var l6n="tiVal";var C6n="ueCheck";var r6n="_mul";var n5=b3a;n5+=L5L.Y4v;n5+=a6a;var S5=x4a;S5+=a0a;var C5=h4a;C5+=D4a;C5+=V8a;var decodeFn=function(d){var I6n='\n';var v6n='\'';var b6n='<';var H6n='>';var Q6n="rin";var K4a="epl";var U4a="eplace";var z6n='"';var u6n='';var l5=D4v;l5+=U4a;var r5=D4v;r5+=K4a;r5+=O6n;var c5=L6n;c5+=Q6n;c5+=N2a;return typeof d !== c5?d:d[s6n](/&gt;/g,H6n)[s6n](/&lt;/g,b6n)[s6n](/&amp;/g,a6n)[s6n](/&quot;/g,z6n)[r5](/&#163;/g,u6n)[l5](/&#39;/g,v6n)[s6n](/&#10;/g,I6n);};this[b3a][p7a]=Y5a;var decode=this[b3a][j1a][C5];if(decode === undefined || decode === e5a){if($[X6n](val)){var A5=u8a;A5+=c6n;for(var i=R1v,ien=val[A5];i < ien;i++){val[i]=decodeFn(val[i]);}}else {val=decodeFn(val);}}this[S5](n5,val);if(multiCheck === undefined || multiCheck === e5a){var g5=r6n;g5+=l6n;g5+=C6n;this[g5]();}return this;},show:function(animate){var n6n="ideDown";var A6n="slideDown";var G5=K3a;G5+=i4v;var Z5=X1a;Z5+=z3a;Z5+=w0a;Z5+=B8a;var V5=q8a;V5+=K4v;V5+=L6n;var el=this[V1a][w1a];if(animate === undefined){animate=e5a;}if(this[b3a][V5][Z5]() && animate && $[G5][A6n]){var E5=S6n;E5+=n6n;el[E5]();}else {el[s1a](H1a,U9a);;}L5L.r5L();return this;},val:function(val){L5L.r5L();var y5=b3a;y5+=L5L.Y4v;y5+=a6a;return val === undefined?this[N9a]():this[y5](val);},compare:function(value,original){var g6n="mpar";var N5=L5L.F4v;N5+=K4v;N5+=g6n;N5+=L5L.Y4v;var m5=A1a;m5+=a6a;m5+=b3a;var compare=this[b3a][m5][N5] || _deepCompare;return compare(value,original);},dataSrc:function(){var k5=L5L.j4v;k5+=Q7a;return this[b3a][j1a][k5];},destroy:function(){var E6n="contai";var J5=e2a;J5+=V6n;J5+=Z6n;var q5=u3a;q5+=L5L.P4v;q5+=G6n;q5+=L5L.Y4v;var T5=E6n;T5+=m6a;this[V1a][T5][q5]();this[L4a](J5);return this;},multiEditable:function(){var y6n="iEditable";var P5=J0a;P5+=y6n;L5L.g5L();return this[b3a][j1a][P5];},multiIds:function(){var j5=m6n;j5+=N6n;return this[b3a][j5];},multiInfoShown:function(show){var k6n="ock";var Y5=i2a;Y5+=k6n;this[V1a][o7a][s1a]({display:show?Y5:h1a});},multiReset:function(){this[b3a][r4a]=[];this[b3a][M4a]={};},submittable:function(){L5L.r5L();return this[b3a][j1a][T6n];},valFromData:O1a,valToData:O1a,_errorNode:function(){var F5=q6n;F5+=r9a;L5L.r5L();F5+=b4a;F5+=A9a;var e5=L5L.j4v;e5+=K4v;e5+=L5L.P4v;return this[e5][F5];},_msg:function(el,msg,fn){var W6n="eD";var p6n="own";var f6n="bloc";var d6n=":visible";var W5=J6n;W5+=L5L.P4v;W5+=P6n;var B5=x4v;B5+=b3a;var t5=j6n;t5+=L5L.F4v;t5+=Y6n;t5+=n3a;if(msg === undefined){return el[j4a]();}if(typeof msg === t5){var R5=e6n;R5+=S6a;var d5=F6n;d5+=z3a;d5+=x4v;var M5=t6n;M5+=b3a;M5+=a6a;var editor=this[b3a][M5];msg=msg(editor,new DataTable[d5](editor[b3a][R5]));}if(el[M6n]()[B5](d6n) && $[k4a][W5]){var p5=R6n;p5+=B6n;el[p5](msg);if(msg){var f5=y4a;f5+=W6n;f5+=p6n;el[f5](fn);;}else {el[T4a](fn);}}else {var i5=i4v;i5+=K4v;i5+=i4v;i5+=L5L.Y4v;var o5=f6n;o5+=o6n;el[j4a](msg || U9a)[s1a](H1a,msg?o5:i5);if(fn){fn();}}return this;},_multiValueCheck:function(){var c8n="putContr";var D6n="tiNoEdi";var U6n="toggle";var i6n="_multi";var H8n="multiEditabl";var x6n="hos";var Q8n="ltiV";var C8n="multiReturn";var S8n="info";var n8n="noMulti";var a8n="iVal";L5L.g5L();var L8n="isMu";var w6n="Info";var I8n="inputControl";var S0=i6n;S0+=w6n;var A0=x6n;A0+=a6a;var C0=h6n;C0+=D6n;C0+=a6a;var l0=U6n;l0+=l1a;l0+=C1a;var r0=J0a;r0+=x4v;var c0=R6n;c0+=B6n;var X0=L5L.j4v;X0+=K4v;X0+=L5L.P4v;var I0=t5a;I0+=u8a;I0+=a6a;I0+=x4v;var v0=K6n;v0+=T9a;v0+=i4v;var u0=O8n;u0+=a6a;u0+=q8a;var z0=L5L.j4v;z0+=K4v;z0+=L5L.P4v;var K5=L8n;K5+=Q8n;K5+=s8n;var D5=H8n;D5+=L5L.Y4v;var h5=A1a;h5+=a6a;h5+=b3a;var x5=L5L.P4v;x5+=b8n;x5+=a8n;x5+=z8n;var w5=t5a;w5+=u8a;w5+=c3a;w5+=u8n;var last;var ids=this[b3a][w5];var values=this[b3a][M4a];var isMultiValue=this[b3a][x5];var isMultiEditable=this[b3a][h5][D5];var val;var different=Y5a;if(ids){var U5=N5a;U5+=v8n;U5+=q8a;for(var i=R1v;i < ids[U5];i++){val=values[ids[i]];if(i > R1v && !_deepCompare(val,last)){different=e5a;break;}last=val;}}if(different && isMultiValue || !isMultiEditable && this[K5]()){var Q0=L5L.P4v;Q0+=T8a;Q0+=u8a;Q0+=Y6n;var L0=L5L.j4v;L0+=K4v;L0+=L5L.P4v;var O0=L5L.j4v;O0+=K4v;O0+=L5L.P4v;this[O0][I8n][s1a]({display:h1a});this[L0][Q0][s1a]({display:X8n});}else {var a0=i4v;a0+=K4v;a0+=i4v;a0+=L5L.Y4v;var b0=L5L.j4v;b0+=W5a;var H0=L0a;H0+=c8n;H0+=r8n;var s0=v1a;s0+=L5L.P4v;this[s0][H0][s1a]({display:X8n});this[b0][m6n][s1a]({display:a0});if(isMultiValue && !different){this[l8n](last,Y5a);}}this[z0][C8n][s1a]({display:ids && ids[u0] > B1v && different && !isMultiValue?X8n:h1a});var i18n=this[b3a][A8n][v0][I0];this[X0][o7a][c0](isMultiEditable?i18n[S8n]:i18n[n8n]);this[V1a][r0][l0](this[b3a][O4a][C0],!isMultiEditable);this[b3a][A0][S0]();return e5a;},_typeFn:function(name){var g8n="unsh";var V8n="if";var Z0=a6a;Z0+=f3a;var V0=K4v;V0+=z3a;V0+=O3a;var g0=g8n;g0+=V8n;g0+=a6a;var n0=L5L.F4v;n0+=L5L.J4v;n0+=u8a;n0+=u8a;var args=Array[P1a][J1a][n0](arguments);args[Z8n]();args[g0](this[b3a][V0]);var fn=this[b3a][Z0][name];if(fn){return fn[G8n](this[b3a][A8n],args);}}};Editor[F5a][E8n]={};Editor[G0][E0]={"className":L5L.M4v,"data":L5L.M4v,"def":L5L.M4v,"fieldInfo":L5L.M4v,"id":L5L.M4v,"label":L5L.M4v,"labelInfo":L5L.M4v,"name":O1a,"type":y0,"message":L5L.M4v,"multiEditable":e5a,"submit":e5a};Editor[F5a][m0][l7a]={type:O1a,name:O1a,classes:O1a,opts:O1a,host:O1a};Editor[F5a][E8n][V1a]={container:O1a,label:O1a,labelInfo:O1a,fieldInfo:O1a,fieldError:O1a,fieldMessage:O1a};Editor[N0]={};Editor[E8n][y8n]={"init":function(dte){},"open":function(dte,append,fn){},"close":function(dte,fn){}};Editor[E8n][k0]={"create":function(conf){},"get":function(conf){},"set":function(conf,val){},"enable":function(conf){},"disable":function(conf){}};Editor[T0][l7a]={"ajaxUrl":O1a,"ajax":O1a,"dataSource":O1a,"domTable":O1a,"opts":O1a,"displayController":O1a,"fields":{},"order":[],"id":-B1v,"displayed":Y5a,"processing":Y5a,"modifier":O1a,"action":O1a,"idSrc":O1a,"unique":R1v};Editor[q0][J0]={"label":O1a,"fn":O1a,"className":O1a};Editor[P0][m8n]={onReturn:j0,onBlur:Y0,onBackground:e0,onComplete:F0,onEsc:N8n,onFieldError:Z4a,submit:t0,focus:R1v,buttons:e5a,title:e5a,message:e5a,drawType:Y5a,scope:M0};Editor[d0]={};(function(){var j8n="s=\"DTED_Lightbox_Close\"></di";var e8n="x_Content";var H4v=25;var s9n='<div class="DTED_Lightbox_Container">';var K3n="_scrollTop";var H9n='<div class="DTED_Lightbox_Background"><div/></div>';var R8n="ontrolle";var k8n="onf";var F8n="<div class=";var T8n="lightb";var j3n="offsetAni";var d8n="yC";var Q9n='<div class="DTED DTED_Lightbox_Wrapper">';var Y8n="<div class=\"DTED_Lightbo";var J8n="isplay";var W8n="lightbox";var t8n="\"DTED_Lightbox_Content_Wrapper\">";var q8n="ox";var S1=L5L.F4v;S1+=k8n;var A1=T8n;A1+=q8n;var C1=L5L.j4v;C1+=J8n;var l1=P8n;l1+=j8n;l1+=Z0a;var r1=F0a;r1+=L5L.j4v;r1+=c0a;L5L.g5L();var c1=Y8n;c1+=e8n;c1+=z0a;var X1=F8n;X1+=t8n;var W0=M8n;W0+=d8n;W0+=R8n;W0+=D4v;var B0=B8n;B0+=x6a;B0+=b3a;var R0=b6a;R0+=a6a;R0+=J4a;var self;Editor[j2a][W8n]=$[R0](e5a,{},Editor[B0][W0],{"init":function(dte){var p8n="_init";self[p8n]();L5L.g5L();return self;},"open":function(dte,append,callback){var o8n="how";var f8n="_sho";var x0=f8n;x0+=r2a;var w0=a3a;w0+=b3a;w0+=o8n;w0+=i4v;var i0=a3a;i0+=L5L.j4v;i0+=K4v;i0+=L5L.P4v;var o0=i8n;o0+=J4a;var f0=f4a;f0+=w8n;f0+=u3a;f0+=i4v;var p0=x8n;p0+=q8a;p0+=h8n;p0+=i4v;if(self[p0]){if(callback){callback();}return;}self[D8n]=dte;var content=self[U8n][K8n];content[f0]()[P4a]();content[o0](append)[O3n](self[i0][L3n]);self[w0]=e5a;self[x0](callback);},"close":function(dte,callback){var s3n="_shown";var D0=Q3n;D0+=A7a;D0+=L5L.Y4v;var h0=a3a;L5L.r5L();h0+=L5L.j4v;h0+=l6a;if(!self[s3n]){if(callback){callback();}return;}self[h0]=dte;self[D0](callback);self[s3n]=Y5a;},node:function(dte){L5L.r5L();var U0=H3n;U0+=W5a;return self[U0][T7a][R1v];},"_init":function(){var b3n="backgro";var c3n='opacity';var I3n="ready";var X3n='div.DTED_Lightbox_Content';var H7=L5L.F4v;H7+=b3a;H7+=b3a;var s7=b3n;s7+=t2a;var Q7=a3n;Q7+=L5L.J4v;Q7+=z3a;Q7+=z3n;var L7=u3n;L7+=q4a;L7+=j3a;var O7=v3n;O7+=L5L.P4v;var K0=a3a;K0+=I3n;if(self[K0]){return;}var dom=self[O7];dom[K8n]=$(X3n,self[U8n][L7]);dom[Q7][s1a](c3n,R1v);L5L.r5L();dom[s7][H7](c3n,R1v);},"_show":function(callback){var y3n="tCalc";var J3n='height';var m3n="ppe";var A3n="click.DT";var Q2n="x_Shown";var b2n="ackgro";var L2n="ightbo";var k3n="orientation";var z2n="not";var T3n="addCl";var l3n="ollTop";var r3n="entation";var u2n='<div class="DTED_Lightbox_Shown"/>';var S3n="ED_Lightbo";var P3n='auto';var O2n=".DTED_L";var q3n='DTED_Lightbox_Mobile';var q7=A9a;q7+=x4v;q7+=r3n;var T7=b3a;T7+=L5L.F4v;T7+=D4v;T7+=l3n;var k7=C3n;k7+=B8a;var G7=A3n;G7+=S3n;G7+=D2a;var Z7=r2a;Z7+=D4v;Z7+=n3n;Z7+=z3n;var g7=g3n;g7+=y8a;var S7=V3n;S7+=L5L.Y4v;var l7=a3a;l7+=Z3n;l7+=G3n;l7+=P6n;var r7=H3n;r7+=l6a;var c7=Q3n;c7+=E3n;c7+=y3n;var X7=a3a;X7+=L5L.j4v;X7+=K4v;X7+=L5L.P4v;var I7=L5L.J4v;I7+=m3n;I7+=y8a;var v7=L5L.F4v;v7+=K4v;v7+=i4v;v7+=K3a;var u7=L5L.F4v;u7+=b3a;u7+=b3a;var z7=a3n;z7+=N3n;var a7=L5L.F4v;a7+=b3a;a7+=b3a;var that=this;var dom=self[U8n];if(window[k3n] !== undefined){var b7=T3n;b7+=C1a;$(x1a)[b7](q3n);}dom[K8n][a7](J3n,P3n);dom[z7][u7]({top:-self[v7][j3n]});$(x1a)[I7](self[U8n][Y3n])[O3n](self[X7][T7a]);self[c7]();self[D8n][e3n](dom[T7a],{opacity:B1v,top:R1v},callback);self[r7][l7](dom[Y3n],{opacity:B1v});setTimeout(function(){var M3n="v.DTE_Foote";var t3n="-ind";var F3n="tex";var A7=F3n;A7+=a6a;A7+=t3n;A7+=k3a;var C7=U2a;C7+=M3n;C7+=D4v;$(C7)[s1a](A7,-B1v);},x1v);dom[S7][d3n](R3n,function(e){var n7=L5L.F4v;n7+=L9a;n7+=Q9a;self[D8n][n7]();});dom[Y3n][g7](R3n,function(e){var V7=a3a;L5L.r5L();V7+=L5L.j4v;V7+=a6a;V7+=L5L.Y4v;self[V7][Y3n]();});$(B3n,dom[Z7])[d3n](G7,function(e){var f3n='DTED_Lightbox_Content_Wrapper';var i3n="ckg";var y7=q8a;y7+=W3n;var E7=a6a;E7+=p3n;E7+=a6a;if($(e[E7])[y7](f3n)){var m7=o3n;m7+=i3n;m7+=w3n;self[D8n][m7]();}});$(window)[d3n](x3n,function(){var U3n="alc";var h3n="_he";var D3n="ightC";L5L.g5L();var N7=h3n;N7+=D3n;N7+=U3n;self[N7]();});self[K3n]=$(k7)[T7]();if(window[q7] !== undefined){var e7=L5L.J4v;e7+=m3n;e7+=y8a;var Y7=l0a;Y7+=O2n;Y7+=L2n;Y7+=Q2n;var j7=s2n;j7+=H2n;var P7=w6a;P7+=b2n;P7+=T8a;P7+=y8a;var J7=A2a;J7+=a6a;var kids=$(x1a)[a2n]()[J7](dom[P7])[z2n](dom[T7a]);$(j7)[O3n](u2n);$(Y7)[e7](kids);}},"_heightCalc":function(){var V2n="igh";var A2n="win";var r2n="out";var c2n=".DTE_Footer";var v2n="maxH";var S2n="dowP";var f7=v2n;f7+=I2n;var p7=L5L.F4v;p7+=x0a;var W7=r2a;W7+=X2n;W7+=z3n;var B7=r2a;B7+=X2n;B7+=z3a;B7+=j3a;var R7=U2a;R7+=N3a;R7+=c2n;var d7=r2n;d7+=j3a;d7+=l2n;var M7=r2a;M7+=C2n;M7+=z3a;M7+=z3n;var t7=A2n;t7+=S2n;t7+=n2n;t7+=g2n;var F7=q8a;F7+=L5L.Y4v;F7+=V2n;F7+=a6a;var dom=self[U8n];var maxHeight=$(window)[F7]() - self[Z2n][t7] * W1v - $(G2n,dom[M7])[d7]() - $(R7,dom[B7])[E2n]();$(y2n,dom[W7])[p7](f7,maxHeight);},"_hide":function(callback){var p2n="ienta";var N2n="click.DTED_Li";var R2n="_anim";var P2n="TED_Lightbox";var W2n="ox_Mobile";var L9n="unbind";var B2n="DTED_Lightb";var t2n="bac";var x2n="Ligh";var w2n="div.DTED_";var U2n="scrollTop";var i2n="ldren";var e2n="ick.DT";var f2n="endTo";var M2n="kgro";var F2n="ED_Lightbox";var h2n="tbox_Shown";var T2n="tbox";var I1=m2n;I1+=w6a;I1+=x4v;I1+=y8a;var v1=N2n;v1+=k2n;v1+=T2n;var u1=m2n;u1+=d3n;var z1=q2n;z1+=J2n;z1+=P2n;var a1=w6a;a1+=j2n;a1+=w3n;var b1=Y2n;b1+=e2n;b1+=F2n;var H1=Y2n;H1+=K4v;H1+=Q9a;var Q1=t2n;Q1+=M2n;Q1+=t2a;var L1=a3a;L1+=d2n;L1+=L7a;L1+=L5L.Y4v;var K7=R2n;K7+=P6n;var U7=a3a;U7+=L5L.j4v;U7+=l6a;var D7=B2n;D7+=W2n;var h7=s2n;h7+=H2n;var o7=A9a;o7+=p2n;o7+=Y6n;o7+=n3a;var dom=self[U8n];if(!callback){callback=function(){};}if(window[o7] !== undefined){var x7=i8n;x7+=f2n;var w7=o2n;w7+=i2n;var i7=w2n;i7+=x2n;i7+=h2n;var show=$(i7);show[w7]()[x7](x1a);show[D2n]();}$(h7)[v4a](D7)[U2n](self[K3n]);self[U7][K7](dom[T7a],{opacity:R1v,top:self[Z2n][j3n]},function(){L5L.r5L();var K2n="tach";var O1=V8a;O1+=K2n;$(this)[O1]();callback();});self[D8n][L1](dom[Q1],{opacity:R1v},function(){var O9n="deta";var s1=O9n;L5L.r5L();s1+=L5L.F4v;s1+=q8a;$(this)[s1]();});dom[H1][L9n](b1);dom[a1][L9n](z1);$(B3n,dom[T7a])[u1](v1);$(window)[I1](x3n);},"_dte":O1a,"_ready":Y5a,"_shown":Y5a,"_dom":{"wrapper":$(Q9n + s9n + X1 + c1 + M7a + M7a + M7a + r1),"background":$(H9n),"close":$(l1),"content":O1a}});self=Editor[C1][A1];self[S1]={"offsetAni":H4v,"windowPadding":H4v};})();(function(){var l9n="<div class=\"DTED";var T5n="windowPadding";var c4v=50;var c9n="=\"DT";var r9n="ED_Envelope_Container\"></div>";var u9n="<div cl";var z9n="\">&times;</div>";var N9n="styl";var n9n="envelope";var a9n="<div class=\"DTED_Envelope_Close";var o9n="clic";var C9n=" D";var I9n="velope_Background\"><div/></div>";var A9n="TED_Envelope_Wrapper\">";var G4v=600;var v9n="s=\"DTED_En";var A5n="height";var Z0n='<div class="DTED_Envelope_Shadow"></div>';var L8N=U2a;L8N+=b3a;L8N+=b9n;L8N+=B8a;var O8N=a9n;O8N+=z9n;var K6N=u9n;K6N+=v8a;K6N+=v9n;K6N+=I9n;var U6N=X9n;U6N+=c9n;U6N+=r9n;var D6N=l9n;D6N+=C9n;D6N+=A9n;var n1=B8n;n1+=S9n;var self;Editor[j2a][n9n]=$[I7a](e5a,{},Editor[n1][y8n],{"init":function(dte){var g1=a3a;g1+=g9n;g1+=a6a;self[D8n]=dte;self[g1]();return self;},"open":function(dte,append,callback){var Z9n="appendCh";var V9n="ppendChild";var G9n="ntent";var N1=a3a;N1+=b3a;N1+=t6n;N1+=r2a;var m1=L5L.F4v;m1+=Z6a;var y1=a3a;y1+=L5L.j4v;y1+=K4v;y1+=L5L.P4v;var E1=L5L.J4v;E1+=V9n;var G1=Z9n;G1+=x4v;G1+=u8a;G1+=L5L.j4v;var Z1=R1a;Z1+=G9n;var V1=V8a;V1+=E9n;V1+=L5L.F4v;V1+=q8a;self[D8n]=dte;$(self[U8n][K8n])[a2n]()[V1]();self[U8n][Z1][G1](append);self[U8n][K8n][E1](self[y1][m1]);self[N1](callback);},"close":function(dte,callback){self[D8n]=dte;self[y9n](callback);},node:function(dte){var k1=a3a;k1+=V1a;return self[k1][T7a][R1v];},"_init":function(){var j9n="bili";var e9n="ckgro";var J9n="sty";var R9n="_cssBackgroundOpacity";var d9n="_ready";var W9n="visbility";var k9n="opaci";var t9n="div.DTED_Envelope_Containe";var m9n="isi";var Y9n="tyle";var x1=N3a;x1+=m9n;x1+=D1a;var w1=N9n;w1+=L5L.Y4v;L5L.g5L();var i1=a3a;i1+=V1a;var f1=i4v;f1+=K4v;f1+=y2a;var p1=M8n;p1+=B8a;var W1=a3a;W1+=L5L.j4v;W1+=K4v;W1+=L5L.P4v;var B1=k9n;B1+=R2a;var R1=L5L.F4v;R1+=x0a;var d1=T9n;d1+=u8a;d1+=q9n;var M1=J9n;M1+=S6a;var t1=N1a;t1+=L5L.j4v;t1+=V8a;t1+=i4v;var F1=N3a;F1+=P9n;F1+=j9n;F1+=R2a;var e1=b3a;e1+=Y9n;var Y1=o3n;Y1+=e9n;Y1+=T8a;Y1+=y8a;var j1=u3n;j1+=F9n;var P1=H3n;P1+=W5a;var J1=t9n;J1+=D4v;var q1=M9n;q1+=k3a;var T1=a3a;T1+=L5L.j4v;T1+=K4v;T1+=L5L.P4v;if(self[d9n]){return;}self[T1][q1]=$(J1,self[P1][j1])[R1v];self[U8n][Y1][e1][F1]=t1;self[U8n][Y3n][M1][d1]=X8n;self[R9n]=$(self[U8n][Y3n])[R1](B1);self[W1][Y3n][B9n][p1]=f1;self[i1][Y3n][w1][W9n]=x1;},"_show":function(callback){var K9n="ckgr";var y5n="ima";var b5n="idth";var p9n="click.DTED";var D9n="_cs";var j5n='click.DTED_Envelope';var O5n="tyl";var S5n="opacity";var w9n="backgr";var C5n="appendChild";var s5n="yle";var m5n="ml,bo";var f9n="_Envel";var M5n='resize.DTED_Envelope';var k5n="offsetHeight";var L5n="offsetH";var H5n="inLeft";var G5n="windowScroll";var v5n="Width";var r5n="backgrou";var X5n="tCal";var z5n="cit";var I5n="_heigh";var i9n="k.DTED_Envelop";var n5n="_findAttachRow";var g5n="px";var U9n="sBackgroundOpacity";var s6N=w6a;s6N+=x4v;s6N+=i4v;s6N+=L5L.j4v;var O6N=p9n;O6N+=f9n;O6N+=K4v;O6N+=L6a;var K4=w6a;K4+=x4v;K4+=y8a;var U4=r2a;U4+=D4v;U4+=N3n;var D4=v3n;D4+=L5L.P4v;var w4=o9n;w4+=i9n;w4+=L5L.Y4v;var i4=g3n;i4+=y8a;var o4=w9n;o4+=x9n;o4+=y8a;var p4=L5L.F4v;p4+=u8a;p4+=t3a;p4+=L5L.Y4v;var e4=L5L.F4v;e4+=n3a;e4+=K3a;var Y4=a3a;Y4+=L5L.j4v;Y4+=K4v;Y4+=L5L.P4v;var j4=A2a;j4+=D4v;j4+=h9n;j4+=u8a;var P4=D9n;P4+=U9n;var J4=a3a;J4+=L5L.j4v;J4+=K4v;J4+=L5L.P4v;var q4=i2a;q4+=K4v;q4+=B5a;var T4=T9n;T4+=O9a;var k4=o3n;k4+=K9n;k4+=x9n;k4+=y8a;var N4=H3n;N4+=W5a;var m4=b3a;m4+=O5n;m4+=L5L.Y4v;var y4=z3a;y4+=D2a;var E4=a6a;E4+=K4v;E4+=z3a;var G4=L6n;G4+=B8a;G4+=u8a;G4+=L5L.Y4v;var Z4=H3n;Z4+=K4v;Z4+=L5L.P4v;var V4=z3a;V4+=D2a;var g4=L5n;g4+=E3n;g4+=a6a;var n4=a6a;n4+=K4v;n4+=z3a;var S4=Q5n;S4+=K3a;S4+=Q9a;S4+=a6a;var A4=a6a;A4+=K4v;A4+=z3a;var C4=b3a;C4+=a6a;C4+=s5n;var l4=a3n;l4+=L5L.J4v;l4+=F9n;var r4=H3n;r4+=K4v;r4+=L5L.P4v;var c4=h9n;c4+=D4v;c4+=N2a;c4+=H5n;var X4=N9n;X4+=L5L.Y4v;var I4=r2a;I4+=X2n;I4+=z3n;var v4=a3a;v4+=L5L.j4v;v4+=K4v;v4+=L5L.P4v;var u4=r2a;u4+=b5n;var z4=b3a;z4+=R2a;z4+=u8a;z4+=L5L.Y4v;var a4=a3a;a4+=v1a;a4+=L5L.P4v;var b4=K4v;b4+=a5n;b4+=z5n;b4+=B8a;var H4=i4v;H4+=K4v;H4+=i4v;H4+=L5L.Y4v;var s4=K4v;s4+=u5n;s4+=v5n;var Q4=I5n;Q4+=X5n;Q4+=L5L.F4v;var L4=w6a;L4+=u8a;L4+=J6a;L4+=o6n;var O4=a3n;O4+=N3n;var K1=H3n;K1+=K4v;K1+=L5L.P4v;var U1=L5L.J4v;U1+=c5n;var D1=a3a;D1+=V1a;var h1=r5n;h1+=y8a;var that=this;var formHeight;if(!callback){callback=function(){};}document[l5n][C5n](self[U8n][h1]);document[l5n][C5n](self[U8n][T7a]);self[D1][K8n][B9n][A5n]=U1;var style=self[K1][O4][B9n];style[S5n]=R1v;style[j2a]=L4;var targetRow=self[n5n]();var height=self[Q4]();var width=targetRow[s4];style[j2a]=H4;style[b4]=B1v;self[a4][T7a][z4][u4]=width + g5n;self[v4][I4][X4][c4]=-(width / W1v) + g5n;self[r4][l4][C4][A4]=$(targetRow)[S4]()[n4] + targetRow[g4] + V4;self[Z4][K8n][G4][E4]=-B1v * height - L4v + y4;self[U8n][Y3n][m4][S5n]=R1v;L5L.g5L();self[N4][k4][B9n][T4]=q4;$(self[J4][Y3n])[V5n]({'opacity':self[P4]},j4);$(self[Y4][T7a])[Z5n]();if(self[e4][G5n]){var M4=E5n;M4+=l8n;var t4=Z3n;t4+=y5n;t4+=a6a;t4+=L5L.Y4v;var F4=R6n;F4+=m5n;F4+=L5L.j4v;F4+=B8a;$(F4)[t4]({"scrollTop":$(targetRow)[M4]()[N5n] + targetRow[k5n] - self[Z2n][T5n]},function(){var q5n="anima";var J5n="conte";var B4=q5n;B4+=l6a;var R4=J5n;R4+=B1a;var d4=v3n;d4+=L5L.P4v;$(self[d4][R4])[B4]({"top":R1v},G4v,callback);});}else {var W4=Q4a;W4+=P5n;$(self[U8n][W4])[V5n]({"top":R1v},G4v,callback);}$(self[U8n][p4])[d3n](j5n,function(e){var f4=a3a;f4+=L5L.j4v;f4+=a6a;L5L.r5L();f4+=L5L.Y4v;self[f4][L3n]();});$(self[U8n][o4])[i4](w4,function(e){var Y5n="dte";var h4=w6a;h4+=j2n;h4+=w3n;var x4=a3a;x4+=Y5n;self[x4][h4]();});$(B3n,self[D4][U4])[K4](O6N,function(e){var t5n="ckground";L5L.r5L();var F5n='DTED_Envelope_Content_Wrapper';var L6N=a6a;L6N+=W2a;L6N+=N9a;if($(e[L6N])[e5n](F5n)){var Q6N=w6a;Q6N+=L5L.J4v;Q6N+=t5n;self[D8n][Q6N]();}});$(window)[s6N](M5n,function(){var R5n="ghtCalc";var d5n="_hei";var H6N=d5n;H6N+=R5n;self[H6N]();});},"_heightCalc":function(){var h5n="hei";var W5n="xHe";var w5n="heig";var D5n="htCalc";var K5n='div.DTE_Footer';var o5n="Body_Content";var i5n="oute";var U5n="heightCalc";var f5n="div.DTE_";var x5n="ren";var V6N=B5n;V6N+=D4v;var g6N=L5L.j4v;g6N+=K4v;g6N+=L5L.P4v;var n6N=a3a;n6N+=L5L.j4v;n6N+=a6a;n6N+=L5L.Y4v;var S6N=h9n;S6N+=W5n;S6N+=p5n;var A6N=L5L.F4v;A6N+=b3a;A6N+=b3a;var C6N=a3n;C6N+=N3n;var l6N=a3a;l6N+=V1a;var r6N=f5n;r6N+=o5n;var c6N=H3n;c6N+=W5a;var X6N=i5n;X6N+=D4v;X6N+=Q8a;X6N+=I2n;var I6N=r2a;I6N+=D4v;I6N+=n3n;I6N+=z3n;var v6N=L5L.F4v;v6N+=K4v;v6N+=i4v;v6N+=K3a;var u6N=w5n;u6N+=R6n;var z6N=L5L.F4v;z6N+=q8a;z6N+=w8n;z6N+=x5n;var a6N=L5L.F4v;a6N+=n3a;a6N+=l6a;a6N+=B1a;var b6N=h5n;b6N+=N2a;b6N+=D5n;var formHeight;formHeight=self[Z2n][b6N]?self[Z2n][U5n](self[U8n][T7a]):$(self[U8n][a6N])[z6N]()[u6N]();var maxHeight=$(window)[A5n]() - self[v6N][T5n] * W1v - $(G2n,self[U8n][I6N])[X6N]() - $(K5n,self[c6N][T7a])[E2n]();$(r6N,self[l6N][C6N])[A6N](S6N,maxHeight);return $(self[n6N][g6N][V6N])[E2n]();},"_hide":function(callback){var b0n="fs";var z0n="ont";var L0n="k.DTED_";var u0n="nte";var Q0n="Lig";var H0n="nbi";var O0n="unbin";var s0n="htbox";var a0n="etHeight";var t6N=O0n;t6N+=L5L.j4v;var F6N=m2n;F6N+=g3n;F6N+=i4v;F6N+=L5L.j4v;var e6N=a3a;e6N+=L5L.j4v;e6N+=K4v;e6N+=L5L.P4v;var Y6N=o9n;Y6N+=L0n;Y6N+=Q0n;Y6N+=s0n;var j6N=T8a;j6N+=H0n;j6N+=i4v;j6N+=L5L.j4v;var P6N=a3a;P6N+=L5L.j4v;P6N+=K4v;P6N+=L5L.P4v;var J6N=m2n;J6N+=w6a;J6N+=L0a;J6N+=L5L.j4v;var q6N=H3n;q6N+=W5a;var E6N=Q5n;E6N+=b0n;E6N+=a0n;var G6N=L5L.F4v;G6N+=z0n;G6N+=k3a;var Z6N=R1a;Z6N+=u0n;Z6N+=B1a;if(!callback){callback=function(){};}$(self[U8n][Z6N])[V5n]({"top":-(self[U8n][G6N][E6N] + c4v)},G4v,function(){var X0n="wrapp";var I0n="Out";var k6N=A2a;k6N+=D4v;k6N+=h9n;L5L.r5L();k6N+=u8a;var N6N=v0n;N6N+=V8a;N6N+=I0n;var m6N=X0n;m6N+=j3a;var y6N=a3a;y6N+=L5L.j4v;y6N+=K4v;y6N+=L5L.P4v;$([self[y6N][m6N],self[U8n][Y3n]])[N6N](k6N,function(){var T6N=D4v;T6N+=c0n;$(this)[T6N]();callback();});});$(self[q6N][L3n])[J6N](R3n);$(self[P6N][Y3n])[j6N](Y6N);$(B3n,self[e6N][T7a])[F6N](R3n);$(window)[t6N](x3n);},"_findAttachRow":function(){var r0n="creat";var C0n='head';var l0n="ataTa";var n0n="head";var i6N=r0n;i6N+=L5L.Y4v;var o6N=L5L.J4v;o6N+=Y8a;o6N+=n8a;o6N+=i4v;var f6N=a3a;f6N+=L5L.j4v;f6N+=a6a;f6N+=L5L.Y4v;var p6N=L7a;p6N+=E9n;p6N+=f4a;var W6N=E9n;L5L.g5L();W6N+=D1a;var B6N=a3a;B6N+=L5L.j4v;B6N+=a6a;B6N+=L5L.Y4v;var R6N=F6n;R6N+=z3a;R6N+=x4v;var d6N=L5L.j4v;d6N+=l0n;d6N+=D1a;var M6N=K3a;M6N+=i4v;var dt=new $[M6N][d6N][R6N](self[B6N][b3a][W6N]);if(self[Z2n][p6N] === C0n){return dt[A0n]()[S0n]();}else if(self[f6N][b3a][o6N] === i6N){var x6N=n0n;x6N+=L5L.Y4v;x6N+=D4v;var w6N=a6a;w6N+=g0n;w6N+=S6a;return dt[w6N]()[x6N]();}else {var h6N=X8a;h6N+=U2a;h6N+=T2a;h6N+=D4v;return dt[H2a](self[D8n][b3a][h6N])[V0n]();}},"_dte":O1a,"_ready":Y5a,"_cssBackgroundOpacity":B1v,"_dom":{"wrapper":$(D6N + Z0n + U6N + M7a)[R1v],"background":$(K6N)[R1v],"close":$(O8N)[R1v],"content":O1a}});self=Editor[L8N][n9n];self[Z2n]={"windowPadding":c4v,"heightCalc":O1a,"attach":H2a,"windowScroll":e5a};})();Editor[P1a][n2n]=function(cfg,after){var R0n="lice";L5L.g5L();var B0n="nArray";var J0n="'. A field already exists with this name";var j0n="ltiRese";var q0n="ield '";var T0n="Error adding f";var E0n="isplayReorde";var N0n="Error adding field. The field requires a `name` option";var V8N=G0n;V8N+=D4v;var g8N=a3a;g8N+=L5L.j4v;g8N+=E0n;g8N+=D4v;if($[X6n](cfg)){if(after !== undefined){var Q8N=u3a;Q8N+=y0n;Q8N+=Q9a;cfg[Q8N]();}for(var i=R1v;i < cfg[j5a];i++){this[n2n](cfg[i],after);}}else {var z8N=K3a;z8N+=m0n;z8N+=u8a;z8N+=L5L.j4v;var a8N=d1a;a8N+=x0a;a8N+=H8a;var b8N=g9n;b8N+=a6a;b8N+=F5a;var s8N=i4v;s8N+=L5L.J4v;s8N+=L5L.P4v;s8N+=L5L.Y4v;var name=cfg[s8N];if(name === undefined){throw N0n;}if(this[b3a][k0n][name]){var H8N=T0n;H8N+=q0n;throw H8N + name + J0n;}this[P0n](b8N,cfg);var field=new Editor[F5a](cfg,this[a8N][z8N],this);if(this[b3a][v9a]){var v8N=t5a;v8N+=j0n;v8N+=a6a;var u8N=L5L.Y4v;u8N+=Y0n;u8N+=e0n;u8N+=F0n;var editFields=this[b3a][u8N];field[v8N]();$[y1a](editFields,function(idSrc,edit){L5L.r5L();var t0n="ultiSe";var r8N=V8a;r8N+=K3a;var c8N=L5L.P4v;c8N+=t0n;c8N+=a6a;var I8N=L5L.j4v;I8N+=Q7a;var val;if(edit[I8N]){var X8N=L5L.j4v;X8N+=L5L.J4v;X8N+=a6a;X8N+=L5L.J4v;val=field[E7a](edit[X8N]);}field[c8N](idSrc,val !== undefined?val:field[r8N]());});}this[b3a][k0n][name]=field;if(after === undefined){var l8N=z3a;l8N+=T8a;l8N+=c2a;this[b3a][M0n][l8N](name);}else if(after === O1a){var A8N=m2n;A8N+=d0n;A8N+=k1a;var C8N=A9a;C8N+=V8a;C8N+=D4v;this[b3a][C8N][A8N](name);}else {var n8N=K2a;n8N+=R0n;var S8N=x4v;S8N+=B0n;var idx=$[S8N](after,this[b3a][M0n]);this[b3a][M0n][n8N](idx + B1v,R1v,name);}}this[g8N](this[V8N]());return this;};Editor[Z8N][G8N]=function(newAjax){if(newAjax){var E8N=L5L.J4v;E8N+=W0n;E8N+=D2a;this[b3a][E8N]=newAjax;return this;}return this[b3a][p0n];};Editor[y8N][Y3n]=function(){var h0n="ub";var f0n="nBackground";var i0n='blur';var m8N=K4v;m8N+=f0n;var onBackground=this[b3a][o0n][m8N];L5L.r5L();if(typeof onBackground === L5L.d4v){onBackground(this);}else if(onBackground === i0n){this[w0n]();}else if(onBackground === N8n){var N8N=L5L.F4v;N8N+=u8a;N8N+=t3a;N8N+=L5L.Y4v;this[N8N]();}else if(onBackground === x0n){var k8N=b3a;k8N+=h0n;k8N+=L5L.P4v;k8N+=H9a;this[k8N]();}return this;};Editor[P1a][T8N]=function(){var D0n="_bl";var q8N=D0n;L5L.g5L();q8N+=B3a;this[q8N]();return this;};Editor[J8N][P8N]=function(cells,fieldNames,show,opts){var L7n="rmOptio";var Q7n="boo";var O7n="rce";var s7n="PlainObjec";var U0n="bubbl";var u7n="_edit";var M8N=U0n;M8N+=L5L.Y4v;var t8N=K0n;t8N+=O7n;var F8N=K3a;F8N+=K4v;F8N+=L7n;F8N+=g8a;var e8N=Q7n;e8N+=u8a;e8N+=u1a;e8N+=i4v;var Y8N=P9n;Y8N+=s7n;Y8N+=a6a;var j8N=H7n;j8N+=x4v;j8N+=L5L.j4v;j8N+=B8a;var that=this;if(this[j8N](function(){L5L.g5L();that[b7n](cells,fieldNames,opts);})){return this;}if($[Y8N](fieldNames)){opts=fieldNames;fieldNames=undefined;show=e5a;}else if(typeof fieldNames === e8N){show=fieldNames;fieldNames=undefined;opts=undefined;}if($[a7n](show)){opts=show;show=e5a;}if(show === undefined){show=e5a;}opts=$[I7a]({},this[b3a][F8N][b7n],opts);var editFields=this[t8N](z7n,cells,fieldNames);this[u7n](cells,editFields,M8N,opts,function(){var K7n="dT";var p7n="_preopen";var D7n="ndTo";var l7n="ePosi";var m7n=" cl";var U7n="ppen";var k7n="/div";var Q1n="rmI";var x7n='attach';var q7n="<div class=\"DTE_Processing_Indicator\"><span></";var v7n="posto";var d7n="bubbleNode";var r7n="include";var F7n="\"><div/>";var G7n="poin";var R7n="esize";var T3N=a3a;T3N+=v7n;T3N+=I7n;var k3N=X7n;k3N+=c7n;var N3N=r7n;N3N+=F5a;N3N+=b3a;var m3N=U0n;m3N+=l7n;m3N+=C7n;var n3N=L5L.J4v;n3N+=L5L.j4v;n3N+=L5L.j4v;var A3N=b9a;A3N+=A7n;A3N+=g8a;var X3N=X7n;X3N+=D4v;X3N+=L5L.P4v;var I3N=L5L.j4v;I3N+=K4v;I3N+=L5L.P4v;var v3N=S7n;v3N+=n7n;var u3N=o2n;u3N+=u8a;u3N+=g7n;L5L.r5L();u3N+=V7n;var H3N=F0a;H3N+=L5L.j4v;H3N+=Z7n;H3N+=C0a;var s3N=G7n;s3N+=E7n;var Q3N=y7n;Q3N+=m7n;Q3N+=L5L.J4v;Q3N+=N7n;var L3N=u0a;L3N+=k7n;L3N+=C0a;var O3N=u0a;O3N+=T7n;var K8N=q7n;K8N+=t0a;var U8N=J7n;U8N+=P7n;var D8N=v5a;D8N+=C0a;var h8N=v5a;h8N+=C0a;var x8N=u8a;x8N+=L0a;x8N+=L5L.Y4v;x8N+=D4v;var w8N=u3n;w8N+=q4a;w8N+=L5L.Y4v;w8N+=D4v;var i8N=j7n;i8N+=Y7n;i8N+=e7n;var o8N=F7n;o8N+=F0a;o8N+=t0a;var f8N=w6a;f8N+=N2a;var p8N=t7n;p8N+=x0a;p8N+=M7n;var W8N=n3n;W8N+=z3a;W8N+=u8a;W8N+=B8a;var B8N=d7n;B8N+=b3a;var d8N=D4v;d8N+=R7n;d8N+=B7n;var namespace=that[W7n](opts);var ret=that[p7n](f7n);if(!ret){return that;}$(window)[n3a](d8N + namespace,function(){L5L.g5L();var i7n="si";var o7n="bubblePo";var R8N=o7n;R8N+=i7n;R8N+=C7n;that[R8N]();});var nodes=[];that[b3a][B8N]=nodes[w7n][W8N](nodes,_pluck(editFields,x7n));var classes=that[O4a][b7n];var background=$(p8N + classes[f8N] + o8N);var container=$(i8N + classes[w8N] + Y7a + k7a + classes[x8N] + h8N + k7a + classes[A0n] + D8N + k7a + classes[L3n] + U8N + K8N + O3N + L3N + Q3N + classes[s3N] + h7n + H3N);if(show){var z3N=n3n;z3N+=z3a;z3N+=L5L.Y4v;z3N+=D7n;var a3N=w6a;a3N+=K6a;var b3N=L5L.J4v;b3N+=U7n;b3N+=K7n;b3N+=K4v;container[b3N](a3N);background[z3N](x1a);}var liner=container[u3N]()[O1n](R1v);var table=liner[a2n]();var close=table[a2n]();liner[O3n](that[V1a][v3N]);table[L1n](that[I3N][X3N]);if(opts[h7a]){var l3N=K3a;l3N+=K4v;l3N+=Q1n;l3N+=Y6a;var r3N=L5L.j4v;r3N+=K4v;r3N+=L5L.P4v;var c3N=z3a;c3N+=D4v;c3N+=L5L.Y4v;c3N+=s1n;liner[c3N](that[r3N][l3N]);}if(opts[H1n]){var C3N=v1a;C3N+=L5L.P4v;liner[L1n](that[C3N][S0n]);}if(opts[A3N]){var S3N=w6a;S3N+=T8a;S3N+=a9a;S3N+=b3a;table[O3n](that[V1a][S3N]);}var pair=$()[n2n](container)[n3N](background);that[b1n](function(submitComplete){L5L.r5L();that[e3n](pair,{opacity:R1v},function(){var a1n="sed";var z1n="_clearDyn";var u1n="amicInf";var v1n="ze.";if(this === container[R1v]){var E3N=o2a;E3N+=w6a;E3N+=S6a;var G3N=Y2n;G3N+=K4v;G3N+=a1n;var Z3N=z1n;Z3N+=u1n;Z3N+=K4v;var V3N=D4v;V3N+=H8a;V3N+=x4v;V3N+=v1n;var g3N=L5L.j4v;g3N+=L5L.Y4v;g3N+=I1n;g3N+=q8a;pair[g3N]();$(window)[E5n](V3N + namespace);that[Z3N]();that[X1n](G3N,[E3N]);}});});background[q2n](function(){L5L.r5L();that[w0n]();});close[q2n](function(){L5L.r5L();var c1n="_clos";var y3N=c1n;y3N+=L5L.Y4v;that[y3N]();});that[m3N]();that[e3n](pair,{opacity:B1v});that[r1n](that[b3a][N3N],opts[k3N]);that[T3N](f7n,e5a);});return this;};Editor[P1a][l1n]=function(){var e1n="lef";var G1n=".DTE";var j1n="bottom";var J1n="outerWidth";var C1n="fset";var g1n="Nodes";var Z1n="DTE_Bubble_Line";var Y1n='below';var O4v=15;var q1n="right";var E1n="_Bubble";var i3N=Q5n;i3N+=C1n;var o3N=N5a;o3N+=N2a;o3N+=a6a;o3N+=q8a;var f3N=Y2n;f3N+=v8a;f3N+=I8a;var p3N=s2n;p3N+=A1n;p3N+=K4v;p3N+=L5L.P4v;var W3N=S6a;W3N+=S1n;var B3N=S6a;B3N+=K3a;B3N+=a6a;var R3N=a6a;R3N+=K4v;R3N+=z3a;var P3N=b9a;P3N+=n1n;P3N+=S6a;P3N+=g1n;var J3N=V1n;J3N+=Z1n;J3N+=D4v;var q3N=l0a;q3N+=G1n;q3N+=E1n;var wrapper=$(q3N),liner=$(J3N),nodes=this[b3a][P3N];var position={top:R1v,left:R1v,right:R1v,bottom:R1v};$[y1a](nodes,function(i,node){var N1n="tom";var k1n="offsetWidt";var y1n="ffs";var m1n="bot";var d3N=K4v;d3N+=y1n;d3N+=V2a;d3N+=l2n;var M3N=m1n;M3N+=N1n;var t3N=k1n;t3N+=q8a;var F3N=S6a;F3N+=k1a;var e3N=S6a;e3N+=k1a;var Y3N=a6a;Y3N+=K4v;Y3N+=z3a;var j3N=K4v;j3N+=K3a;j3N+=C1n;var pos=$(node)[j3N]();node=$(node)[N9a](R1v);position[N5n]+=pos[Y3N];position[T1n]+=pos[e3N];position[q1n]+=pos[F3N] + node[t3N];position[M3N]+=pos[N5n] + node[d3N];});position[R3N]/=nodes[j5a];position[B3N]/=nodes[W3N];position[q1n]/=nodes[j5a];position[p3N]/=nodes[j5a];var top=position[N5n],left=(position[T1n] + position[q1n]) / W1v,width=liner[J1n](),visLeft=left - width / W1v,visRight=visLeft + width,docWidth=$(window)[P1n](),padding=O4v,classes=this[f3N][b7n];wrapper[s1a]({top:top,left:left});if(liner[o3N] && liner[i3N]()[N5n] < R1v){var x3N=a6a;x3N+=K4v;x3N+=z3a;var w3N=L5L.F4v;w3N+=b3a;w3N+=b3a;wrapper[w3N](x3N,position[j1n])[p1a](Y1n);}else {wrapper[v4a](Y1n);}if(visRight + padding > docWidth){var h3N=e1n;h3N+=a6a;var diff=visRight - docWidth;liner[s1a](h3N,visLeft < padding?-(visLeft - padding):-(diff + padding));}else {var U3N=S6a;U3N+=K3a;U3N+=a6a;var D3N=L5L.F4v;D3N+=b3a;D3N+=b3a;liner[D3N](U3N,visLeft < padding?-(visLeft - padding):R1v);}return this;};Editor[P1a][K3N]=function(buttons){var d1n="asi";var M1n="Ar";var u2N=F1n;u2N+=t1n;var z2N=p2a;z2N+=f2a;var a2N=L5L.j4v;a2N+=K4v;a2N+=L5L.P4v;var b2N=P9n;b2N+=M1n;L5L.g5L();b2N+=C2n;b2N+=B8a;var O2N=R3a;O2N+=d1n;O2N+=L5L.F4v;var that=this;if(buttons === O2N){var s2N=R1n;s2N+=w6a;s2N+=B1n;var Q2N=l5a;Q2N+=Y6n;Q2N+=K4v;Q2N+=i4v;var L2N=K6n;L2N+=W1n;buttons=[{text:this[L2N][this[b3a][Q2N]][s2N],action:function(){var p1n="bmit";L5L.r5L();var H2N=R1n;H2N+=p1n;this[H2N]();}}];}else if(!$[b2N](buttons)){buttons=[buttons];}$(this[a2N][z2N])[u2N]();$[y1a](buttons,function(i,btn){var u4n='keypress';var o1n="Ind";var H4n="tabIndex";var h1n="sName";var f1n="To";var L4n='<button/>';var i1n="tabin";var s4n="className";var m2N=p2a;m2N+=f2a;var y2N=i8n;y2N+=J4a;y2N+=f1n;var g2N=K4v;g2N+=i4v;var n2N=a6a;n2N+=g0n;n2N+=o1n;n2N+=b6a;var S2N=i1n;S2N+=w1n;var A2N=L5L.J4v;A2N+=a6a;A2N+=a6a;A2N+=D4v;var C2N=x1n;C2N+=h1n;var l2N=K3a;l2N+=K4v;l2N+=D4v;l2N+=L5L.P4v;var r2N=D1n;r2N+=K4v;r2N+=i4v;var c2N=u8a;c2N+=L5L.J4v;c2N+=U1n;var X2N=l6a;X2N+=D2a;X2N+=a6a;var v2N=L6n;v2N+=K1n;if(typeof btn === v2N){btn={text:btn,action:function(){var I2N=O4n;I2N+=H9a;this[I2N]();}};}var text=btn[X2N] || btn[c2N];var action=btn[r2N] || btn[k4a];$(L4n,{'class':that[O4a][l2N][Q4n] + (btn[s4n]?q7a + btn[C2N]:U9a)})[j4a](typeof text === L5L.d4v?text(that):text || U9a)[A2N](S2N,btn[n2N] !== undefined?btn[H4n]:R1v)[g2N](b4n,function(e){var a4n="yCo";var V2N=o6n;V2N+=L5L.Y4v;L5L.r5L();V2N+=a4n;V2N+=V8a;if(e[V2N] === U1v && action){action[z4n](that);}})[n3a](u4n,function(e){var c4n="tDe";var I4n="Code";var Z2N=v4n;L5L.r5L();Z2N+=I4n;if(e[Z2N] === U1v){var G2N=X4n;G2N+=V7n;G2N+=c4n;G2N+=r4n;e[G2N]();}})[n3a](Z1a,function(e){e[l4n]();L5L.g5L();if(action){var E2N=L5L.F4v;E2N+=L5L.J4v;E2N+=q1a;action[E2N](that,e);}})[y2N](that[V1a][m2N]);});return this;};Editor[P1a][N2N]=function(fieldName){var V4n="destroy";var n4n="ludeFi";L5L.r5L();var S4n="inc";var k2N=q6n;k2N+=C4n;var that=this;var fields=this[b3a][k2N];if(typeof fieldName === A4n){var q2N=S4n;q2N+=n4n;q2N+=r9a;q2N+=b3a;var T2N=K2a;T2N+=g4n;T2N+=L5L.F4v;T2N+=L5L.Y4v;that[H4a](fieldName)[V4n]();delete fields[fieldName];var orderIdx=$[Z4n](fieldName,this[b3a][M0n]);this[b3a][M0n][T2N](orderIdx,B1v);var includeIdx=$[Z4n](fieldName,this[b3a][q2N]);if(includeIdx !== -B1v){this[b3a][G4n][E4n](includeIdx,B1v);}}else {var J2N=L5L.Y4v;J2N+=L5L.J4v;J2N+=L5L.F4v;J2N+=q8a;$[J2N](this[y4n](fieldName),function(i,name){var m4n="clear";L5L.r5L();that[m4n](name);});}return this;};Editor[P1a][L3n]=function(){var P2N=F3a;P2N+=t3a;P2N+=L5L.Y4v;this[P2N](Y5a);return this;};Editor[P1a][j2N]=function(arg1,arg2,arg3,arg4){var k4n="_actionClas";var N4n="initC";var q4n="fier";var Y4n="tFi";var i2N=N4n;i2N+=u3a;i2N+=L5L.J4v;i2N+=l6a;var f2N=L5L.Y4v;f2N+=L5L.J4v;f2N+=f4a;var p2N=k4n;p2N+=b3a;var W2N=U2a;W2N+=K2a;W2N+=w0a;W2N+=B8a;var B2N=b3a;B2N+=a6a;B2N+=B8a;B2N+=S6a;var R2N=K3a;R2N+=K4v;R2N+=T4n;var d2N=X8a;d2N+=U2a;d2N+=q4n;var t2N=L5L.Y4v;t2N+=J4n;t2N+=x6a;t2N+=u8n;var e2N=H7n;e2N+=x4v;e2N+=H2n;var Y2N=q6n;Y2N+=C4n;var that=this;var fields=this[b3a][Y2N];var count=B1v;if(this[e2N](function(){var F2N=P4n;F2N+=u1a;L5L.g5L();F2N+=a6a;F2N+=L5L.Y4v;that[F2N](arg1,arg2,arg3,arg4);})){return this;}if(typeof arg1 === j4n){count=arg1;arg1=arg2;arg2=arg3;}this[b3a][t2N]={};for(var i=R1v;i < count;i++){var M2N=P2a;M2N+=x4v;M2N+=Y4n;M2N+=C4n;this[b3a][M2N][i]={fields:this[b3a][k0n]};}var argOpts=this[e4n](arg1,arg2,arg3,arg4);this[b3a][v9a]=F4n;this[b3a][t4n]=M4n;this[b3a][d2N]=O1a;this[V1a][R2N][B2N][W2N]=X8n;this[p2N]();this[d4n](this[k0n]());$[f2N](fields,function(name,field){var R4n="multiReset";field[R4n]();L5L.g5L();for(var i=R1v;i < count;i++){var o2N=L5L.j4v;o2N+=L5L.Y4v;o2N+=K3a;field[B4n](i,field[o2N]());}field[l8n](field[F1a]());});this[X1n](i2N,O1a,function(){var W4n="maybeO";var w2N=W4n;w2N+=I7n;that[p4n]();that[W7n](argOpts[j1a]);argOpts[w2N]();});return this;};Editor[x2N][h2N]=function(parent){var i4n='.edep';var o4n="unde";if($[X6n](parent)){var D2N=u8a;D2N+=f4n;D2N+=q8a;for(var i=R1v,ien=parent[D2N];i < ien;i++){var U2N=o4n;U2N+=M2a;this[U2N](parent[i]);}return this;}var field=this[H4a](parent);$(field[V0n]())[E5n](i4n);return this;};Editor[P1a][w4n]=function(parent,url,opts){var K4n='POST';var x4n=".ede";var C9N=x4n;C9N+=z3a;var l9N=h4n;l9N+=B1a;var r9N=K4v;r9N+=i4v;var c9N=A2a;c9N+=V8a;var L9N=D4n;L9N+=L5L.j4v;var O9N=J5a;O9N+=b3a;L5L.g5L();O9N+=K4v;O9N+=i4v;if($[X6n](parent)){var K2N=S6a;K2N+=i4v;K2N+=N2a;K2N+=U4n;for(var i=R1v,ien=parent[K2N];i < ien;i++){this[w4n](parent[i],url,opts);}return this;}var that=this;var field=this[H4a](parent);var ajaxOpts={type:K4n,dataType:O9N};opts=$[L9N]({event:O6r,data:O1a,preUpdate:O1a,postUpdate:O1a},opts);var update=function(json){var u6r="postUpdate";var z6r='enable';var H6r="preUpdate";var b6r='message';var L6r="upda";var a6r='show';var s6r="preUpdat";var I9N=N1a;I9N+=L5L.j4v;I9N+=L5L.Y4v;var v9N=L5L.Y4v;v9N+=l5a;v9N+=q8a;var z9N=L5L.Y4v;z9N+=D4v;z9N+=w2a;z9N+=D4v;var a9N=N3a;a9N+=L5L.J4v;a9N+=u8a;var b9N=L6r;b9N+=a6a;b9N+=L5L.Y4v;var H9N=u8a;H9N+=Q6r;var s9N=L5L.Y4v;s9N+=L5L.J4v;s9N+=L5L.F4v;s9N+=q8a;var Q9N=s6r;Q9N+=L5L.Y4v;if(opts[Q9N]){opts[H6r](json);}$[s9N]({labels:H9N,options:b9N,values:a9N,messages:b6r,errors:z9N},function(jsonProp,fieldFn){L5L.r5L();if(json[jsonProp]){var u9N=u1a;u9N+=L5L.F4v;u9N+=q8a;$[u9N](json[jsonProp],function(field,val){that[H4a](field)[fieldFn](val);});}});$[v9N]([I9N,a6r,z6r,o1a],function(i,key){if(json[key]){var X9N=d2n;X9N+=P6n;that[key](json[key],json[X9N]);}});if(opts[u6r]){opts[u6r](json);}field[w4a](Y5a);};$(field[c9N]())[r9N](opts[l9N] + C9N,function(e){var I6r="editFie";var r6r='data';var C6r="xten";var l6r="hen";var y9N=j6n;y9N+=Y8a;y9N+=v6r;var G9N=L5L.j4v;G9N+=L5L.J4v;G9N+=E9n;var Z9N=N3a;Z9N+=L5L.J4v;Z9N+=t4a;Z9N+=b3a;var V9N=w2a;V9N+=r2a;V9N+=b3a;var g9N=I6r;g9N+=F0n;var n9N=N5a;n9N+=N2a;n9N+=a6a;n9N+=q8a;var S9N=a6a;S9N+=p3n;S9N+=a6a;var A9N=K3a;A9N+=x4v;A9N+=i4v;A9N+=L5L.j4v;if($(field[V0n]())[A9N](e[S9N])[n9N] === R1v){return;}field[w4a](e5a);var data={};data[X6r]=that[b3a][c6r]?_pluck(that[b3a][g9N],r6r):O1a;data[H2a]=data[V9N]?data[X6r][R1v]:O1a;data[Z9N]=that[g1a]();if(opts[G9N]){var E9N=L5L.j4v;E9N+=Q7a;var ret=opts[E9N](data);if(ret){opts[Z7a]=ret;}}if(typeof url === y9N){var N9N=N3a;N9N+=L5L.J4v;N9N+=u8a;var m9N=L5L.F4v;m9N+=L5L.J4v;m9N+=u8a;m9N+=u8a;var o=url[m9N](that,field[N9N](),data,update);if(o){var k9N=a6a;k9N+=q8a;k9N+=V7n;if(typeof o === L5L.R4v && typeof o[k9N] === L5L.d4v){var T9N=a6a;T9N+=l6r;o[T9N](function(resolved){L5L.g5L();if(resolved){update(resolved);}});}else {update(o);}}}else {var q9N=L5L.Y4v;q9N+=C6r;q9N+=L5L.j4v;if($[a7n](url)){$[I7a](ajaxOpts,url);}else {ajaxOpts[A6r]=url;}$[p0n]($[q9N](ajaxOpts,{url:url,data:data,success:update}));}});return this;};Editor[P1a][J9N]=function(){var g6r=".d";var V6r="destro";var Z6r="Controller";var E6r="destr";var n6r="qu";var B9N=L5L.j4v;B9N+=K4v;B9N+=L5L.P4v;var R9N=T8a;R9N+=S6r;R9N+=n6r;R9N+=L5L.Y4v;var d9N=g6r;d9N+=l6a;L5L.r5L();var t9N=V6r;t9N+=B8a;var F9N=j2a;F9N+=Z6r;var Y9N=L5L.F4v;Y9N+=u8a;Y9N+=L5L.Y4v;Y9N+=W2a;var P9N=M8n;P9N+=B8a;P9N+=P2a;if(this[b3a][P9N]){var j9N=L5L.F4v;j9N+=u8a;j9N+=t3a;j9N+=L5L.Y4v;this[j9N]();}this[Y9N]();if(this[b3a][G6r]){var e9N=L5L.J4v;e9N+=z3a;e9N+=L6a;e9N+=y8a;$(x1a)[e9N](this[b3a][G6r]);}var controller=this[b3a][F9N];if(controller[t9N]){var M9N=E6r;M9N+=Z6n;controller[M9N](this);}$(document)[E5n](d9N + this[b3a][R9N]);this[B9N]=O1a;this[b3a]=O1a;};Editor[W9N][y6r]=function(name){var p9N=V3a;p9N+=Z3a;p9N+=m6r;var that=this;$[y1a](this[p9N](name),function(i,n){var o9N=X1a;o9N+=L5L.J4v;o9N+=D1a;var f9N=K3a;f9N+=m0n;f9N+=q2a;that[f9N](n)[o9N]();});return this;};Editor[P1a][j2a]=function(show){if(show === undefined){return this[b3a][N6r];}L5L.r5L();return this[show?k6r:N8n]();};Editor[i9N][N6r]=function(){return $[T6r](this[b3a][k0n],function(field,name){return field[N6r]()?name:O1a;});};Editor[w9N][x9N]=function(){var h9N=i4v;h9N+=K4v;h9N+=L5L.j4v;h9N+=L5L.Y4v;return this[b3a][y8n][h9N](this);};Editor[P1a][D9N]=function(items,arg1,arg2,arg3,arg4){var J6r="aSou";var Y6r="_ti";var Q5N=L5L.P4v;Q5N+=L5L.J4v;Q5N+=x4v;Q5N+=i4v;var L5N=q6r;L5N+=J6r;L5N+=D4v;L5N+=P6r;var O5N=j6r;O5N+=L5L.j4v;O5N+=x4v;O5N+=a6a;var U9N=Y6r;U9N+=H2n;var that=this;if(this[U9N](function(){var K9N=P2a;L5L.g5L();K9N+=x4v;K9N+=a6a;that[K9N](items,arg1,arg2,arg3,arg4);})){return this;}var argOpts=this[e4n](arg1,arg2,arg3,arg4);this[O5N](items,this[L5N](e6r,items),Q5N,argOpts[j1a],function(){var F6r="ybe";var M6r="_assembleMa";var b5N=h9n;b5N+=F6r;b5N+=t6r;b5N+=V7n;var H5N=A1a;H5N+=O3a;var s5N=M6r;s5N+=L0a;that[s5N]();that[W7n](argOpts[H5N]);argOpts[b5N]();});return this;};Editor[P1a][d6r]=function(name){var a5N=a3a;a5N+=q6n;a5N+=Z3a;a5N+=m6r;var that=this;$[y1a](this[a5N](name),function(i,n){var z5N=q6n;z5N+=L5L.Y4v;L5L.r5L();z5N+=u8a;z5N+=L5L.j4v;that[z5N](n)[d6r]();});return this;};Editor[u5N][z4a]=function(name,msg){L5L.r5L();var R6r="formEr";if(msg === undefined){var I5N=R6r;I5N+=h5a;var v5N=v1a;v5N+=L5L.P4v;this[B6r](this[v5N][I5N],name);this[b3a][W6r]=name;}else {var X5N=p6r;X5N+=K4v;X5N+=D4v;this[H4a](name)[X5N](msg);}return this;};Editor[P1a][c5N]=function(name){var f6r="nknown field name - ";L5L.r5L();var r5N=K3a;r5N+=m0n;r5N+=F0n;var fields=this[b3a][r5N];if(!fields[name]){var l5N=V5a;l5N+=f6r;throw l5N + name;}return fields[name];};Editor[P1a][C5N]=function(){return $[T6r](this[b3a][k0n],function(field,name){return name;});};Editor[A5N][S5N]=_api_file;Editor[P1a][n5N]=_api_files;Editor[g5N][V5N]=function(name){var G5N=N2a;G5N+=L5L.Y4v;G5N+=a6a;var that=this;if(!name){name=this[k0n]();}L5L.r5L();if($[X6n](name)){var Z5N=u1a;Z5N+=f4a;var out={};$[Z5N](name,function(i,n){L5L.r5L();out[n]=that[H4a](n)[N9a]();});return out;}return this[H4a](name)[G5N]();};Editor[P1a][E5N]=function(names,animate){L5L.r5L();var that=this;$[y1a](this[y4n](names),function(i,n){var y5N=q8a;y5N+=x4v;L5L.r5L();y5N+=L5L.j4v;y5N+=L5L.Y4v;that[H4a](n)[y5N](animate);});return this;};Editor[P1a][m5N]=function(includeHash){L5L.r5L();var o6r="ditF";var k5N=L5L.Y4v;k5N+=o6r;k5N+=x4v;k5N+=C4n;var N5N=L5L.P4v;N5N+=L5L.J4v;N5N+=z3a;return $[N5N](this[b3a][k5N],function(edit,idSrc){return includeHash === e5a?i6r + idSrc:idSrc;});};Editor[P1a][w6r]=function(inNames){var x6r="_fieldNam";var J5N=x6r;J5N+=H8a;var q5N=S7n;q5N+=D4v;q5N+=w2a;q5N+=D4v;var T5N=L5L.j4v;T5N+=K4v;T5N+=L5L.P4v;var formError=$(this[T5N][q5N]);L5L.g5L();if(this[b3a][W6r]){return e5a;}var names=this[J5N](inNames);for(var i=R1v,ien=names[j5a];i < ien;i++){var P5N=q6n;P5N+=L5L.Y4v;P5N+=q2a;if(this[P5N](names[i])[w6r]()){return e5a;}}return Y5a;};Editor[P1a][j5N]=function(cell,fieldName,opts){var v8r='div.DTE_Field';var U6r="classe";var O8r="inline";var h6r="lin";var f5N=L0a;f5N+=h6r;f5N+=L5L.Y4v;var p5N=a3a;p5N+=L5L.Y4v;p5N+=U2a;p5N+=a6a;var t5N=L5L.Y4v;t5N+=D6r;var F5N=U6r;F5N+=b3a;var e5N=q6r;e5N+=K6r;var Y5N=L5L.Y4v;Y5N+=H6a;Y5N+=V7n;Y5N+=L5L.j4v;var that=this;if($[a7n](fieldName)){opts=fieldName;fieldName=undefined;}opts=$[Y5N]({},this[b3a][m8n][O8r],opts);var editFields=this[e5N](z7n,cell,fieldName);var node,field;var countOuter=R1v,countInner;var closed=Y5a;var classes=this[F5N][O8r];$[t5N](editFields,function(i,editField){var H8r="ow inline at a time";var s8r="it more than one r";var Q8r="Cannot ed";var R5N=L8r;R5N+=q8a;var d5N=L5L.J4v;d5N+=A1n;L5L.g5L();d5N+=D6r;if(countOuter > R1v){var M5N=Q8r;M5N+=s8r;M5N+=H8r;throw M5N;}node=$(editField[d5N][R1v]);countInner=R1v;$[R5N](editField[b8r],function(j,f){var a8r="Cannot edit more than one fie";L5L.r5L();var u8r="at a time";var z8r="ld inline ";if(countInner > R1v){var B5N=a8r;B5N+=z8r;B5N+=u8r;throw B5N;}field=f;countInner++;});countOuter++;;});if($(v8r,node)[j5a]){return this;}if(this[I8r](function(){var W5N=L0a;W5N+=u8a;L5L.r5L();W5N+=S4a;that[W5N](cell,fieldName,opts);})){return this;}this[p5N](cell,editFields,f5N,opts,function(){var V8r="px\"";var A8r="place";var n8r="<div class=\"DTE_Processing_Indi";var G8r="inlin";var g8r="ator\"><span/></di";var N8r="contents";var E8r="preo";var y8r="ormOpt";var c8r="_fo";var k8r="liner";var l8r="rmError";var r8r="oseReg";var T8r='" style="width:';var j8r="rep";var C8r="ppend";var G0N=L0a;G0N+=h6r;G0N+=L5L.Y4v;var Z0N=K3a;Z0N+=X8r;Z0N+=b3a;var V0N=c8r;V0N+=L5L.F4v;V0N+=T8a;V0N+=b3a;var u0N=F3a;u0N+=r8r;var s0N=X7n;s0N+=l8r;var Q0N=L5L.j4v;Q0N+=K4v;Q0N+=L5L.P4v;var L0N=L5L.J4v;L0N+=C8r;var O0N=u3a;O0N+=A8r;var K5N=q6n;K5N+=y8a;var U5N=u0a;U5N+=S8r;var D5N=n8r;D5N+=L5L.F4v;D5N+=g8r;D5N+=Z0a;var h5N=V8r;h5N+=C0a;var x5N=Z8r;x5N+=L5L.j4v;x5N+=a6a;x5N+=q8a;var w5N=G8r;w5N+=L5L.Y4v;var i5N=a3a;i5N+=E8r;i5N+=z3a;i5N+=V7n;var o5N=E3a;o5N+=y8r;o5N+=x4v;o5N+=m8r;var namespace=that[o5N](opts);var ret=that[i5N](w5N);if(!ret){return that;}var children=node[N8r]()[P4a]();node[O3n]($(k7a + classes[T7a] + Y7a + k7a + classes[k8r] + T8r + node[x5N]() + h5N + D5N + M7a + U5N + classes[q8r] + W7a + M7a));node[K5N](J8r + classes[k8r][O0N](/ /g,P8r))[O3n](field[V0n]())[L0N](that[Q0N][s0N]);if(opts[q8r]){var z0N=v1a;z0N+=L5L.P4v;var a0N=L5L.J4v;a0N+=z3a;a0N+=z3a;a0N+=J4a;var b0N=j8r;b0N+=Y8r;var H0N=L5L.j4v;H0N+=x4v;H0N+=N3a;H0N+=B7n;node[e8r](H0N + classes[q8r][b0N](/ /g,P8r))[a0N](that[z0N][q8r]);}that[u0N](function(submitComplete,action){var t8r="eta";closed=e5a;$(document)[E5n](Z1a + namespace);if(!submitComplete || action !== F8r){var I0N=L5L.J4v;I0N+=z3a;I0N+=I7n;I0N+=L5L.j4v;var v0N=L5L.j4v;v0N+=t8r;v0N+=L5L.F4v;v0N+=q8a;node[N8r]()[v0N]();node[I0N](children);}that[M8r]();return d8r;;});setTimeout(function(){var c0N=R5a;c0N+=B5a;var X0N=K4v;X0N+=i4v;if(closed){return;}$(document)[X0N](c0N + namespace,function(e){var W8r="andSe";var B8r="rge";var f8r='owns';var p8r="Ba";var n0N=z3a;n0N+=L5L.J4v;n0N+=D4v;n0N+=R8r;var S0N=a6a;S0N+=L5L.J4v;S0N+=B8r;S0N+=a6a;var A0N=a3a;A0N+=a6a;A0N+=f3a;A0N+=a0a;var C0N=W8r;C0N+=u8a;C0N+=K3a;var l0N=n2n;l0N+=p8r;l0N+=B5a;var r0N=n2n;r0N+=p8r;r0N+=L5L.F4v;L5L.r5L();r0N+=o6n;var back=$[k4a][r0N]?l0N:C0N;if(!field[A0N](f8r,e[o8r]) && $[Z4n](node[R1v],$(e[S0N])[n0N]()[back]()) === -B1v){var g0N=w6a;g0N+=u8a;g0N+=T8a;g0N+=D4v;that[g0N]();}});},R1v);that[V0N]([field],opts[Z0N]);that[i8r](G0N,e5a);});return this;};Editor[E0N][h7a]=function(name,msg){var D8r="messa";var h8r="formInfo";var w8r="mess";if(msg === undefined){var m0N=L5L.j4v;m0N+=K4v;m0N+=L5L.P4v;var y0N=a3a;y0N+=w8r;y0N+=x8r;this[y0N](this[m0N][h8r],name);}else {var N0N=D8r;N0N+=U8r;this[H4a](name)[N0N](msg);}return this;};Editor[P1a][v9a]=function(mode){var Q3r='Not currently in an editing mode';var H3r="om create mode is not support";var s3r="Changing fr";var K8r="crea";var J0N=K8r;J0N+=a6a;J0N+=L5L.Y4v;var q0N=O3r;q0N+=i4v;var T0N=O3r;L5L.r5L();T0N+=i4v;if(!mode){var k0N=L3r;k0N+=v6r;return this[b3a][k0N];}if(!this[b3a][T0N]){throw new Error(Q3r);}else if(this[b3a][q0N] === K7a && mode !== J0N){var P0N=s3r;P0N+=H3r;P0N+=P2a;throw new Error(P0N);}this[b3a][t4n]=mode;return this;};Editor[P1a][j0N]=function(){return this[b3a][b3r];};Editor[P1a][Y0N]=function(fieldNames){var z3r="multiGet";var t0N=q6n;t0N+=x6a;t0N+=L5L.j4v;var that=this;if(fieldNames === undefined){fieldNames=this[k0n]();}if($[X6n](fieldNames)){var out={};$[y1a](fieldNames,function(i,name){var a3r="ltiGet";var F0N=t5a;F0N+=a3r;var e0N=K3a;e0N+=x4v;L5L.g5L();e0N+=x6a;e0N+=L5L.j4v;out[name]=that[e0N](name)[F0N]();});return out;}return this[t0N](fieldNames)[z3r]();};Editor[P1a][M0N]=function(fieldNames,val){var I3r="Set";L5L.g5L();var u3r="sPlainObject";var d0N=x4v;d0N+=u3r;var that=this;if($[d0N](fieldNames) && val === undefined){var R0N=L5L.Y4v;R0N+=L5L.J4v;R0N+=L5L.F4v;R0N+=q8a;$[R0N](fieldNames,function(name,value){var v3r="ultiSet";L5L.g5L();var W0N=L5L.P4v;W0N+=v3r;var B0N=T2a;B0N+=u8a;B0N+=L5L.j4v;that[B0N](name)[W0N](value);});}else {var f0N=L5L.P4v;f0N+=T8a;f0N+=i5a;f0N+=I3r;var p0N=q6n;p0N+=r9a;this[p0N](fieldNames)[f0N](val);}return this;};Editor[P1a][o0N]=function(name){var i0N=K3a;L5L.g5L();i0N+=x4v;i0N+=r9a;var that=this;if(!name){name=this[M0n]();}return $[X6n](name)?$[T6r](name,function(n){return that[H4a](n)[V0n]();}):this[i0N](name)[V0n]();};Editor[w0N][E5n]=function(name,fn){$(this)[E5n](this[X3r](name),fn);L5L.g5L();return this;};Editor[P1a][n3a]=function(name,fn){$(this)[n3a](this[X3r](name),fn);return this;};Editor[P1a][c3r]=function(name,fn){var h0N=X1n;h0N+=h0a;var x0N=n3a;x0N+=L5L.Y4v;$(this)[x0N](this[h0N](name),fn);return this;};Editor[P1a][v3a]=function(){var S3r="eR";var A3r="_clo";var r3r="_postope";var l3r="mai";var C3r="_preop";var n3r="eg";var u7N=r3r;u7N+=i4v;var L7N=l3r;L7N+=i4v;var O7N=C3r;O7N+=V7n;var D0N=A3r;D0N+=b3a;D0N+=S3r;D0N+=n3r;var that=this;this[d4n]();this[D0N](function(){L5L.g5L();that[b3a][y8n][L3n](that,function(){var g3r="_cle";var V3r="arD";var Z3r="ynamicIn";var K0N=Y2n;K0N+=K4v;L5L.g5L();K0N+=b3a;K0N+=P2a;var U0N=g3r;U0N+=V3r;U0N+=Z3r;U0N+=X7n;that[U0N]();that[X1n](K0N,[F4n]);});});L5L.g5L();var ret=this[O7N](L7N);if(!ret){return this;}this[b3a][y8n][v3a](this,this[V1a][T7a],function(){var G3r="ned";var z7N=h9n;z7N+=x4v;z7N+=i4v;var a7N=K4v;a7N+=L6a;a7N+=G3r;var b7N=E3r;b7N+=L5L.Y4v;b7N+=B1a;var s7N=A9a;s7N+=L5L.j4v;s7N+=L5L.Y4v;s7N+=D4v;var Q7N=h9n;Q7N+=z3a;that[r1n]($[Q7N](that[b3a][s7N],function(name){var H7N=T2a;H7N+=u8a;H7N+=L5L.j4v;H7N+=b3a;return that[b3a][H7N][name];}),that[b3a][o0n][y3r]);that[b7N](a7N,[z7N,that[b3a][t4n]]);});this[u7N](F4n,Y5a);return this;};Editor[P1a][v7N]=function(set){var e3r="dditional fields, must be provided for ordering.";L5L.r5L();var j3r="All fi";var Y3r="elds, and no a";var m3r="xtend";var P3r="sort";var n7N=L5L.Y4v;n7N+=m3r;var A7N=J5a;A7N+=K4v;A7N+=x4v;A7N+=i4v;var C7N=S6n;C7N+=x4v;C7N+=P6r;var l7N=b3a;l7N+=K4v;l7N+=N3r;var r7N=G0n;r7N+=D4v;var X7N=S6a;X7N+=i4v;X7N+=k5a;if(!set){var I7N=A9a;I7N+=k3r;return this[b3a][I7N];}if(arguments[X7N] && !$[X6n](set)){var c7N=b3a;c7N+=T3r;c7N+=L5L.Y4v;set=Array[P1a][c7N][z4n](arguments);}if(this[b3a][r7N][J1a]()[l7N]()[q3r](J3r) !== set[C7N]()[P3r]()[A7N](J3r)){var S7N=j3r;S7N+=Y3r;S7N+=e3r;throw S7N;}$[n7N](this[b3a][M0n],set);this[d4n]();return this;};Editor[P1a][D2n]=function(items,arg1,arg2,arg3,arg4){var M3r="editFi";var W3r="_actionClass";var d3r="ataSou";var p3r='initRemove';var q7N=L5L.j4v;q7N+=L5L.J4v;q7N+=a6a;q7N+=L5L.J4v;var T7N=F3r;T7N+=L5L.Y4v;var k7N=a3a;k7N+=h4n;k7N+=B1a;var N7N=U2a;N7N+=b3a;N7N+=t3r;var m7N=K3a;m7N+=K4v;m7N+=D4v;m7N+=L5L.P4v;var y7N=L5L.j4v;y7N+=W5a;var E7N=M3r;E7N+=r9a;E7N+=b3a;var G7N=l5a;G7N+=Y6n;G7N+=K4v;G7N+=i4v;var Z7N=H3n;Z7N+=d3r;Z7N+=R3r;Z7N+=L5L.Y4v;var V7N=N5a;V7N+=k5a;var that=this;if(this[I8r](function(){var B3r="mov";var g7N=D4v;g7N+=L5L.Y4v;g7N+=B3r;g7N+=L5L.Y4v;L5L.r5L();that[g7N](items,arg1,arg2,arg3,arg4);})){return this;}if(items[V7N] === undefined){items=[items];}var argOpts=this[e4n](arg1,arg2,arg3,arg4);var editFields=this[Z7N](e6r,items);this[b3a][G7N]=D2n;this[b3a][b3r]=items;this[b3a][E7N]=editFields;this[y7N][m7N][B9n][N7N]=h1a;this[W3r]();this[k7N](p3r,[_pluck(editFields,T7N),_pluck(editFields,q7N),items],function(){var f3r='initMultiRemove';L5L.r5L();that[X1n](f3r,[editFields,items],function(){var o3r="_for";var i3r="mOpti";var w3r="maybeOpen";var P7N=K3a;P7N+=X8r;P7N+=b3a;var J7N=o3r;J7N+=i3r;J7N+=K4v;L5L.g5L();J7N+=g8a;that[p4n]();that[J7N](argOpts[j1a]);argOpts[w3r]();var opts=that[b3a][o0n];if(opts[P7N] !== O1a){var j7N=b9a;j7N+=A7n;j7N+=i4v;$(j7N,that[V1a][q8r])[O1n](opts[y3r])[y3r]();}});});return this;};Editor[P1a][Y7N]=function(set,val){var x3r="isPl";var h3r="inOb";var F7N=L5L.Y4v;F7N+=D6r;var e7N=x3r;e7N+=L5L.J4v;e7N+=h3r;e7N+=D3r;var that=this;if(!$[e7N](set)){var o={};o[set]=val;set=o;}$[F7N](set,function(n,v){var M7N=b3a;M7N+=L5L.Y4v;M7N+=a6a;var t7N=K3a;t7N+=x4v;t7N+=x6a;t7N+=L5L.j4v;L5L.g5L();that[t7N](n)[M7N](v);});return this;};Editor[P1a][d7N]=function(names,animate){var R7N=L5L.Y4v;R7N+=D6r;var that=this;$[R7N](this[y4n](names),function(i,n){var U3r="show";var B7N=q6n;B7N+=r9a;that[B7N](n)[U3r](animate);});return this;};Editor[P1a][T6n]=function(successCallback,errorCallback,formatdata,hide){var i7N=L5L.Y4v;i7N+=D6r;var W7N=l5a;W7N+=C7n;var that=this,fields=this[b3a][k0n],errorFields=[],errorReady=R1v,sent=Y5a;if(this[b3a][w4a] || !this[b3a][W7N]){return this;}this[K3r](e5a);var send=function(){var L2r="Submit";var f7N=l5a;f7N+=Y6n;f7N+=n3a;L5L.g5L();var p7N=x4v;p7N+=O2r;p7N+=L2r;if(errorFields[j5a] !== errorReady || sent){return;}that[X1n](p7N,[that[b3a][f7N]],function(result){if(result === Y5a){var o7N=H3a;o7N+=H8a;o7N+=b8a;that[o7N](Y5a);return;}sent=e5a;that[Q2r](successCallback,errorCallback,formatdata,hide);});};this[z4a]();$[i7N](fields,function(name,field){L5L.g5L();if(field[w6r]()){errorFields[C5a](name);}});$[y1a](errorFields,function(i,name){fields[name][z4a](U9a,function(){errorReady++;L5L.g5L();send();});});send();return this;};Editor[P1a][G6r]=function(set){var s2r="templa";var H2r="tem";var x7N=s2r;x7N+=l6a;if(set === undefined){var w7N=H2r;w7N+=z3a;w7N+=b2r;w7N+=L5L.Y4v;return this[b3a][w7N];}this[b3a][x7N]=set === O1a?O1a:$(set);return this;};Editor[P1a][h7N]=function(title){var v2r="ildre";var b1N=a2r;L5L.g5L();b1N+=u8a;var Q1N=z2r;Q1N+=Y6n;Q1N+=K4v;Q1N+=i4v;var O1N=L5L.F4v;O1N+=w0a;O1N+=b3a;O1N+=I8a;var K7N=U2a;K7N+=u2r;var U7N=f4a;U7N+=v2r;U7N+=i4v;var D7N=L5L.j4v;D7N+=K4v;D7N+=L5L.P4v;var header=$(this[D7N][S0n])[U7N](K7N + this[O1N][S0n][K8n]);if(title === undefined){var L1N=q8a;L1N+=a6a;L1N+=B6n;return header[L1N]();}if(typeof title === Q1N){var H1N=a6a;H1N+=I2r;var s1N=F6n;s1N+=z3a;s1N+=x4v;title=title(this,new DataTable[s1N](this[b3a][H1N]));}header[b1N](title);return this;};Editor[P1a][g1a]=function(field,value){if(value !== undefined || $[a7n](field)){return this[l8n](field,value);}return this[N9a](field);;};var apiRegister=DataTable[X2r][c2r];function __getInst(api){var r2r="oInit";var u1N=j6r;u1N+=U2a;u1N+=a6a;u1N+=A9a;var z1N=P2a;z1N+=x4v;z1N+=h4v;z1N+=D4v;var a1N=R1a;a1N+=B1a;a1N+=b6a;a1N+=a6a;var ctx=api[a1N][R1v];return ctx[r2r][z1N] || ctx[u1N];}function __setBasic(inst,opts,type,plural){var Z2r='1';var V2r=/%d/;var l2r="ag";var C2r='_basic';var X1N=u6a;X1N+=x0a;X1N+=l2r;X1N+=L5L.Y4v;var v1N=R0a;v1N+=L5L.Y4v;if(!opts){opts={};}if(opts[q8r] === undefined){opts[q8r]=C2r;}if(opts[v1N] === undefined){var I1N=a6a;I1N+=x4v;I1N+=A2r;I1N+=L5L.Y4v;opts[H1n]=inst[S2r][type][I1N];}L5L.r5L();if(opts[X1N] === undefined){if(type === n2r){var confirm=inst[S2r][type][g2r];opts[h7a]=plural !== B1v?confirm[a3a][s6n](V2r,plural):confirm[Z2r];}else {var c1N=L5L.P4v;c1N+=G2r;c1N+=L5L.J4v;c1N+=U8r;opts[c1N]=U9a;}}return opts;}apiRegister(E2r,function(){return __getInst(this);});apiRegister(y2r,function(opts){var inst=__getInst(this);L5L.r5L();inst[M4n](__setBasic(inst,opts,K7a));return this;});apiRegister(r1N,function(opts){var l1N=L5L.Y4v;l1N+=L5L.j4v;l1N+=x4v;l1N+=a6a;var inst=__getInst(this);inst[T3a](this[R1v][R1v],__setBasic(inst,opts,l1N));return this;});apiRegister(C1N,function(opts){var A1N=m2r;A1N+=a6a;var inst=__getInst(this);inst[A1N](this[R1v],__setBasic(inst,opts,F8r));return this;});apiRegister(N2r,function(opts){var S1N=k2r;S1N+=f4v;var inst=__getInst(this);inst[D2n](this[R1v][R1v],__setBasic(inst,opts,S1N,B1v));return this;});apiRegister(n1N,function(opts){var T2r="emo";var g1N=D4v;g1N+=T2r;L5L.r5L();g1N+=N3a;g1N+=L5L.Y4v;var inst=__getInst(this);inst[D2n](this[R1v],__setBasic(inst,opts,g1N,this[R1v][j5a]));return this;});apiRegister(q2r,function(type,opts){L5L.r5L();if(!type){type=d8r;}else if($[a7n](type)){opts=type;type=d8r;}__getInst(this)[type](this[R1v][R1v],opts);return this;});apiRegister(V1N,function(opts){__getInst(this)[b7n](this[R1v],opts);return this;});apiRegister(J2r,_api_file);apiRegister(Z1N,_api_files);$(document)[n3a](G1N,function(e,ctx,json){var P2r="les";var e2r='dt';var y1N=q6n;L5L.r5L();y1N+=P2r;var E1N=j2r;E1N+=Y2r;if(e[E1N] !== e2r){return;}if(json && json[y1N]){$[y1a](json[A5a],function(name,files){var t2r="il";var k1N=q6n;k1N+=u8a;k1N+=H8a;var N1N=F2r;L5L.r5L();N1N+=y8a;if(!Editor[A5a][name]){var m1N=K3a;m1N+=t2r;m1N+=L5L.Y4v;m1N+=b3a;Editor[m1N][name]={};}$[N1N](Editor[k1N][name],files);});}});Editor[z4a]=function(msg,tn){L5L.r5L();var M2r=' For more information, please refer to https://datatables.net/tn/';throw tn?msg + M2r + tn:msg;};Editor[T1N]=function(data,props,fn){var d2r="isArra";var R2r="lab";var P1N=d2r;P1N+=B8a;var J1N=R2r;J1N+=x6a;var q1N=L5L.Y4v;q1N+=B2r;q1N+=i4v;q1N+=L5L.j4v;var i,ien,dataPoint;L5L.r5L();props=$[q1N]({label:J1N,value:W2r},props);if($[P1N](data)){var j1N=p2r;j1N+=q8a;for((i=R1v,ien=data[j1N]);i < ien;i++){dataPoint=data[i];if($[a7n](dataPoint)){var t1N=L5L.J4v;t1N+=A1n;t1N+=D4v;var F1N=N3a;F1N+=s8n;var e1N=u8a;e1N+=Q6r;var Y1N=N3a;Y1N+=L5L.J4v;Y1N+=u8a;Y1N+=z8n;fn(dataPoint[props[Y1N]] === undefined?dataPoint[props[e1N]]:dataPoint[props[F1N]],dataPoint[props[P7a]],i,dataPoint[t1N]);}else {fn(dataPoint,dataPoint,i);}}}else {var M1N=L5L.Y4v;M1N+=L5L.J4v;M1N+=L5L.F4v;M1N+=q8a;i=R1v;$[M1N](data,function(key,val){fn(val,key,i);L5L.g5L();i++;});}};Editor[d1N]=function(id){L5L.g5L();var f2r="repl";var R1N=f2r;R1N+=O6n;return id[R1N](/\./g,J3r);};Editor[o2r]=function(editor,conf,files,progressCallback,completeCallback){var w9r="_limitLeft";var h2r="leRe";var i2r="<i>Uploading";L5L.g5L();var D2r="adText";var w2r=" file</";var U2r="funct";var x2r="i>";var K2r='A server error occurred while uploading the file';var O9r="onload";var x9r="readAsDataURL";var R4N=L5L.P4v;R4N+=L5L.J4v;R4N+=z3a;var p1N=i2r;p1N+=w2r;p1N+=x2r;var W1N=q6n;W1N+=h2r;W1N+=D2r;var B1N=U2r;B1N+=x4v;B1N+=n3a;var reader=new FileReader();var counter=R1v;var ids=[];var generalError=K2r;editor[z4a](conf[j2r],U9a);if(typeof conf[p0n] === B1N){conf[p0n](files,function(ids){completeCallback[z4n](editor,ids);});return;}progressCallback(conf,conf[W1N] || p1N);reader[O9r]=function(e){var l9r="Upload feature cannot use `ajax.data` with an object. Plea";var r9r="or upload plug-in";var I9r="jax";var Z9r='preSubmit.DTE_Upload';var g9r="dA";var c9r="No Ajax option specified f";var X9r="load";var a9r="uploadFie";var V9r="sDataURL";var C9r="e use it as a function in";var Q9r="functi";var s9r="aj";var S9r='preUpload';var z9r="up";var v9r="ajaxData";var A9r="stead.";var c4N=L9r;c4N+=L6n;var X4N=h2a;X4N+=D2a;var v4N=i4v;v4N+=L5L.J4v;v4N+=L5L.P4v;v4N+=L5L.Y4v;var u4N=j6r;u4N+=N3a;u4N+=V7n;u4N+=a6a;var a4N=Z9a;a4N+=E9n;var H4N=Q9r;H4N+=n3a;L5L.g5L();var Q4N=s9r;Q4N+=p3a;var D1N=s9r;D1N+=H9r;D1N+=L5L.J4v;var h1N=T8a;h1N+=b9r;var x1N=n3n;x1N+=s1n;var w1N=i4v;w1N+=L5L.J4v;w1N+=L5L.P4v;w1N+=L5L.Y4v;var i1N=a9r;i1N+=q2a;var o1N=z9r;o1N+=u8a;o1N+=u9r;o1N+=L5L.j4v;var f1N=L3r;f1N+=x4v;f1N+=K4v;f1N+=i4v;var data=new FormData();var ajax;data[O3n](f1N,o1N);data[O3n](i1N,conf[w1N]);data[x1N](h1N,files[counter]);if(conf[D1N]){conf[v9r](data,files[counter],counter);}if(conf[p0n]){var U1N=L5L.J4v;U1N+=I9r;ajax=conf[U1N];}else if($[a7n](editor[b3a][p0n])){var L4N=L5L.J4v;L4N+=J5a;L4N+=L5L.J4v;L4N+=D2a;var O4N=z9r;O4N+=X9r;var K1N=L5L.J4v;K1N+=J5a;K1N+=p3a;ajax=editor[b3a][p0n][o2r]?editor[b3a][K1N][O4N]:editor[b3a][L4N];}else if(typeof editor[b3a][Q4N] === A4n){ajax=editor[b3a][p0n];}if(!ajax){var s4N=c9r;s4N+=r9r;throw new Exception(s4N);}if(typeof ajax === A4n){ajax={url:ajax};}if(typeof ajax[Z7a] === H4N){var b4N=L5L.Y4v;b4N+=L5L.J4v;b4N+=f4a;var d={};var ret=ajax[Z7a](d);if(ret !== undefined && typeof ret !== A4n){d=ret;}$[b4N](d,function(key,value){L5L.g5L();data[O3n](key,value);});}else if($[a7n](ajax[a4N])){var z4N=l9r;z4N+=b3a;z4N+=C9r;z4N+=A9r;throw new Exception(z4N);}var preRet=editor[u4N](S9r,[conf[v4N],files[counter],data]);if(preRet === Y5a){if(counter < files[j5a] - B1v){var I4N=n9r;I4N+=g9r;I4N+=V9r;counter++;reader[I4N](files[counter]);}else {completeCallback[z4n](editor,ids);}return;}var submit=Y5a;editor[n3a](Z9r,function(){submit=e5a;return Y5a;});$[X4N]($[I7a]({},ajax,{type:c4N,data:data,dataType:G9r,contentType:Y5a,processData:Y5a,xhr:function(){L5L.g5L();var j9r="onloadend";var m9r="onprogress";var y9r="ajaxSettings";var r4N=E9r;r4N+=u9r;r4N+=L5L.j4v;var xhr=$[y9r][D3a]();if(xhr[r4N]){xhr[o2r][m9r]=function(e){var q9r="total";var J9r="%";var T9r="Fixe";var P9r=':';var N9r="lengthComputable";if(e[N9r]){var S4N=S6a;S4N+=i4v;S4N+=k5a;var A4N=u8a;A4N+=L5L.Y4v;A4N+=k9r;A4N+=U4n;var C4N=a6a;C4N+=K4v;C4N+=T9r;C4N+=L5L.j4v;var l4N=X9r;l4N+=P2a;var percent=(e[l4N] / e[q9r] * S4v)[C4N](R1v) + J9r;progressCallback(conf,files[A4N] === B1v?percent:counter + P9r + files[S4N] + q7a + percent);}};xhr[o2r][j9r]=function(e){var e9r="processingText";var Y9r="Processi";var n4N=Y9r;n4N+=k9r;progressCallback(conf,conf[e9r] || n4N);};}return xhr;},success:function(json){var M9r="uploadXhrSuc";var o9r="L";var R9r="Submit.DTE_Upload";var f9r="dAsDataUR";var F9r="dE";var W9r="tat";var t9r="rrors";var q4N=x4v;q4N+=L5L.j4v;var T4N=T8a;T4N+=b9r;var N4N=j3a;N4N+=D4v;N4N+=K4v;N4N+=D4v;var G4N=N5a;G4N+=k5a;var Z4N=J2a;Z4N+=F9r;Z4N+=t9r;var V4N=M9r;V4N+=P6r;V4N+=b3a;V4N+=b3a;var g4N=d9r;g4N+=R9r;editor[E5n](g4N);editor[X1n](V4N,[conf[j2r],json]);if(json[B9r] && json[Z4N][G4N]){var E4N=O8n;E4N+=U4n;var errors=json[B9r];for(var i=R1v,ien=errors[E4N];i < ien;i++){var m4N=b3a;m4N+=W9r;m4N+=n1a;var y4N=j3a;y4N+=w2a;y4N+=D4v;editor[y4N](errors[i][j2r],errors[i][m4N]);}}else if(json[N4N]){var k4N=L5L.Y4v;k4N+=D4v;k4N+=D4v;k4N+=A9a;editor[z4a](json[k4N]);}else if(!json[T4N] || !json[o2r][q4N]){editor[z4a](conf[j2r],generalError);}else {var F4N=S6a;F4N+=i4v;F4N+=k5a;var e4N=x4v;e4N+=L5L.j4v;if(json[A5a]){var J4N=L5L.Y4v;J4N+=L5L.J4v;J4N+=f4a;$[J4N](json[A5a],function(table,files){var p9r="ile";var Y4N=q6n;Y4N+=S6a;Y4N+=b3a;var P4N=K3a;P4N+=p9r;P4N+=b3a;if(!Editor[P4N][table]){var j4N=K3a;j4N+=g5a;Editor[j4N][table]={};}$[I7a](Editor[Y4N][table],files);});}ids[C5a](json[o2r][e4N]);if(counter < files[F4N] - B1v){var t4N=n9r;t4N+=f9r;t4N+=o9r;counter++;reader[t4N](files[counter]);}else {completeCallback[z4n](editor,ids);if(submit){editor[T6n]();}}}progressCallback(conf);},error:function(xhr){var i9r='uploadXhrError';var d4N=i4v;d4N+=L5L.J4v;d4N+=L5L.P4v;d4N+=L5L.Y4v;var M4N=L5L.Y4v;M4N+=D4v;M4N+=D4v;M4N+=A9a;editor[X1n](i9r,[conf[j2r],xhr]);editor[M4N](conf[d4N],generalError);progressCallback(conf);}}));};files=$[R4N](files,function(val){L5L.r5L();return val;});if(conf[w9r] !== undefined){var W4N=u8a;W4N+=L5L.Y4v;W4N+=S1n;var B4N=K2a;B4N+=g4n;B4N+=P6r;files[B4N](conf[w9r],files[W4N]);}reader[x9r](files[R1v]);};Editor[p4N][z5a]=function(init){var W5r="domTa";var Z0r="roller";var h5r="indicator";var r5r="e=\"head\" ";var a5r="utt";var v5r="/></div>";var U9r="r.dt.d";var x5r='<div data-dte-e="processing" class="';var Y5r="mplate";var U5r='<div data-dte-e="body_content" class="';var O5r="rocessing";var C5r="iv data-dte-e=\"form_error\" class=\"";var I0r='foot';var Q0r='<div data-dte-e="form_info" class="';var V0r="ayCont";var w5r="dataSources";var d5r="dataSourc";var L5r="bodyCon";var f5r="actionName";var n5r="onten";var c5r="div data-dte-";var o5r="domTable";var y5r="\"><span/";var D9r="que";var r0r='init.dt.dte';var q5r="uniq";var H5r="ableTools";var V5r="t\" class=\"";var T5r="lasses";var S5r="m>";var G5r="dte-e=\"form\" class=\"";var u5r="m_buttons\" class=\"";var A5r="</for";var E0r='initComplete';var D5r='<div data-dte-e="body" class="';var g5r="<div data-dte-e=\"form_conten";var I5r="v c";var F5r="legacy";var K9r="iqu";var N5r="roc";var z5r="<div data-dte-e=\"for";var k5r="essing";var t5r="Aj";var v0r='form_content';var b5r="Table";var s5r="formConte";var Z5r="form data-";var l5r="orm";var J5r="sett";var m5r="></";var X0r='body_content';var E5r="\"/";var u0r="events";var K5r='<div data-dte-e="foot" class="';var M5r="mOption";var R5r="idSr";var m8z=x4v;m8z+=i4v;m8z+=H9a;m8z+=u5a;var y8z=a3a;y8z+=L5L.Y4v;y8z+=h9r;y8z+=a6a;var C8z=T8a;C8z+=S6r;C8z+=D9r;var l8z=D2a;l8z+=q8a;l8z+=U9r;l8z+=l6a;var I8z=m2n;I8z+=K9r;I8z+=L5L.Y4v;var v8z=K4v;v8z+=i4v;var a8z=K3a;a8z+=m0n;a8z+=u8a;a8z+=u8n;var b8z=z3a;b8z+=O5r;var H8z=L5r;H8z+=l6a;H8z+=i4v;H8z+=a6a;var s8z=s2n;s8z+=L5L.j4v;s8z+=B8a;var Q8z=X7n;Q8z+=K4v;Q8z+=l6a;Q8z+=D4v;var L8z=Q5r;L8z+=L5L.P4v;var O8z=s5r;O8z+=B1a;var f6z=a8a;f6z+=H5r;var p6z=L5L.j4v;p6z+=L7a;p6z+=L5L.J4v;p6z+=b5r;var W6z=K3a;W6z+=i4v;var B6z=v5a;B6z+=r0a;B6z+=C0a;var R6z=w6a;R6z+=a5r;R6z+=K4v;R6z+=g8a;var d6z=K3a;d6z+=K4v;d6z+=D4v;d6z+=L5L.P4v;var M6z=z5r;M6z+=u5r;var t6z=v5a;t6z+=v5r;var F6z=Q4a;F6z+=a6a;F6z+=k3a;var e6z=z0a;e6z+=S0a;e6z+=I5r;e6z+=X5r;var Y6z=q8a;Y6z+=L5L.Y4v;Y6z+=L5L.J4v;Y6z+=k3r;var j6z=u0a;j6z+=c5r;j6z+=r5r;j6z+=e7n;var P6z=x4v;P6z+=i4v;P6z+=X7n;var J6z=K3a;J6z+=K4v;J6z+=T4n;var q6z=j3a;q6z+=D4v;q6z+=A9a;var T6z=K3a;T6z+=l5r;var k6z=j7n;k6z+=C5r;var N6z=A5r;N6z+=S5r;var m6z=L5L.F4v;m6z+=n5r;m6z+=a6a;var y6z=g5r;y6z+=V5r;var E6z=E9n;E6z+=N2a;var G6z=u0a;G6z+=Z5r;G6z+=G5r;var Z6z=v5a;Z6z+=r0a;Z6z+=C0a;var V6z=Q4a;V6z+=P5n;var g6z=v5a;g6z+=C0a;var n6z=B5n;n6z+=D4v;var S6z=F0a;S6z+=U2a;S6z+=N3a;S6z+=C0a;var A6z=E5r;A6z+=C0a;var C6z=u3n;C6z+=F9n;var l6z=C3n;l6z+=B8a;var r6z=y5r;r6z+=m5r;r6z+=L5L.j4v;r6z+=c0a;var c6z=z3a;c6z+=N5r;c6z+=k5r;var X6z=u0a;X6z+=S8r;var I6z=L5L.j4v;I6z+=W5a;var v6z=L5L.F4v;v6z+=T5r;var u6z=q5r;u6z+=z8n;var z6z=J5r;z6z+=P5r;var a6z=j5r;a6z+=i4v;var b6z=Y2n;b6z+=L5L.J4v;b6z+=b3a;b6z+=I8a;var H6z=L5L.j4v;H6z+=L5L.Y4v;H6z+=a6a;H6z+=D6r;var s6z=l6a;s6z+=Y5r;var Q6z=a6a;Q6z+=e5r;Q6z+=b2r;Q6z+=L5L.Y4v;var L6z=F5r;L6z+=t5r;L6z+=p3a;var O6z=Q5r;O6z+=M5r;O6z+=b3a;var K4N=d5r;K4N+=H8a;var U4N=R5r;U4N+=L5L.F4v;var D4N=h2a;D4N+=D2a;var h4N=p0n;h4N+=B5r;var x4N=L5L.j4v;x4N+=w6a;x4N+=b5r;var w4N=E9n;w4N+=D1a;var i4N=W5r;i4N+=i2a;i4N+=L5L.Y4v;var o4N=X8a;o4N+=L5L.j4v;o4N+=S9n;var f4N=b6a;f4N+=a6a;f4N+=J4a;init=$[I7a](e5a,{},Editor[p5r],init);this[b3a]=$[f4N](e5a,{},Editor[o4N][l7a],{actionName:init[f5r],table:init[i4N] || init[w4N],dbTable:init[x4N] || O1a,ajaxUrl:init[h4N],ajax:init[D4N],idSrc:init[U4N],dataSource:init[o5r] || init[A0n]?Editor[K4N][i5r]:Editor[w5r][j4a],formOptions:init[O6z],legacyAjax:init[L6z],template:init[Q6z]?$(init[s6z])[H6z]():O1a});this[b6z]=$[I7a](e5a,{},Editor[O4a]);this[S2r]=init[a6z];Editor[E8n][z6z][u6z]++;var that=this;var classes=this[v6z];this[I6z]={"wrapper":$(X6z + classes[T7a] + Y7a + x5r + classes[c6z][h5r] + r6z + D5r + classes[l6z][C6z] + Y7a + U5r + classes[l5n][K8n] + A6z + S6z + K5r + classes[O0r][n6z] + g6z + k7a + classes[O0r][V6z] + Z6z + M7a + M7a)[R1v],"form":$(G6z + classes[L0r][E6z] + Y7a + y6z + classes[L0r][m6z] + W7a + N6z)[R1v],"formError":$(k6z + classes[T6z][q6z] + W7a)[R1v],"formInfo":$(Q0r + classes[J6z][P6z] + W7a)[R1v],"header":$(j6z + classes[Y6z][T7a] + e6z + classes[S0n][F6z] + t6z)[R1v],"buttons":$(M6z + classes[d6z][R6z] + B6z)[R1v]};if($[W6z][p6z][f6z]){var x6z=L5L.Y4v;x6z+=L5L.j4v;x6z+=x4v;x6z+=a6a;var w6z=L5L.Y4v;w6z+=L5L.J4v;w6z+=f4a;var i6z=x4v;i6z+=v7a;i6z+=W1n;var o6z=K3a;o6z+=i4v;var ttButtons=$[o6z][i5r][s0r][H0r];var i18n=this[i6z];$[w6z]([K7a,x6z,n2r],function(i,val){var a0r="ttonText";var b0r="sBu";var D6z=b0r;D6z+=a0r;var h6z=z0r;h6z+=a3a;ttButtons[h6z + val][D6z]=i18n[val][Q4n];});}$[y1a](init[u0r],function(evt,fn){that[n3a](evt,function(){var K6z=d0n;K6z+=k1a;var U6z=T1a;U6z+=u8a;U6z+=u8a;var args=Array[P1a][J1a][U6z](arguments);args[K6z]();fn[G8n](that,args);});});var dom=this[V1a];var wrapper=dom[T7a];dom[O8z]=_editor_el(v0r,dom[L8z])[R1v];dom[Q8z]=_editor_el(I0r,wrapper)[R1v];dom[l5n]=_editor_el(s8z,wrapper)[R1v];dom[H8z]=_editor_el(X0r,wrapper)[R1v];dom[b8z]=_editor_el(c0r,wrapper)[R1v];if(init[a8z]){var u8z=H4a;u8z+=b3a;var z8z=L5L.J4v;z8z+=L5L.j4v;z8z+=L5L.j4v;this[z8z](init[u8z]);}$(document)[v8z](r0r + this[b3a][I8z],function(e,settings,json){var l0r="nTa";var C0r="_editor";var r8z=a6a;r8z+=g0n;L5L.r5L();r8z+=S6a;var c8z=l0r;c8z+=D1a;var X8z=e6n;X8z+=S6a;if(that[b3a][X8z] && settings[c8z] === $(that[b3a][r8z])[N9a](R1v)){settings[C0r]=that;}})[n3a](l8z + this[b3a][C8z],function(e,settings,json){var n0r="tionsUpd";var A0r="nT";var S8z=a6a;S8z+=L5L.J4v;S8z+=i2a;S8z+=L5L.Y4v;var A8z=A0r;A8z+=L5L.J4v;A8z+=D1a;if(json && that[b3a][A0n] && settings[A8z] === $(that[b3a][S8z])[N9a](R1v)){var n8z=S0r;n8z+=n0r;n8z+=P6n;that[n8z](json);}});try{var G8z=x4v;G8z+=O2r;var Z8z=g0r;Z8z+=L5L.J4v;Z8z+=B8a;var V8z=L5L.j4v;V8z+=x4v;V8z+=b3a;V8z+=t3r;var g8z=g0r;g8z+=V0r;g8z+=Z0r;this[b3a][g8z]=Editor[V8z][init[Z8z]][G8z](this);}catch(e){var G0r='Cannot find display controller ';var E8z=L5L.j4v;E8z+=P9n;E8z+=z3a;E8z+=O9a;throw G0r + init[E8z];}this[y8z](E0r,[]);$(document)[y0r](m8z,[this]);};Editor[P1a][N8z]=function(){var q0r="ddC";var k0r="addC";var J0r="las";var F8z=u3a;F8z+=m0r;var j8z=P2a;j8z+=H9a;var J8z=N0r;J8z+=L0a;var q8z=L5L.J4v;q8z+=Y8a;q8z+=n8a;q8z+=i4v;var T8z=O3r;T8z+=g8a;var k8z=L5L.F4v;k8z+=w0a;k8z+=a4a;k8z+=b3a;var classesActions=this[k8z][T8z];var action=this[b3a][q8z];var wrapper=$(this[V1a][T7a]);wrapper[v4a]([classesActions[M4n],classesActions[T3a],classesActions[D2n]][J8z](q7a));if(action === M4n){var P8z=k0r;P8z+=T0r;wrapper[P8z](classesActions[M4n]);}else if(action === j8z){var e8z=L5L.Y4v;e8z+=L5L.j4v;e8z+=x4v;e8z+=a6a;var Y8z=L5L.J4v;Y8z+=q0r;Y8z+=J0r;Y8z+=b3a;wrapper[Y8z](classesActions[e8z]);}else if(action === F8z){var M8z=u3a;M8z+=L5L.P4v;M8z+=G6n;M8z+=L5L.Y4v;var t8z=k0r;t8z+=u8a;t8z+=v8a;t8z+=b3a;wrapper[t8z](classesActions[M8z]);}};Editor[d8z][R8z]=function(data,success,error,submitParams){var l7r="deleteBody";var a7r="xOf";var C7r="ndexO";var Y0r="ELE";var H7r=/_id_/;var c7r="complete";var n7r='?';var O7r=',';var S7r="param";var P0r="delete";var X7r="shif";var K0r='idSrc';var u7r="omplete";var j0r="Body";var N3z=P0r;N3z+=j0r;var m3z=r6a;m3z+=Y0r;m3z+=e0r;var y3z=I3a;y3z+=L5L.Y4v;var E3z=L5L.j4v;E3z+=L5L.J4v;E3z+=a6a;E3z+=L5L.J4v;var g3z=T8a;g3z+=D4v;g3z+=u8a;var n3z=T8a;n3z+=D4v;n3z+=u8a;var O3z=F0r;O3z+=t0r;var K8z=D4v;K8z+=c0n;var U8z=h2a;U8z+=D2a;U8z+=B5r;var D8z=L5L.J4v;D8z+=J5a;D8z+=L5L.J4v;D8z+=D2a;var W8z=M0r;W8z+=j8a;W8z+=G8a;W8z+=a8a;var B8z=D1n;B8z+=n3a;var that=this;var action=this[b3a][B8z];var thrown;var opts={type:W8z,dataType:G9r,data:O1a,error:[function(xhr,text,err){L5L.g5L();thrown=err;}],success:[],complete:[function(xhr,text){var i0r="Te";var D0r="onseJSON";var R0r="ainObject";var d0r="Pl";var o0r="respon";var n4v=204;var h0r="esp";var w0r="rseJSON";var p0r="sta";var f0r='null';var B0r="resp";var x0r="esponseJSON";var W0r="onseText";var h8z=x4v;h8z+=b3a;h8z+=d0r;h8z+=R0r;var f8z=B0r;f8z+=W0r;var p8z=p0r;p8z+=a6a;p8z+=n1a;var json=O1a;if(xhr[p8z] === n4v || xhr[f8z] === f0r){json={};}else {try{var x8z=o0r;x8z+=Q9a;x8z+=i0r;x8z+=H6a;var w8z=a5n;w8z+=w0r;var i8z=D4v;i8z+=x0r;var o8z=D4v;o8z+=h0r;o8z+=D0r;json=xhr[o8z]?xhr[i8z]:$[w8z](xhr[x8z]);}catch(e){}}if($[h8z](json) || $[X6n](json)){success(json,xhr[U0r] >= g4v,xhr);}else {error(xhr,text,thrown);}}]};var a;var ajaxSrc=this[b3a][D8z] || this[b3a][U8z];var id=action === F8r || action === K8z?_pluck(this[b3a][c6r],K0r):O1a;if($[O3z](id)){id=id[q3r](O7r);}if($[a7n](ajaxSrc) && ajaxSrc[action]){ajaxSrc=ajaxSrc[action];}if(typeof ajaxSrc === L5L.d4v){var L3z=L7r;L3z+=D4v;L3z+=u8a;var uri=O1a;var method=O1a;if(this[b3a][L3z]){var b3z=u3a;b3z+=z3a;b3z+=Y8r;var s3z=B2a;s3z+=L7a;s3z+=L5L.Y4v;var Q3z=h2a;Q3z+=D2a;Q3z+=B5r;var url=this[b3a][Q3z];if(url[s3z]){uri=url[action];}if(uri[Q7r](q7a) !== -B1v){var H3z=s7r;H3z+=H9a;a=uri[H3z](q7a);method=a[R1v];uri=a[B1v];}uri=uri[b3z](H7r,id);}ajaxSrc(method,uri,data,success,error);return;}else if(typeof ajaxSrc === A4n){var a3z=b7r;a3z+=L5L.Y4v;a3z+=a7r;if(ajaxSrc[a3z](q7a) !== -B1v){var u3z=T8a;u3z+=D4v;u3z+=u8a;var z3z=K2a;z3z+=u8a;z3z+=H9a;a=ajaxSrc[z3z](q7a);opts[s3a]=a[R1v];opts[u3z]=a[B1v];}else {opts[A6r]=ajaxSrc;}}else {var S3z=b6a;S3z+=z7r;var l3z=L5L.Y4v;l3z+=D4v;l3z+=w2a;l3z+=D4v;var I3z=L5L.F4v;I3z+=u7r;var v3z=L5L.Y4v;v3z+=H6a;v3z+=L5L.Y4v;v3z+=y8a;var optsCopy=$[v3z]({},ajaxSrc || ({}));if(optsCopy[I3z]){var r3z=R1a;r3z+=v7r;r3z+=S6a;r3z+=l6a;var c3z=R1a;c3z+=v7r;c3z+=I7r;var X3z=T8a;X3z+=i4v;X3z+=X7r;X3z+=a6a;opts[c7r][X3z](optsCopy[c3z]);delete optsCopy[r3z];}if(optsCopy[l3z]){var A3z=m2n;A3z+=d0n;A3z+=K3a;A3z+=a6a;var C3z=L5L.Y4v;C3z+=r7r;C3z+=K4v;C3z+=D4v;opts[C3z][A3z](optsCopy[z4a]);delete optsCopy[z4a];}opts=$[S3z]({},opts,optsCopy);}opts[n3z]=opts[g3z][s6n](H7r,id);if(opts[Z7a]){var G3z=b6a;G3z+=l6a;G3z+=i4v;G3z+=L5L.j4v;var Z3z=L5L.j4v;Z3z+=L5L.J4v;Z3z+=a6a;Z3z+=L5L.J4v;var V3z=L5L.j4v;V3z+=L5L.J4v;V3z+=a6a;V3z+=L5L.J4v;var isFn=typeof opts[Z7a] === L5L.d4v;var newData=isFn?opts[V3z](data):opts[Z3z];data=isFn && newData?newData:$[G3z](e5a,data,newData);}opts[E3z]=data;if(opts[y3z] === m3z && (opts[N3z] === undefined || opts[l7r] === e5a)){var J3z=L5L.j4v;J3z+=L7a;J3z+=L5L.J4v;var q3z=x4v;q3z+=C7r;q3z+=K3a;var T3z=T8a;T3z+=A7r;var k3z=L5L.j4v;k3z+=L5L.J4v;k3z+=a6a;k3z+=L5L.J4v;var params=$[S7r](opts[k3z]);opts[T3z]+=opts[A6r][q3z](n7r) === -B1v?n7r + params:a6n + params;delete opts[J3z];}$[p0n](opts);};Editor[P1a][e3n]=function(target,style,time,callback){L5L.r5L();var g7r="stop";if($[k4a][V5n]){var P3z=J6n;P3z+=L5L.P4v;P3z+=P6n;target[g7r]()[P3z](style,time,callback);}else {target[s1a](style);if(typeof time === L5L.d4v){time[z4n](target);}else if(callback){callback[z4n](target);}}};Editor[P1a][p4n]=function(){var V7r="formIn";var Z7r="bodyContent";var M3z=i8n;M3z+=V7n;M3z+=L5L.j4v;var t3z=V7r;t3z+=X7n;var F3z=L0r;F3z+=R6a;var e3z=i8n;e3z+=J4a;var Y3z=a3n;Y3z+=L5L.J4v;Y3z+=z3a;Y3z+=z3n;var j3z=L5L.j4v;j3z+=W5a;var dom=this[j3z];$(dom[Y3z])[L1n](dom[S0n]);$(dom[O0r])[e3z](dom[F3z])[O3n](dom[q8r]);L5L.g5L();$(dom[Z7r])[O3n](dom[t3z])[M3z](dom[L0r]);};Editor[P1a][d3z]=function(){var G7r="ose";var y7r="lur";var E7r="eB";var W3z=L5L.F4v;W3z+=u8a;W3z+=G7r;var B3z=z3a;B3z+=D4v;B3z+=E7r;B3z+=y7r;var R3z=m7r;R3z+=B3a;var opts=this[b3a][o0n];var onBlur=opts[R3z];if(this[X1n](B3z) === Y5a){return;}if(typeof onBlur === L5L.d4v){onBlur(this);}else if(onBlur === x0n){this[T6n]();}else if(onBlur === W3z){this[N7r]();}};Editor[P1a][p3z]=function(){var k7r="oveCla";var T7r="asse";var i3z=D4v;i3z+=F1n;i3z+=k7r;i3z+=x0a;var o3z=a3n;o3z+=N3n;var f3z=Y2n;f3z+=T7r;f3z+=b3a;L5L.g5L();if(!this[b3a]){return;}var errorClass=this[f3z][H4a][z4a];var fields=this[b3a][k0n];$(J8r + errorClass,this[V1a][o3z])[i3z](errorClass);$[y1a](fields,function(name,field){var w3z=L5L.P4v;w3z+=G2r;w3z+=x8r;field[z4a](U9a)[w3z](U9a);});this[z4a](U9a)[h7a](U9a);};Editor[P1a][x3z]=function(submitComplete,mode){var J7r="preC";var Y7r="seCb";var F7r='focus.editor-focus';var t7r="osed";var j7r="clo";var Q2z=L5L.F4v;Q2z+=L9a;Q2z+=b3a;Q2z+=L5L.Y4v;var L2z=j6r;L2z+=N3a;L2z+=V7n;L2z+=a6a;var O2z=T9n;O2z+=w0a;O2z+=q7r;O2z+=L5L.j4v;var K3z=K4v;K3z+=K3a;K3z+=K3a;var D3z=J7r;D3z+=L9a;D3z+=Q9a;L5L.g5L();var h3z=a3a;h3z+=L5L.Y4v;h3z+=f4v;h3z+=B1a;var closed;if(this[h3z](D3z) === Y5a){return;}if(this[b3a][P7r]){var U3z=j7r;U3z+=Y7r;closed=this[b3a][P7r](submitComplete,mode);this[b3a][U3z]=O1a;}if(this[b3a][e7r]){this[b3a][e7r]();this[b3a][e7r]=O1a;}$(x1a)[K3z](F7r);this[b3a][O2z]=Y5a;this[L2z](Q2z);if(closed){var s2z=Y2n;s2z+=t7r;this[X1n](s2z,[closed]);}};Editor[P1a][b1n]=function(fn){this[b3a][P7r]=fn;};Editor[H2z][e4n]=function(arg1,arg2,arg3,arg4){var d7r="main";var that=this;var title;var buttons;var show;var opts;if($[a7n](arg1)){opts=arg1;}else if(typeof arg1 === M7r){show=arg1;opts=arg2;;}else {title=arg1;buttons=arg2;show=arg3;opts=arg4;;}L5L.r5L();if(show === undefined){show=e5a;}if(title){var b2z=a6a;b2z+=H9a;b2z+=u8a;b2z+=L5L.Y4v;that[b2z](title);}if(buttons){that[q8r](buttons);}return {opts:$[I7a]({},this[b3a][m8n][d7r],opts),maybeOpen:function(){if(show){var a2z=A1a;a2z+=L5L.Y4v;a2z+=i4v;that[a2z]();}}};};Editor[P1a][P0n]=function(name){var R7r="Sour";var I2z=Z7a;I2z+=R7r;I2z+=L5L.F4v;I2z+=L5L.Y4v;var v2z=L5L.F4v;v2z+=B7r;var u2z=S6n;u2z+=x4v;u2z+=P6r;var z2z=m3a;z2z+=h4v;z2z+=I3a;z2z+=L5L.Y4v;var args=Array[z2z][u2z][v2z](arguments);args[Z8n]();var fn=this[b3a][I2z][name];if(fn){return fn[G8n](this,args);}};Editor[X2z][c2z]=function(includeFields){var o7r="includeFi";var Q1r='displayOrder';var W7r="hildren";var f7r="formContent";var J2z=X1a;J2z+=b9n;J2z+=q7r;J2z+=L5L.j4v;var g2z=L8r;g2z+=q8a;L5L.g5L();var n2z=V8a;n2z+=I1n;n2z+=q8a;var S2z=L5L.F4v;S2z+=W7r;var C2z=L5L.P4v;C2z+=p7r;C2z+=L5L.Y4v;var l2z=l6a;l2z+=L5L.P4v;l2z+=b9n;l2z+=l6a;var r2z=K4v;r2z+=D4v;r2z+=V8a;r2z+=D4v;var that=this;var formContent=$(this[V1a][f7r]);var fields=this[b3a][k0n];var order=this[b3a][r2z];var template=this[b3a][l2z];var mode=this[b3a][C2z] || F4n;if(includeFields){this[b3a][G4n]=includeFields;}else {var A2z=o7r;A2z+=x6a;A2z+=L5L.j4v;A2z+=b3a;includeFields=this[b3a][A2z];}formContent[S2z]()[n2z]();$[g2z](order,function(i,fieldOrName){var U7r='[data-editor-template="';var x7r="nA";var h7r="editor-field[na";var i7r="_w";var D7r="me=\"";var w7r="eakI";var Z2z=i7r;Z2z+=w7r;Z2z+=x7r;Z2z+=t0r;var V2z=i4v;V2z+=L5L.J4v;V2z+=u6a;var name=fieldOrName instanceof Editor[F5a]?fieldOrName[V2z]():fieldOrName;if(that[Z2z](name,includeFields) !== -B1v){if(template && mode === F4n){var k2z=K3a;k2z+=L0a;k2z+=L5L.j4v;var N2z=A2a;N2z+=L5L.j4v;N2z+=L5L.Y4v;var m2z=w3a;m2z+=E7n;var y2z=v5a;y2z+=I5a;var E2z=h7r;E2z+=D7r;var G2z=K3a;G2z+=x4v;G2z+=y8a;template[G2z](E2z + name + y2z)[m2z](fields[name][N2z]());template[k2z](U7r + name + K7r)[O3n](fields[name][V0n]());}else {var q2z=A2a;q2z+=L5L.j4v;q2z+=L5L.Y4v;var T2z=O1r;T2z+=L5L.j4v;formContent[T2z](fields[name][q2z]());}}});if(template && mode === F4n){template[L1r](formContent);}this[X1n](Q1r,[this[b3a][J2z],this[b3a][t4n],formContent]);};Editor[P1a][P2z]=function(items,editFields,type,formOptions,setupDone){var l1r='initEdit';var C1r='node';var H1r="onClass";var H9z=L5L.j4v;H9z+=L5L.J4v;H9z+=E9n;var L9z=p2r;L9z+=q8a;var O9z=b3a;O9z+=T3r;O9z+=L5L.Y4v;var K2z=K4v;K2z+=l2a;K2z+=L5L.Y4v;K2z+=D4v;var R2z=a3a;R2z+=L5L.J4v;R2z+=s1r;R2z+=H1r;var d2z=K3a;d2z+=K4v;d2z+=T4n;var M2z=L5L.j4v;M2z+=K4v;M2z+=L5L.P4v;var t2z=P2a;t2z+=H9a;var F2z=X8a;F2z+=b1r;F2z+=j3a;var e2z=P2a;e2z+=H9a;e2z+=s5a;e2z+=L5L.J4v;var Y2z=L5L.Y4v;Y2z+=J4n;Y2z+=r9a;Y2z+=b3a;var j2z=T2a;j2z+=u8a;j2z+=u8n;var that=this;var fields=this[b3a][j2z];var usedFields=[];var includeInOrder;var editData={};this[b3a][Y2z]=editFields;this[b3a][e2z]=editData;this[b3a][F2z]=items;this[b3a][t4n]=t2z;this[M2z][d2z][B9n][j2a]=X8n;this[b3a][v9a]=type;this[R2z]();$[y1a](fields,function(name,field){var a1r="iIds";var z1r="tiRe";var D2z=t5a;D2z+=u8a;D2z+=a6a;D2z+=a1r;var W2z=u1a;W2z+=f4a;var B2z=h6n;B2z+=z1r;B2z+=b3a;B2z+=V2a;field[B2z]();includeInOrder=Y5a;editData[name]={};$[W2z](editFields,function(idSrc,edit){var I1r="iS";var v1r="Fields";if(edit[k0n][name]){var o2z=D4v;o2z+=K4v;o2z+=r2a;var f2z=b3a;f2z+=R1a;f2z+=z3a;f2z+=L5L.Y4v;var p2z=u1r;p2z+=D4v;p2z+=q9n;var val=field[E7a](edit[Z7a]);editData[name][idSrc]=val === O1a?U9a:$[p2z](val)?val[J1a]():val;if(!formOptions || formOptions[f2z] === o2z){var w2z=j2a;w2z+=v1r;var i2z=V8a;i2z+=K3a;field[B4n](idSrc,val !== undefined?val:field[i2z]());if(!edit[w2z] || edit[b8r][name]){includeInOrder=e5a;}}else {if(!edit[b8r] || edit[b8r][name]){var h2z=L5L.j4v;h2z+=L5L.Y4v;h2z+=K3a;var x2z=J0a;x2z+=I1r;x2z+=V2a;field[x2z](idSrc,val !== undefined?val:field[h2z]());includeInOrder=e5a;}}}});if(field[D2z]()[j5a] !== R1v && includeInOrder){var U2z=X1r;U2z+=c2a;usedFields[U2z](name);}});var currOrder=this[K2z]()[O9z]();for(var i=currOrder[L9z] - B1v;i >= R1v;i--){var Q9z=c1r;Q9z+=V6n;Q9z+=g2n;if($[Z4n](currOrder[i][Q9z](),usedFields) === -B1v){var s9z=K2a;s9z+=u8a;s9z+=r1r;s9z+=L5L.Y4v;currOrder[s9z](i,B1v);}}this[d4n](currOrder);this[X1n](l1r,[_pluck(editFields,C1r)[R1v],_pluck(editFields,H9z)[R1v],items,type],function(){var S1r="tiEdit";var A1r="initMul";var b9z=A1r;b9z+=S1r;that[X1n](b9z,[editFields,items,type],function(){setupDone();});});};Editor[P1a][a9z]=function(trigger,args,promiseComplete){var E1r="Ev";var n1r="esu";var P1r="res";var y1r='pre';var V1r="ndexOf";var g1r="resul";var N1r="Event";var G1r="ggerHandler";var T1r="result";var J1r="sul";var q1r="then";var k1r='Cancelled';var Z1r="tri";var z9z=F0r;z9z+=r7r;z9z+=q9n;if(!args){args=[];}if($[z9z](trigger)){for(var i=R1v,ien=trigger[j5a];i < ien;i++){var u9z=a3a;u9z+=h4n;u9z+=i4v;u9z+=a6a;this[u9z](trigger[i],args);}}else {var S9z=D4v;S9z+=n1r;S9z+=u7a;var c9z=g1r;c9z+=a6a;var X9z=x4v;X9z+=V1r;var I9z=Z1r;I9z+=G1r;var v9z=E1r;v9z+=k3a;var e=$[v9z](trigger);$(this)[I9z](e,args);if(trigger[X9z](y1r) === R1v && e[c9z] === Y5a){$(this)[m1r]($[N1r](trigger + k1r),args);}if(promiseComplete){var l9z=q5a;l9z+=D3r;var r9z=D4v;r9z+=L5L.Y4v;r9z+=b3a;r9z+=b8n;if(e[r9z] && typeof e[T1r] === l9z && e[T1r][q1r]){var C9z=u3a;C9z+=J1r;C9z+=a6a;e[C9z][q1r](promiseComplete);}else {var A9z=P1r;A9z+=b8n;promiseComplete(e[A9z]);}}return e[S9z];}};Editor[n9z][X3r]=function(input){var F1r="substring";var j1r="tch";var Y1r=/^on([A-Z])/;var e1r="toLowerCase";var g9z=s7r;g9z+=H9a;var name;var names=input[g9z](q7a);for(var i=R1v,ien=names[j5a];i < ien;i++){var V9z=L5L.P4v;V9z+=L5L.J4v;V9z+=j1r;name=names[i];var onStyle=name[V9z](Y1r);if(onStyle){name=onStyle[B1v][e1r]() + name[F1r](p1v);}names[i]=name;}return names[q3r](q7a);};Editor[P1a][Z9z]=function(node){L5L.g5L();var foundField=O1a;$[y1a](this[b3a][k0n],function(name,field){var y9z=p2r;y9z+=q8a;var E9z=q6n;E9z+=y8a;var G9z=i4v;G9z+=K4v;G9z+=L5L.j4v;G9z+=L5L.Y4v;if($(field[G9z]())[E9z](node)[y9z]){foundField=field;}});return foundField;};Editor[m9z][N9z]=function(fieldNames){var t1r="Array";L5L.g5L();var k9z=x4v;k9z+=b3a;k9z+=t1r;if(fieldNames === undefined){return this[k0n]();}else if(!$[k9z](fieldNames)){return [fieldNames];}return fieldNames;};Editor[P1a][r1n]=function(fieldsIn,focus){var B1r="q";var p1r="div.D";var f1r="TE ";var W1r=":";var M1r="etF";var d1r="um";var i1r="activeElemen";var o1r=/^jq:/;var t9z=b3a;t9z+=M1r;t9z+=K4v;t9z+=c7n;var J9z=i4v;J9z+=d1r;J9z+=O0a;J9z+=D4v;var that=this;var field;var fields=$[T6r](fieldsIn,function(fieldOrName){var R1r="ields";var q9z=K3a;q9z+=R1r;var T9z=L6n;T9z+=D4v;T9z+=g2n;return typeof fieldOrName === T9z?that[b3a][q9z][fieldOrName]:fieldOrName;});if(typeof focus === J9z){field=fields[focus];}else if(focus){var P9z=J5a;P9z+=B1r;P9z+=W1r;if(focus[Q7r](P9z) === R1v){var Y9z=u3a;Y9z+=b9n;Y9z+=P6r;var j9z=p1r;j9z+=f1r;field=$(j9z + focus[Y9z](o1r,U9a));}else {var e9z=q6n;e9z+=r9a;e9z+=b3a;field=this[b3a][e9z][focus];}}else {var F9z=i1r;F9z+=a6a;document[F9z][w0n]();}this[b3a][t9z]=field;if(field){var M9z=X7n;M9z+=L5L.F4v;M9z+=T8a;M9z+=b3a;field[M9z]();}};Editor[d9z][R9z]=function(opts){var v4r="onBac";var Z4r="canReturnSubmit";var h1r="Cou";var U1r="itOnRetur";var L4r="closeOnComplete";var z4r="submitOnReturn";var a4r="turn";var D1r="editOp";var w1r="dow";var c4r="ssa";var b4r="onRe";var H4r="tOnBlur";var u4r="blurOnBackground";var x1r="sag";var K1r="OnBlur";var X4r="ssag";var O4r='.dteInline';var I4r="kg";var I5z=v4n;I5z+=w1r;I5z+=i4v;var v5z=K4v;v5z+=i4v;var u5z=b9a;u5z+=a6a;u5z+=a6a;u5z+=m8r;var b5z=m6r;b5z+=x1r;b5z+=L5L.Y4v;var H5z=u6a;H5z+=x0a;H5z+=x8r;var Q5z=z2r;Q5z+=C7n;var L5z=L6n;L5z+=D4v;L5z+=x4v;L5z+=k9r;var O5z=Y6n;O5z+=a6a;O5z+=u8a;O5z+=L5L.Y4v;var K9z=T3a;K9z+=h1r;K9z+=B1a;var U9z=D1r;U9z+=a6a;U9z+=b3a;var o9z=O4n;o9z+=U1r;o9z+=i4v;var W9z=T6n;W9z+=K1r;var that=this;var inlineCount=__inlineCounter++;var namespace=O4r + inlineCount;if(opts[L4r] !== undefined){var B9z=L5L.F4v;B9z+=L9a;B9z+=Q9a;opts[Q4r]=opts[L4r]?B9z:h1a;}if(opts[W9z] !== undefined){var f9z=b3a;f9z+=s4r;f9z+=x4v;f9z+=H4r;var p9z=m7r;p9z+=T8a;p9z+=D4v;opts[p9z]=opts[f9z]?x0n:N8n;}if(opts[o9z] !== undefined){var w9z=O4n;w9z+=x4v;w9z+=a6a;var i9z=b4r;i9z+=a4r;opts[i9z]=opts[z4r]?w9z:h1a;}L5L.r5L();if(opts[u4r] !== undefined){var D9z=A2a;D9z+=i4v;D9z+=L5L.Y4v;var h9z=w6a;h9z+=u8a;h9z+=T8a;h9z+=D4v;var x9z=v4r;x9z+=I4r;x9z+=w3n;opts[x9z]=opts[u4r]?h9z:D9z;}this[b3a][U9z]=opts;this[b3a][K9z]=inlineCount;if(typeof opts[O5z] === L5z || typeof opts[H1n] === Q5z){var s5z=Y6n;s5z+=a6a;s5z+=u8a;s5z+=L5L.Y4v;this[H1n](opts[H1n]);opts[s5z]=e5a;}if(typeof opts[H5z] === A4n || typeof opts[b5z] === L5L.d4v){var z5z=u6a;z5z+=X4r;z5z+=L5L.Y4v;var a5z=u6a;a5z+=c4r;a5z+=U8r;this[a5z](opts[z5z]);opts[h7a]=e5a;}if(typeof opts[u5z] !== M7r){this[q8r](opts[q8r]);opts[q8r]=e5a;}$(document)[v5z](I5z + namespace,function(e){var C4r="veE";var A4r="leme";var S4r="unc";var g4r="eturnSub";var n4r="canR";var V4r="ieldFromN";var r4r="keyC";var X5z=r4r;L5L.r5L();X5z+=l4r;if(e[X5z] === U1v && that[b3a][N6r]){var c5z=D1n;c5z+=C4r;c5z+=A4r;c5z+=B1a;var el=$(document[c5z]);if(el){var C5z=K3a;C5z+=S4r;C5z+=C7n;var l5z=n4r;l5z+=g4r;l5z+=B1n;var r5z=E3a;r5z+=V4r;r5z+=l4r;var field=that[r5z](el);if(field && typeof field[l5z] === C5z && field[Z4r](el)){e[l4n]();}}}});$(document)[n3a](b4n + namespace,function(e){var W4r='button';var J4r="nction";var d4r='.DTE_Form_Buttons';var T4r="_fieldFromN";var F4r="onReturn";var N4r="uncti";var X4v=39;var y4r="keyCo";var M4r="onEsc";var p4r="cu";var G4r="aren";var j4r="Return";var e4r="entDe";var P4r="nRe";var I4v=37;var E4r="eyCode";var R4r="eyC";var k4r="canReturnSubmi";var q5z=p2r;q5z+=q8a;var T5z=z3a;T5z+=G4r;T5z+=O3a;var m5z=o6n;m5z+=E4r;var A5z=y4r;A5z+=V8a;var el=$(document[m4r]);if(e[A5z] === U1v && that[b3a][N6r]){var g5z=K3a;g5z+=N4r;g5z+=n3a;var n5z=k4r;n5z+=a6a;var S5z=T4r;S5z+=l4r;var field=that[S5z](el);if(field && typeof field[n5z] === g5z && field[Z4r](el)){var E5z=q4r;E5z+=J4r;var G5z=K4v;G5z+=P4r;G5z+=d5a;G5z+=i4v;var V5z=n3a;V5z+=j4r;if(opts[V5z] === x0n){var Z5z=R1n;Z5z+=Y4r;Z5z+=x4v;Z5z+=a6a;e[l4n]();that[Z5z]();}else if(typeof opts[G5z] === E5z){var y5z=d9r;y5z+=N3a;y5z+=e4r;y5z+=r4n;e[y5z]();opts[F4r](that,e);}}}else if(e[m5z] === b4v){var k5z=i2a;k5z+=B3a;var N5z=n3a;N5z+=z8a;N5z+=t4r;e[l4n]();if(typeof opts[M4r] === L5L.d4v){opts[M4r](that,e);}else if(opts[N5z] === k5z){that[w0n]();}else if(opts[M4r] === N8n){that[L3n]();}else if(opts[M4r] === x0n){that[T6n]();}}else if(el[T5z](d4r)[q5z]){var P5z=o6n;P5z+=R4r;P5z+=p7r;P5z+=L5L.Y4v;if(e[B4r] === I4v){var J5z=d9r;J5z+=N3a;el[J5z](W4r)[y3r]();}else if(e[P5z] === X4v){var Y5z=X7n;Y5z+=p4r;Y5z+=b3a;var j5z=y2a;j5z+=H6a;el[j5z](W4r)[Y5z]();}}});this[b3a][e7r]=function(){var o4r="wn";var f4r="ey";var t5z=K4v;t5z+=K3a;t5z+=K3a;var F5z=o6n;F5z+=f4r;F5z+=v1a;L5L.r5L();F5z+=o4r;var e5z=K4v;e5z+=K3a;e5z+=K3a;$(document)[e5z](F5z + namespace);$(document)[t5z](b4n + namespace);};return namespace;};Editor[P1a][i4r]=function(direction,action,data){var x4r='send';var w4r="legacyAjax";if(!this[b3a][w4r] || !data){return;}if(direction === x4r){var d5z=L5L.Y4v;d5z+=U2a;d5z+=a6a;var M5z=B2a;M5z+=L5L.J4v;M5z+=l6a;if(action === M5z || action === d5z){var W5z=L5L.j4v;W5z+=Q7a;var B5z=L5L.j4v;B5z+=L5L.J4v;B5z+=a6a;B5z+=L5L.J4v;var R5z=L5L.Y4v;R5z+=L5L.J4v;R5z+=L5L.F4v;R5z+=q8a;var id;$[R5z](data[B5z],function(rowId,values){var h4r='Editor: Multi-row editing is not supported by the legacy Ajax data format';L5L.r5L();if(id !== undefined){throw h4r;}id=rowId;});data[W5z]=data[Z7a][id];if(action === F8r){data[A7a]=id;}}else {var p5z=Z9a;p5z+=E9n;data[A7a]=$[T6r](data[p5z],function(values,id){L5L.r5L();return id;});delete data[Z7a];}}else {if(!data[Z7a] && data[H2a]){var f5z=D4v;f5z+=K4v;f5z+=r2a;data[Z7a]=[data[f5z]];}else if(!data[Z7a]){var o5z=L5L.j4v;o5z+=L5L.J4v;o5z+=a6a;o5z+=L5L.J4v;data[o5z]=[];}}};Editor[P1a][i5z]=function(json){var that=this;L5L.g5L();if(json[D4r]){$[y1a](this[b3a][k0n],function(name,field){var K4r="update";var w5z=U4r;w5z+=x4v;w5z+=m8r;if(json[w5z][name] !== undefined){var fieldInst=that[H4a](name);if(fieldInst && fieldInst[K4r]){var x5z=K4v;x5z+=O6d;fieldInst[K4r](json[x5z][name]);}}});}};Editor[h5z][B6r]=function(el,msg){var L6d="eOut";var D5z=K3a;D5z+=i4v;var canAnimate=$[D5z][V5n]?e5a:Y5a;if(typeof msg === L5L.d4v){var U5z=F6n;U5z+=z3a;U5z+=x4v;msg=msg(this,new DataTable[U5z](this[b3a][A0n]));}el=$(el);L5L.g5L();if(canAnimate){var K5z=b3a;K5z+=a6a;K5z+=A1a;el[K5z]();}if(!msg){if(this[b3a][N6r] && canAnimate){var O0z=v0n;O0z+=L5L.j4v;O0z+=L6d;el[O0z](function(){el[j4a](U9a);});}else {var Q0z=i4v;Q0z+=c3r;var L0z=L5L.F4v;L0z+=b3a;L0z+=b3a;el[j4a](U9a)[L0z](H1a,Q0z);}}else {if(this[b3a][N6r] && canAnimate){var s0z=R6n;s0z+=L5L.P4v;s0z+=u8a;el[s0z](msg)[Z5n]();}else {var a0z=i2a;a0z+=K4v;a0z+=L5L.F4v;a0z+=o6n;var b0z=U2a;b0z+=b3a;b0z+=t3r;var H0z=q8a;H0z+=a6a;H0z+=L5L.P4v;H0z+=u8a;el[H0z](msg)[s1a](b0z,a0z);}}};Editor[z0z][u0z]=function(){var s6d="foShown";var H6d="Mu";var a6d="multiEd";var b6d="MultiValu";var Q6d="multiIn";var z6d="ita";var I0z=u8a;L5L.r5L();I0z+=c6n;var v0z=H4a;v0z+=b3a;var fields=this[b3a][v0z];var include=this[b3a][G4n];var show=e5a;var state;if(!include){return;}for(var i=R1v,ien=include[I0z];i < ien;i++){var l0z=Q6d;l0z+=s6d;var r0z=P9n;r0z+=H6d;r0z+=c4a;var c0z=P9n;c0z+=b6d;c0z+=L5L.Y4v;var X0z=a6d;X0z+=z6d;X0z+=i2a;X0z+=L5L.Y4v;var field=fields[include[i]];var multiEditable=field[X0z]();if(field[c0z]() && multiEditable && show){state=e5a;show=Y5a;}else if(field[r0z]() && !multiEditable){state=e5a;}else {state=Y5a;}fields[include[i]][l0z](state);}};Editor[P1a][i8r]=function(type,immediate){var X6d="ptu";var r6d="displayControll";var Z6d="_multiInfo";var S6d="tor-focus";var v6d="t.editor-int";var I6d="ernal";var l6d='submit.editor-internal';var A6d="focus.edi";var c6d="eFocus";var T0z=A1a;T0z+=L5L.Y4v;T0z+=i4v;var V0z=b9a;V0z+=n1n;V0z+=u8a;V0z+=L5L.Y4v;var g0z=h9n;g0z+=x4v;L5L.g5L();g0z+=i4v;var S0z=u6d;S0z+=v6d;S0z+=I6d;var A0z=T1a;A0z+=X6d;A0z+=D4v;A0z+=c6d;var C0z=r6d;C0z+=j3a;var that=this;var focusCapture=this[b3a][C0z][A0z];if(focusCapture === undefined){focusCapture=e5a;}$(this[V1a][L0r])[E5n](S0z)[n3a](l6d,function(e){var C6d="reventDefault";var n0z=z3a;n0z+=C6d;e[n0z]();});if(focusCapture && (type === g0z || type === V0z)){var G0z=A6d;G0z+=S6d;var Z0z=K4v;Z0z+=i4v;$(x1a)[Z0z](G0z,function(){var V6d="setFocus";var g6d='.DTED';var k0z=S6a;k0z+=S1n;var N0z=M6n;N0z+=b3a;var m0z=u8a;m0z+=V7n;m0z+=k5a;var y0z=J2n;L5L.r5L();y0z+=e0r;var E0z=n6d;E0z+=k3a;E0z+=b3a;if($(document[m4r])[E0z](y0z)[m0z] === R1v && $(document[m4r])[N0z](g6d)[k0z] === R1v){if(that[b3a][V6d]){that[b3a][V6d][y3r]();}}});}this[Z6d]();this[X1n](T0z,[type,this[b3a][t4n]]);if(immediate){var P0z=D1n;P0z+=n3a;var J0z=A1a;J0z+=V7n;J0z+=L5L.Y4v;J0z+=L5L.j4v;var q0z=a3a;q0z+=L5L.Y4v;q0z+=f4v;q0z+=B1a;this[q0z](J0z,[type,this[b3a][P0z]]);}return e5a;};Editor[j0z][Y0z]=function(type){var E6d="eOpe";var G6d="layed";var y6d="elOpen";var R0z=T9n;R0z+=G6d;var e0z=U4v;e0z+=E6d;e0z+=i4v;if(this[X1n](e0z,[type,this[b3a][t4n]]) === Y5a){var d0z=L5L.P4v;d0z+=l4r;var M0z=O3r;M0z+=i4v;var t0z=T1a;t0z+=I6a;t0z+=y6d;var F0z=a3a;F0z+=m6d;this[M8r]();this[F0z](t0z,[type,this[b3a][M0z]]);if((this[b3a][d0z] === d8r || this[b3a][v9a] === f7n) && this[b3a][e7r]){this[b3a][e7r]();}this[b3a][e7r]=O1a;return Y5a;}this[b3a][R0z]=type;return e5a;};Editor[P1a][B0z]=function(processing){var N6d="proce";var k6d="togg";L5L.g5L();var q6d='div.DTE';var i0z=N6d;i0z+=b3a;i0z+=b8a;var o0z=k6d;o0z+=S6a;o0z+=T6d;var f0z=r2a;f0z+=X2n;f0z+=L6a;f0z+=D4v;var p0z=v1a;p0z+=L5L.P4v;var W0z=D1n;W0z+=N3a;W0z+=L5L.Y4v;var procClass=this[O4a][w4a][W0z];$([q6d,this[p0z][f0z]])[o0z](procClass,processing);this[b3a][i0z]=processing;this[X1n](c0r,[processing]);};Editor[w0z][Q2r]=function(successCallback,errorCallback,formatdata,hide){var o6d="chang";var P6d="Ajax";var H8d='all';var J6d="_legacy";var j6d="dbTa";var b8d="submitC";var z8d="nCom";var Y6d="ionName";var a8d="_processi";var R6d="aSourc";var M6d="ount";var i6d="lIfChanged";var c8d="_ajax";var X8d="ocessin";var F6d="itData";var p6d="tO";var W6d="Se";var v8d="Complete";var e6d="Opt";var f6d="bjectDataFn";var I8d='preSubmit';var P7z=T1a;P7z+=u8a;P7z+=u8a;var J7z=L7r;J7z+=A7r;var q7z=L5L.J4v;q7z+=J5a;q7z+=L5L.J4v;q7z+=D2a;var k7z=b6a;k7z+=z7r;var N7z=b3a;N7z+=J4a;var m7z=J6d;m7z+=P6d;var b7z=P2a;b7z+=x4v;b7z+=a6a;var H7z=P4n;H7z+=L5L.Y4v;H7z+=P6n;var L7z=j6d;L7z+=D1a;var O7z=l5a;O7z+=a6a;O7z+=Y6d;var K0z=T3a;K0z+=e6d;K0z+=b3a;var U0z=L5L.Y4v;U0z+=L5L.j4v;U0z+=F6d;var D0z=T3a;D0z+=t6d;D0z+=M6d;var h0z=d6d;h0z+=R6d;h0z+=L5L.Y4v;var x0z=B6d;x0z+=W6d;x0z+=p6d;x0z+=f6d;var that=this;var i,iLen,eventRet,errorNodes;var changed=Y5a,allData={},changedData={};var setBuilder=DataTable[b0a][G7a][x0z];var dataSource=this[b3a][h0z];var fields=this[b3a][k0n];var editCount=this[b3a][D0z];var modifier=this[b3a][b3r];var editFields=this[b3a][c6r];var editData=this[b3a][U0z];var opts=this[b3a][K0z];var changedSubmit=opts[T6n];var submitParamsLocal;var action=this[b3a][t4n];var submitParams={"data":{}};submitParams[this[b3a][O7z]]=action;if(this[b3a][L7z]){var s7z=j6d;s7z+=D1a;var Q7z=a6a;Q7z+=g0n;Q7z+=S6a;submitParams[Q7z]=this[b3a][s7z];}if(action === H7z || action === b7z){var C7z=o6d;C7z+=L5L.Y4v;C7z+=L5L.j4v;var l7z=L5L.J4v;l7z+=u8a;l7z+=i6d;$[y1a](editFields,function(idSrc,edit){var w6d="isEmptyO";var x6d="bject";var s8d="isEmptyObject";var r7z=w6d;r7z+=x6d;var allRowData={};var changedRowData={};L5L.r5L();$[y1a](fields,function(name,field){var Q8d='-many-count';L5L.g5L();var D6d="com";var K6d="G";var O8d='[]';var L8d=/\[.*$/;var h6d="submittable";if(edit[k0n][name] && field[h6d]()){var X7z=D6d;X7z+=n6d;X7z+=L5L.Y4v;var I7z=L5L.Y4v;I7z+=U2a;I7z+=a6a;var v7z=u3a;v7z+=z3a;v7z+=Y8r;var u7z=F0r;u7z+=D4v;u7z+=U6d;var a7z=L5L.P4v;a7z+=G1a;a7z+=K6d;a7z+=V2a;var multiGet=field[a7z]();var builder=setBuilder(name);if(multiGet[idSrc] === undefined){var z7z=Z9a;z7z+=E9n;var originalVal=field[E7a](edit[z7z]);builder(allRowData,originalVal);return;}var value=multiGet[idSrc];var manyBuilder=$[u7z](value) && name[Q7r](O8d) !== -B1v?setBuilder(name[v7z](L8d,U9a) + Q8d):O1a;builder(allRowData,value);if(manyBuilder){manyBuilder(allRowData,value[j5a]);}if(action === I7z && (!editData[name] || !field[X7z](value,editData[name][idSrc]))){builder(changedRowData,value);changed=e5a;if(manyBuilder){var c7z=N5a;c7z+=N2a;c7z+=a6a;c7z+=q8a;manyBuilder(changedRowData,value[c7z]);}}}});if(!$[s8d](allRowData)){allData[idSrc]=allRowData;}if(!$[r7z](changedRowData)){changedData[idSrc]=changedRowData;}});if(action === K7a || changedSubmit === H8d || changedSubmit === l7z && changed){submitParams[Z7a]=allData;}else if(changedSubmit === C7z && changed){submitParams[Z7a]=changedData;}else {var G7z=b8d;G7z+=K4v;G7z+=v7r;G7z+=I7r;var Z7z=j6r;Z7z+=f4v;Z7z+=i4v;Z7z+=a6a;var V7z=a8d;V7z+=i4v;V7z+=N2a;var S7z=K4v;S7z+=z8d;S7z+=u8d;var A7z=l5a;A7z+=a6a;A7z+=v6r;this[b3a][A7z]=O1a;if(opts[Q4r] === N8n && (hide === undefined || hide)){this[N7r](Y5a);}else if(typeof opts[S7z] === L5L.d4v){var n7z=n3a;n7z+=v8d;opts[n7z](this);}if(successCallback){var g7z=T1a;g7z+=u8a;g7z+=u8a;successCallback[g7z](this);}this[V7z](Y5a);this[Z7z](G7z);return;}}else if(action === D2n){var E7z=u1a;E7z+=f4a;$[E7z](editFields,function(idSrc,edit){var y7z=L5L.j4v;y7z+=L7a;y7z+=L5L.J4v;submitParams[Z7a][idSrc]=edit[y7z];});}this[m7z](N7z,action,submitParams);submitParamsLocal=$[k7z](e5a,{},submitParams);if(formatdata){formatdata(submitParams);}if(this[X1n](I8d,[submitParams,action]) === Y5a){var T7z=a3a;T7z+=U4v;T7z+=X8d;T7z+=N2a;this[T7z](Y5a);return;}var submitWire=this[b3a][q7z] || this[b3a][J7z]?this[c8d]:this[r8d];submitWire[P7z](this,submitParams,function(json,notGood,xhr){var j7z=D1n;j7z+=K4v;j7z+=i4v;that[l8d](json,notGood,submitParams,submitParamsLocal,that[b3a][j7z],editCount,hide,successCallback,errorCallback,xhr);},function(xhr,err,thrown){var Y7z=L5L.J4v;Y7z+=Y8a;Y7z+=n8a;Y7z+=i4v;that[C8d](xhr,err,thrown,errorCallback,submitParams,that[b3a][Y7z]);},submitParams);};Editor[P1a][r8d]=function(data,success,error,submitParams){var g8d="ividual";var V8d="ource";var S8d="_fnGetObjectData";var d7z=k2r;d7z+=N3a;d7z+=L5L.Y4v;var M7z=K4v;M7z+=F6n;M7z+=A8d;var t7z=L5L.Y4v;t7z+=D2a;t7z+=a6a;var F7z=S8d;F7z+=a0a;var e7z=l5a;e7z+=Y6n;e7z+=n3a;var that=this;var action=data[e7z];var out={data:[]};var idGet=DataTable[b0a][G7a][F7z](this[b3a][n8d]);var idSet=DataTable[t7z][M7z][N7a](this[b3a][n8d]);if(action !== d7z){var i7z=L5L.j4v;i7z+=L5L.J4v;i7z+=a6a;i7z+=L5L.J4v;var o7z=u1a;o7z+=f4a;var f7z=x4v;f7z+=i4v;f7z+=L5L.j4v;f7z+=g8d;var p7z=a3a;p7z+=Z7a;p7z+=G8a;p7z+=V8d;var W7z=X8a;W7z+=b1r;W7z+=j3a;var B7z=K0n;B7z+=D4v;B7z+=P6r;var R7z=B8n;R7z+=L5L.Y4v;var originalData=this[b3a][R7z] === F4n?this[B7z](e6r,this[W7z]()):this[p7z](f7z,this[b3r]());$[o7z](data[i7z],function(key,vals){var G8d="_fnExt";var y8d="eExt";var E8d="dataTabl";var D7z=P4n;L5L.g5L();D7z+=Z8d;var h7z=G8d;h7z+=J4a;var x7z=E8d;x7z+=y8d;var w7z=K3a;w7z+=i4v;var toSave;var extender=$[w7z][x7z][G7a][h7z];if(action === F8r){var rowData=originalData[key][Z7a];toSave=extender({},rowData,e5a);toSave=extender(toSave,vals,e5a);}else {toSave=extender({},vals,e5a);}var overrideId=idGet(toSave);if(action === D7z && overrideId === undefined){idSet(toSave,+new Date() + U9a + key);}else {idSet(toSave,overrideId);}out[Z7a][C5a](toSave);});}success(out);};Editor[U7z][l8d]=function(json,notGood,submitParams,submitParamsLocal,action,editCount,hide,successCallback,errorCallback,xhr){var K8d="ubmitSucc";var l3d="ids";var N8d="oces";var M8d="oin";var k8d="fieldE";var e8d="succes";var I3d="mmit";var t8d="br";var d8d="ldErrors";var s3d='prep';var c3d="even";var H3d="etD";var P8d="tOpts";var r3d='preRemove';var Y8d="Un";var J8d="_legacyA";var C3d="editCount";var q8d="Subm";var v3d="tEdi";var m8d="submitComplet";var j8d='receive';var L3d="taSo";var z3d="Crea";var X3d="postRe";var u3d='preCreate';var Q3d="urc";var S3d="nComplete";var O3d="_da";var F8d="sful";var a3d="post";var L4z=m8d;L4z+=L5L.Y4v;var O4z=a3a;O4z+=U4v;O4z+=N8d;O4z+=b8a;var z1z=u8a;z1z+=f4n;z1z+=q8a;var a1z=L5L.Y4v;a1z+=m0a;a1z+=D4v;var b1z=k8d;b1z+=m0a;b1z+=D4v;b1z+=b3a;var s1z=p6r;s1z+=K4v;s1z+=D4v;var Q1z=T8d;Q1z+=a6a;Q1z+=q8d;Q1z+=H9a;var L1z=J8d;L1z+=W0n;L1z+=D2a;var O1z=L5L.P4v;O1z+=K4v;O1z+=b1r;O1z+=j3a;var K7z=P2a;K7z+=x4v;K7z+=P8d;var that=this;var setData;var fields=this[b3a][k0n];var opts=this[b3a][K7z];var modifier=this[b3a][O1z];this[L1z](j8d,action,json);this[X1n](Q1z,[json,submitParams,action,xhr]);if(!json[s1z]){var H1z=p6r;H1z+=A9a;json[H1z]=L5L.M4v;}if(!json[b1z]){json[B9r]=[];}if(notGood || json[a1z] || json[B9r][z1z]){var Z1z=T6n;Z1z+=Y8d;Z1z+=e8d;Z1z+=F8d;var V1z=u0a;V1z+=t8d;V1z+=C0a;var g1z=J5a;g1z+=M8d;var n1z=L5L.Y4v;n1z+=D4v;n1z+=w2a;n1z+=D4v;var v1z=q6n;v1z+=L5L.Y4v;v1z+=d8d;var u1z=p6r;u1z+=A9a;var globalError=[];if(json[u1z]){globalError[C5a](json[z4a]);}$[y1a](json[v1z],function(i,err){var B8d="yed";var o8d="ldError";var R8d="spla";var U8d=': ';var W8d="nkno";var h8d="onFieldError";var x8d="position";var w8d="dyC";L5L.g5L();var p8d="wn field: ";var D8d="nFieldEr";var X1z=L5L.j4v;X1z+=x4v;X1z+=R8d;X1z+=B8d;var field=fields[err[j2r]];if(!field){var I1z=V5a;I1z+=W8d;I1z+=p8d;throw new Error(I1z + err[j2r]);}else if(field[X1z]()){field[z4a](err[U0r] || R6a);if(i === R1v){var r1z=f8d;r1z+=b3a;var c1z=n3a;c1z+=e0n;c1z+=o8d;if(opts[c1z] === r1z){var A1z=K3a;A1z+=i8d;var C1z=s2n;C1z+=w8d;C1z+=n3a;C1z+=P5n;var l1z=L5L.j4v;l1z+=K4v;l1z+=L5L.P4v;that[e3n]($(that[l1z][C1z],that[b3a][T7a]),{scrollTop:$(field[V0n]())[x8d]()[N5n]},V4v);field[A1z]();}else if(typeof opts[h8d] === L5L.d4v){var S1z=K4v;S1z+=D8d;S1z+=w2a;S1z+=D4v;opts[S1z](that,err);}}}else {globalError[C5a](field[j2r]() + U8d + (err[U0r] || R6a));}});this[n1z](globalError[g1z](V1z));this[X1n](Z1z,[json]);if(errorCallback){errorCallback[z4n](that,json);}}else {var K1z=b3a;K1z+=K8d;K1z+=G2r;var G1z=L5L.F4v;G1z+=u3a;G1z+=L7a;G1z+=L5L.Y4v;var store={};if(json[Z7a] && (action === G1z || action === T3a)){var M1z=L5L.j4v;M1z+=L7a;M1z+=L5L.J4v;var t1z=R1a;t1z+=L5L.P4v;t1z+=B1n;var m1z=N5a;m1z+=N2a;m1z+=U4n;var y1z=L5L.j4v;y1z+=L5L.J4v;y1z+=E9n;var E1z=O3d;E1z+=L3d;E1z+=Q3d;E1z+=L5L.Y4v;this[E1z](s3d,action,modifier,submitParamsLocal,json,store);for(var i=R1v;i < json[y1z][m1z];i++){var k1z=b3a;k1z+=H3d;k1z+=Q7a;var N1z=E3r;N1z+=V7n;N1z+=a6a;setData=json[Z7a][i];var id=this[P0n](b3d,setData);this[N1z](k1z,[json,setData,action]);if(action === M4n){var P1z=a3d;P1z+=z3d;P1z+=l6a;var J1z=j6r;J1z+=f4v;J1z+=i4v;J1z+=a6a;var q1z=P4n;q1z+=Z8d;var T1z=E3r;T1z+=L5L.Y4v;T1z+=B1a;this[T1z](u3d,[json,setData,id]);this[P0n](q1z,fields,setData,store);this[J1z]([K7a,P1z],[json,setData,id]);}else if(action === T3a){var F1z=T8d;F1z+=v3d;F1z+=a6a;var e1z=P2a;e1z+=x4v;e1z+=a6a;var Y1z=d9r;Y1z+=z8a;Y1z+=U2a;Y1z+=a6a;var j1z=a3a;j1z+=L5L.Y4v;j1z+=h9r;j1z+=a6a;this[j1z](Y1z,[json,setData,id]);this[P0n](F8r,modifier,fields,setData,store);this[X1n]([e1z,F1z],[json,setData,id]);}}this[P0n](t1z,action,modifier,json[M1z],store);}else if(action === D2n){var i1z=R1a;i1z+=I3d;var o1z=x4v;o1z+=L5L.j4v;o1z+=b3a;var f1z=X3d;f1z+=m0r;var p1z=u3a;p1z+=m0r;var W1z=a3a;W1z+=c3d;W1z+=a6a;var B1z=k2r;B1z+=f4v;var R1z=q6r;R1z+=K6r;var d1z=a3a;d1z+=L5L.Y4v;d1z+=h9r;d1z+=a6a;this[P0n](s3d,action,modifier,submitParamsLocal,json,store);this[d1z](r3d,[json,this[l3d]()]);this[R1z](B1z,modifier,fields,store);this[W1z]([p1z,f1z],[json,this[o1z]()]);this[P0n](i1z,action,modifier,json[Z7a],store);}if(editCount === this[b3a][C3d]){var x1z=L5L.F4v;x1z+=u8a;x1z+=t3a;x1z+=L5L.Y4v;var w1z=L5L.J4v;w1z+=s1r;w1z+=n3a;var action=this[b3a][w1z];this[b3a][t4n]=O1a;if(opts[Q4r] === x1z && (hide === undefined || hide)){var D1z=Z9a;D1z+=a6a;D1z+=L5L.J4v;var h1z=A3d;h1z+=u8a;h1z+=K4v;h1z+=Q9a;this[h1z](json[D1z]?e5a:Y5a,action);}else if(typeof opts[Q4r] === L5L.d4v){var U1z=K4v;U1z+=S3d;opts[U1z](this);}}if(successCallback){successCallback[z4n](that,json);}this[X1n](K1z,[json,setData,action]);}this[O4z](Y5a);this[X1n](L4z,[json,setData,action]);};Editor[P1a][C8d]=function(xhr,err,thrown,errorCallback,submitParams,action){var G3d="system";var Z3d="ev";var g3d="Com";var V3d="mitError";var z4z=b3a;z4z+=n3d;z4z+=g3d;z4z+=u8d;var a4z=s9a;a4z+=V3d;var b4z=a3a;b4z+=h4n;b4z+=i4v;b4z+=a6a;L5L.g5L();var H4z=L5L.Y4v;H4z+=n7n;var s4z=T8d;s4z+=a6a;s4z+=G8a;s4z+=n3d;var Q4z=a3a;Q4z+=Z3d;Q4z+=k3a;this[Q4z](s4z,[O1a,submitParams,action,xhr]);this[z4a](this[S2r][H4z][G3d]);this[K3r](Y5a);if(errorCallback){errorCallback[z4n](this,xhr,err,thrown);}this[b4z]([a4z,z4z],[xhr,err,thrown,submitParams]);};Editor[P1a][I8r]=function(fn){var N3d="oFeatures";var k3d="itComplete";var E3d="cessin";var y3d="bServerSi";var A4z=X1a;A4z+=z3a;A4z+=w0a;A4z+=B8a;var C4z=L5L.j4v;C4z+=P9n;C4z+=b9n;C4z+=B8a;var X4z=m3a;L5L.g5L();X4z+=E3d;X4z+=N2a;var u4z=F6n;u4z+=z3a;u4z+=x4v;var that=this;var dt=this[b3a][A0n]?new $[k4a][i5r][u4z](this[b3a][A0n]):O1a;var ssp=Y5a;if(dt){var I4z=y3d;I4z+=V8a;var v4z=l8n;v4z+=Y6n;v4z+=m3d;ssp=dt[v4z]()[R1v][N3d][I4z];}if(this[b3a][X4z]){var r4z=b3a;r4z+=s4r;r4z+=k3d;var c4z=n3a;c4z+=L5L.Y4v;this[c4z](r4z,function(){if(ssp){var l4z=L5L.j4v;l4z+=D4v;l4z+=L5L.J4v;l4z+=r2a;dt[c3r](l4z,fn);}else {setTimeout(function(){fn();},x1v);}});return e5a;}else if(this[C4z]() === d8r || this[A4z]() === f7n){var g4z=w6a;g4z+=u8a;g4z+=B3a;var S4z=K4v;S4z+=i4v;S4z+=L5L.Y4v;this[S4z](N8n,function(){var T3d='submitComplete';L5L.r5L();if(!that[b3a][w4a]){setTimeout(function(){L5L.r5L();if(that[b3a]){fn();}},x1v);}else {that[c3r](T3d,function(e,json){if(ssp && json){var n4z=L5L.j4v;n4z+=D4v;n4z+=L5L.J4v;n4z+=r2a;dt[c3r](n4z,fn);}else {setTimeout(function(){if(that[b3a]){fn();}},x1v);}});}})[g4z]();return e5a;}return Y5a;};Editor[P1a][q3d]=function(name,arr){var V4z=u8a;V4z+=L5L.Y4v;V4z+=S1n;for(var i=R1v,ien=arr[V4z];i < ien;i++){if(name == arr[i]){return i;}}return -B1v;};Editor[Z4z]={"table":O1a,"ajaxUrl":O1a,"fields":[],"display":J3d,"ajax":O1a,"idSrc":P3d,"events":{},"i18n":{"create":{"button":G4z,"title":j3d,"submit":Y3d},"edit":{"button":e3d,"title":F3d,"submit":t3d},"remove":{"button":E4z,"title":y4z,"submit":M3d,"confirm":{"_":d3d,"1":R3d}},"error":{"system":m4z},multi:{title:B3d,info:W3d,restore:N4z,noMulti:k4z},datetime:{previous:p3d,next:f3d,months:[o3d,i3d,w3d,x3d,T4z,h3d,q4z,D3d,J4z,P4z,U3d,j4z],weekdays:[K3d,O2d,L2d,Q2d,Y4z,s2d,e4z],amPm:[H2d,b2d],hours:F4z,minutes:t4z,seconds:M4z,unknown:J3r}},formOptions:{bubble:$[I7a]({},Editor[d4z][R4z],{title:Y5a,message:Y5a,buttons:B4z,submit:a2d}),inline:$[I7a]({},Editor[E8n][W4z],{buttons:Y5a,submit:p4z}),main:$[I7a]({},Editor[f4z][m8n])},legacyAjax:Y5a,actionName:z2d};(function(){var w2d="tDat";var u2d="taT";var U2d="oA";var x2d="aFn";var v2d="So";var t9d="[dat";var A9d="cancelled";var I2d="urce";var Y9d='keyless';var G9d="rowIds";var p2d="attach";var k6D=L5L.j4v;k6D+=L5L.J4v;k6D+=u2d;k6D+=I2r;var o4z=Z7a;o4z+=v2d;o4z+=I2d;o4z+=b3a;var __dataSources=Editor[o4z]={};var __dtIsSsp=function(dt,editor){var C2d="oF";var l2d="Side";var A2d="eat";var c2d="wTy";var X2d="dra";var r2d="bServer";L5L.r5L();var S2d="ures";var x4z=X2d;x4z+=c2d;x4z+=z3a;x4z+=L5L.Y4v;var w4z=r2d;w4z+=l2d;var i4z=C2d;i4z+=A2d;i4z+=S2d;return dt[l7a]()[R1v][i4z][w4z] && editor[b3a][o0n][x4z] !== h1a;};var __dtApi=function(table){var n2d="DataTa";L5L.g5L();var h4z=n2d;h4z+=D1a;return $(table)[h4z]();};var __dtHighlight=function(node){node=$(node);setTimeout(function(){var V2d="dCla";L5L.g5L();var Z2d='highlight';var D4z=g2d;D4z+=V2d;D4z+=b3a;D4z+=b3a;node[D4z](Z2d);setTimeout(function(){var E2d='noHighlight';var G2d="addClas";var U4z=G2d;U4z+=b3a;node[U4z](E2d)[v4a](Z2d);L5L.g5L();setTimeout(function(){var y2d="oveC";var K4z=D4v;K4z+=F1n;K4z+=y2d;L5L.r5L();K4z+=T0r;node[K4z](E2d);},Z4v);},V4v);},L4v);};var __dtRowSelector=function(out,dt,identifier,fields,idFn){var L6D=L5L.Y4v;L6D+=L5L.J4v;L6D+=L5L.F4v;L6D+=q8a;var O6D=b7r;O6D+=m2d;O6D+=b3a;dt[X6r](identifier)[O6D]()[L6D](function(idx){var k2d="d row identifier";var N2d="Unable to fin";var K1v=14;var T2d='row';var Q6D=D4v;Q6D+=K4v;Q6D+=r2a;var row=dt[Q6D](idx);var data=row[Z7a]();var idSrc=idFn(data);L5L.r5L();if(idSrc === undefined){var H6D=N2d;H6D+=k2d;var s6D=j3a;s6D+=h5a;Editor[s6D](H6D,K1v);}out[idSrc]={idSrc:idSrc,data:data,node:row[V0n](),fields:fields,type:T2d};});};var __dtFieldsFromIdx=function(dt,fields,idx){var Y2d="editField";var e2d='Unable to automatically determine field from source. Please specify the field name.';var J2d="mptyOb";var q2d="isE";var j2d="aoColumns";var X6D=q2d;X6D+=J2d;X6D+=J5a;X6D+=P2d;var z6D=L5L.P4v;z6D+=r6a;z6D+=Q7a;var a6D=T3a;a6D+=F5a;var b6D=Q9a;b6D+=a6a;b6D+=Y6n;b6D+=m3d;var field;var col=dt[b6D]()[R1v][j2d][idx];var dataSrc=col[Y2d] !== undefined?col[a6D]:col[z6D];var resolvedFields={};var run=function(field,dataSrc){L5L.g5L();if(field[j2r]() === dataSrc){var u6D=o4a;u6D+=L5L.Y4v;resolvedFields[field[u6D]()]=field;}};$[y1a](fields,function(name,fieldInst){var v6D=u1r;v6D+=C2n;v6D+=B8a;if($[v6D](dataSrc)){var I6D=N5a;I6D+=k5a;for(var i=R1v;i < dataSrc[I6D];i++){run(fieldInst,dataSrc[i]);}}else {run(fieldInst,dataSrc);}});if($[X6D](resolvedFields)){Editor[z4a](e2d,h1v);}return resolvedFields;};var __dtCellSelector=function(out,dt,identifier,allFields,idFn,forceFields){var c6D=L2a;L5L.g5L();c6D+=u8a;c6D+=b3a;dt[c6D](identifier)[F2d]()[y1a](function(idx){var B2d="lu";var W2d="displayFi";var t2d="ayFi";var M2d="xedNode";L5L.g5L();var R2d="deName";var f2d="fixedNode";var y6D=L5L.Y4v;y6D+=D2a;y6D+=a6a;y6D+=J4a;var E6D=g0r;E6D+=t2d;E6D+=x6a;E6D+=u8n;var G6D=i4v;G6D+=p7r;G6D+=L5L.Y4v;var Z6D=K3a;Z6D+=x4v;Z6D+=M2d;var V6D=d2d;V6D+=D6r;var g6D=L5L.J4v;g6D+=a6a;g6D+=a6a;g6D+=D6r;var S6D=A2a;S6D+=R2d;var A6D=K4v;A6D+=w6a;A6D+=D3r;var C6D=R1a;C6D+=B2d;C6D+=L5L.P4v;C6D+=i4v;var l6D=D4v;l6D+=K4v;l6D+=r2a;var r6D=L2a;r6D+=u8a;var cell=dt[r6D](idx);var row=dt[H2a](idx[l6D]);var data=row[Z7a]();var idSrc=idFn(data);var fields=forceFields || __dtFieldsFromIdx(dt,allFields,idx[C6D]);var isNode=typeof identifier === A6D && identifier[S6D] || identifier instanceof $;var prevDisplayFields,prevAttach;if(out[idSrc]){var n6D=W2d;n6D+=C4n;prevAttach=out[idSrc][p2d];prevDisplayFields=out[idSrc][n6D];}__dtRowSelector(out,dt,idx[H2a],allFields,idFn);out[idSrc][g6D]=prevAttach || [];out[idSrc][V6D][C5a](isNode?$(identifier)[N9a](R1v):cell[f2d]?cell[Z6D]():cell[G6D]());out[idSrc][E6D]=prevDisplayFields || ({});$[y6D](out[idSrc][b8r],fields);});};var __dtColumnSelector=function(out,dt,identifier,fields,idFn){var N6D=L5L.Y4v;N6D+=L5L.J4v;N6D+=L5L.F4v;N6D+=q8a;var m6D=L2a;m6D+=u8a;m6D+=b3a;dt[m6D](O1a,identifier)[F2d]()[N6D](function(idx){__dtCellSelector(out,dt,idx,fields,idFn);});};L5L.g5L();var __dtjqId=function(id){var o2d='\\$1';return typeof id === A4n?i6r + id[s6n](/(:|\.|\[|\]|,)/g,o2d):i6r + id;};__dataSources[k6D]={id:function(data){var i2d="nGetObjec";var J6D=E3a;J6D+=i2d;J6D+=w2d;J6D+=x2d;var q6D=K4v;q6D+=F6n;q6D+=z3a;q6D+=x4v;var T6D=L5L.Y4v;T6D+=D2a;T6D+=a6a;var idFn=DataTable[T6D][q6D][J6D](this[b3a][n8d]);return idFn(data);},individual:function(identifier,fieldNames){var h2d="dS";var D2d="GetObjectDataFn";var F6D=a6a;F6D+=I2r;var e6D=x4v;e6D+=h2d;e6D+=R3r;var Y6D=B6d;Y6D+=D2d;var j6D=U2d;j6D+=A8d;var P6D=L5L.Y4v;P6D+=H6a;var idFn=DataTable[P6D][j6D][Y6D](this[b3a][e6D]);var dt=__dtApi(this[b3a][F6D]);var fields=this[b3a][k0n];var out={};var forceFields;var responsiveNode;if(fieldNames){if(!$[X6n](fieldNames)){fieldNames=[fieldNames];}forceFields={};$[y1a](fieldNames,function(i,name){forceFields[name]=fields[name];});}__dtCellSelector(out,dt,identifier,fields,idFn,forceFields);return out;},fields:function(identifier){var O9d="Objec";var s9d="colu";var b9d="umns";var K2d="isPlain";var H9d="mns";var R6D=K2d;R6D+=O9d;R6D+=a6a;var d6D=a6a;d6D+=g0n;d6D+=u8a;d6D+=L5L.Y4v;var M6D=U2d;M6D+=A8d;var t6D=L5L.Y4v;t6D+=H6a;var idFn=DataTable[t6D][M6D][y7a](this[b3a][n8d]);var dt=__dtApi(this[b3a][d6D]);var fields=this[b3a][k0n];var out={};if($[R6D](identifier) && (identifier[X6r] !== undefined || identifier[L9d] !== undefined || identifier[Q9d] !== undefined)){var B6D=s9d;B6D+=H9d;if(identifier[X6r] !== undefined){__dtRowSelector(out,dt,identifier[X6r],fields,idFn);}if(identifier[B6D] !== undefined){var W6D=L5L.F4v;W6D+=r8n;W6D+=b9d;__dtColumnSelector(out,dt,identifier[W6D],fields,idFn);}if(identifier[Q9d] !== undefined){var p6D=L5L.F4v;p6D+=L5L.Y4v;p6D+=q1a;p6D+=b3a;__dtCellSelector(out,dt,identifier[p6D],fields,idFn);}}else {__dtRowSelector(out,dt,identifier,fields,idFn);}return out;},create:function(fields,data){var f6D=a6a;f6D+=I2r;var dt=__dtApi(this[b3a][f6D]);if(!__dtIsSsp(dt,this)){var o6D=g2d;o6D+=L5L.j4v;var row=dt[H2a][o6D](data);__dtHighlight(row[V0n]());}},edit:function(identifier,fields,data,store){var X9d="ice";var c9d="wId";var r9d="dataTableExt";var C9d="dd";var l9d="_fnExtend";var z9d="drawType";var a9d="non";var w6D=a9d;w6D+=L5L.Y4v;var i6D=E9n;i6D+=D1a;var that=this;var dt=__dtApi(this[b3a][i6D]);if(!__dtIsSsp(dt,this) || this[b3a][o0n][z9d] === w6D){var u8D=i4v;u8D+=K4v;u8D+=L5L.j4v;u8D+=L5L.Y4v;var h6D=L5L.J4v;h6D+=i4v;h6D+=B8a;var x6D=x4v;x6D+=L5L.j4v;var rowId=__dataSources[i5r][x6D][z4n](this,data);var row;try{row=dt[H2a](__dtjqId(rowId));}catch(e){row=dt;}if(!row[h6D]()){var D6D=w2a;D6D+=r2a;row=dt[D6D](function(rowIdx,rowData,rowNode){L5L.r5L();var u9d="aT";var O8D=L5L.F4v;O8D+=L5L.J4v;O8D+=u8a;O8D+=u8a;var K6D=x4v;K6D+=L5L.j4v;var U6D=L5L.j4v;U6D+=L7a;U6D+=u9d;U6D+=I2r;return rowId == __dataSources[U6D][K6D][O8D](that,rowData);});}if(row[v9d]()){var a8D=b3a;a8D+=I9d;a8D+=X9d;var b8D=w2a;b8D+=r2a;b8D+=N6n;var H8D=w2a;H8D+=c9d;H8D+=b3a;var s8D=x4v;s8D+=i4v;s8D+=p4a;s8D+=B8a;var Q8D=L5L.j4v;Q8D+=Q7a;var L8D=K4v;L8D+=X2r;var extender=$[k4a][r9d][L8D][l9d];var toSave=extender({},row[Q8D](),e5a);toSave=extender(toSave,data,e5a);row[Z7a](toSave);var idx=$[s8D](rowId,store[H8D]);store[b8D][a8D](idx,B1v);}else {var z8D=L5L.J4v;z8D+=C9d;row=dt[H2a][z8D](data);}__dtHighlight(row[u8D]());}},remove:function(identifier,fields,store){var n9d="every";var v8D=E9n;v8D+=w6a;v8D+=S6a;var that=this;var dt=__dtApi(this[b3a][v8D]);var cancelled=store[A9d];if(cancelled[j5a] === R1v){var I8D=w2a;I8D+=S9d;dt[I8D](identifier)[D2n]();}else {var indexes=[];dt[X6r](identifier)[n9d](function(){var V9d="Tab";var Z9d="ush";var c8D=g9d;c8D+=u8a;var X8D=Z7a;X8D+=V9d;X8D+=S6a;var id=__dataSources[X8D][A7a][c8D](that,this[Z7a]());if($[Z4n](id,cancelled) === -B1v){var l8D=x4v;l8D+=i4v;l8D+=w1n;var r8D=z3a;r8D+=Z9d;indexes[r8D](this[l8D]());}});dt[X6r](indexes)[D2n]();}},prep:function(action,identifier,submit,json,store){var m9d="canc";var C8D=P2a;C8D+=x4v;C8D+=a6a;if(action === C8D){var A8D=L5L.P4v;A8D+=L5L.J4v;A8D+=z3a;var cancelled=json[A9d] || [];store[G9d]=$[A8D](submit[Z7a],function(val,key){var E9d="sEmp";var y9d="tyObjec";var S8D=x4v;S8D+=E9d;S8D+=y9d;S8D+=a6a;return !$[S8D](submit[Z7a][key]) && $[Z4n](key,cancelled) === -B1v?key:undefined;});}else if(action === n2r){var n8D=m9d;n8D+=x6a;n8D+=u8a;n8D+=P2a;store[n8D]=json[A9d] || [];}},commit:function(action,identifier,data,store){var T9d="oFe";var P9d="ove";L5L.g5L();var J9d="bServerSide";var q9d="atures";var N9d="drawT";var j9d="raw";var q8D=N9d;q8D+=B8a;q8D+=z3a;q8D+=L5L.Y4v;var V8D=S6a;V8D+=k9d;V8D+=q8a;var g8D=L5L.Y4v;g8D+=L5L.j4v;g8D+=x4v;g8D+=a6a;var that=this;var dt=__dtApi(this[b3a][A0n]);if(!__dtIsSsp(dt,this) && action === g8D && store[G9d][V8D]){var G8D=S6a;G8D+=S1n;var ids=store[G9d];var row;var compare=function(id){L5L.g5L();return function(rowIdx,rowData,rowNode){var Z8D=x4v;L5L.g5L();Z8D+=L5L.j4v;return id == __dataSources[i5r][Z8D][z4n](that,rowData);};};for(var i=R1v,ien=ids[G8D];i < ien;i++){var k8D=T9d;k8D+=q9d;var N8D=Q9a;N8D+=A1n;N8D+=P5r;var m8D=Z3n;m8D+=B8a;var y8D=Z3n;y8D+=B8a;try{var E8D=D4v;E8D+=K4v;E8D+=r2a;row=dt[E8D](__dtjqId(ids[i]));}catch(e){row=dt;}if(!row[y8D]()){row=dt[H2a](compare(ids[i]));}if(row[m8D]() && !dt[N8D]()[R1v][k8D][J9d]){var T8D=u3a;T8D+=L5L.P4v;T8D+=P9d;row[T8D]();}}}var drawType=this[b3a][o0n][q8D];if(drawType !== h1a){var J8D=L5L.j4v;J8D+=j9d;dt[J8D](drawType);}}};function __html_id(identifier){var e9d='[data-editor-id="';var F9d='Could not find an element with `data-editor-id` or `id` of: ';L5L.g5L();var context=document;if(identifier !== Y9d){var P8D=v5a;P8D+=I5a;context=$(e9d + identifier + P8D);if(context[j5a] === R1v){var j8D=L6n;j8D+=K1n;context=typeof identifier === j8D?$(__dtjqId(identifier)):$(identifier);}if(context[j5a] === R1v){throw F9d + identifier;}}return context;}function __html_el(identifier,name){var M9d="a-editor-field=\"";var e8D=v5a;e8D+=I5a;var Y8D=t9d;Y8D+=M9d;var context=__html_id(identifier);return $(Y8D + name + e8D,context);}function __html_els(identifier,names){var F8D=S6a;F8D+=i4v;F8D+=k5a;var out=$();for(var i=R1v,ien=names[F8D];i < ien;i++){out=out[n2n](__html_el(identifier,names[i]));}L5L.g5L();return out;}function __html_get(identifier,dataSrc){var W9d="[data-edit";var p9d="-value]";var d9d="data-e";var R9d="ditor-value";var d8D=d9d;d8D+=R9d;var M8D=u8a;M8D+=B9d;M8D+=U4n;var t8D=W9d;t8D+=A9a;t8D+=p9d;var el=__html_el(identifier,dataSrc);return el[f9d](t8D)[M8D]?el[o9d](d8D):el[j4a]();}function __html_set(identifier,fields,data){var R8D=u1a;R8D+=f4a;$[R8D](fields,function(name,field){var i9d="[d";var w9d="a-editor-value]";var h9d="ta-editor";var x9d="dataSr";var U9d="value";var val=field[E7a](data);if(val !== undefined){var p8D=p2r;p8D+=q8a;var W8D=i9d;W8D+=L7a;W8D+=w9d;var B8D=x9d;B8D+=L5L.F4v;var el=__html_el(identifier,field[B8D]());if(el[f9d](W8D)[p8D]){var f8D=Z9a;f8D+=h9d;f8D+=D9d;f8D+=U9d;el[o9d](f8D,val);}else {var x8D=q8a;x8D+=a6a;x8D+=B6n;var o8D=L8r;o8D+=q8a;el[o8D](function(){var K9d="ldNo";var Q5d="firstChild";var L5d="hild";var O5d="moveC";var i8D=o2n;i8D+=K9d;i8D+=V8a;L5L.r5L();i8D+=b3a;while(this[i8D][j5a]){var w8D=u3a;w8D+=O5d;w8D+=L5d;this[w8D](this[Q5d]);}})[x8D](val);}}});}__dataSources[j4a]={id:function(data){var H5d="oAp";var s5d="_fnGetObjec";var D8D=s5d;D8D+=w2d;D8D+=x2d;var h8D=H5d;h8D+=x4v;var idFn=DataTable[b0a][h8D][D8D](this[b3a][n8d]);return idFn(data);},initField:function(cfg){var a5d="data-edi";var b5d="[";var z5d="tor-label";var K8D=O8n;K8D+=U4n;var U8D=b5d;U8D+=a5d;U8D+=z5d;U8D+=M7n;var label=$(U8D + (cfg[Z7a] || cfg[j2r]) + K7r);if(!cfg[P7a] && label[K8D]){var O3D=R6n;O3D+=L5L.P4v;O3D+=u8a;cfg[P7a]=label[O3D]();}},individual:function(identifier,fieldNames){var l5d="ddBack";var r5d="dBac";var A5d='andSelf';var g5d="yl";var C5d='data-editor-field';var Z5d=" data source";var X5d="a-edi";var V5d="Cannot automatically determine field name f";var u5d="tm";var c5d="tor-id";var I3D=q8a;I3D+=u5d;I3D+=u8a;var u3D=N5a;u3D+=v8n;u3D+=q8a;var z3D=u1r;L5L.r5L();z3D+=U6d;var attachEl;if(identifier instanceof $ || identifier[v5d]){var b3D=z0r;b3D+=I5d;b3D+=L5L.j4v;var H3D=d6d;H3D+=L5L.J4v;var s3D=t9d;s3D+=X5d;s3D+=c5d;s3D+=I5a;var Q3D=g2d;Q3D+=r5d;Q3D+=o6n;var L3D=L5L.J4v;L3D+=l5d;attachEl=identifier;if(!fieldNames){fieldNames=[$(identifier)[o9d](C5d)];}var back=$[k4a][L3D]?Q3D:A5d;identifier=$(identifier)[S5d](s3D)[back]()[H3D](b3D);}if(!identifier){var a3D=n5d;a3D+=g5d;a3D+=H8a;a3D+=b3a;identifier=a3D;}if(fieldNames && !$[z3D](fieldNames)){fieldNames=[fieldNames];}if(!fieldNames || fieldNames[u3D] === R1v){var v3D=V5d;v3D+=w2a;v3D+=L5L.P4v;v3D+=Z5d;throw v3D;}var out=__dataSources[I3D][k0n][z4n](this,identifier);var fields=this[b3a][k0n];var forceFields={};$[y1a](fieldNames,function(i,name){L5L.r5L();forceFields[name]=fields[name];});$[y1a](out,function(id,set){var E5d='cell';var G5d="ayFie";var c3D=T9n;c3D+=u8a;c3D+=G5d;c3D+=F0n;var X3D=a6a;X3D+=f3a;set[X3D]=E5d;set[p2d]=attachEl?$(attachEl):__html_els(identifier,fieldNames)[y5d]();set[k0n]=fields;set[c3D]=forceFields;});return out;},fields:function(identifier){var m5d="sAr";var A3D=w2a;A3D+=r2a;var l3D=K3a;l3D+=x4v;l3D+=x6a;l3D+=u8n;var r3D=x4v;r3D+=m5d;r3D+=U6d;var out={};var self=__dataSources[j4a];if($[r3D](identifier)){for(var i=R1v,ien=identifier[j5a];i < ien;i++){var res=self[k0n][z4n](this,identifier[i]);out[identifier[i]]=res[identifier[i]];}return out;}var data={};var fields=this[b3a][l3D];if(!identifier){identifier=Y9d;}$[y1a](fields,function(name,field){var T5d="dataSrc";var k5d="lToD";var C3D=N5d;C3D+=k5d;L5L.g5L();C3D+=Q7a;var val=__html_get(identifier,field[T5d]());field[C3D](data,val === O1a?undefined:val);});out[identifier]={idSrc:identifier,data:data,node:document,fields:fields,type:A3D};return out;},create:function(fields,data){L5L.r5L();if(data){var n3D=x4v;n3D+=L5L.j4v;var S3D=q8a;S3D+=a6a;S3D+=L5L.P4v;S3D+=u8a;var id=__dataSources[S3D][n3D][z4n](this,data);try{var g3D=O8n;g3D+=U4n;if(__html_id(id)[g3D]){__html_set(id,fields,data);}}catch(e){;}}},edit:function(identifier,fields,data){var id=__dataSources[j4a][A7a][z4n](this,data) || Y9d;__html_set(id,fields,data);},remove:function(identifier,fields){var V3D=k2r;V3D+=N3a;V3D+=L5L.Y4v;L5L.g5L();__html_id(identifier)[V3D]();}};})();L5L.g5L();Editor[Z3D]={"wrapper":G3D,"processing":{"indicator":q5d,"active":E3D},"header":{"wrapper":y3D,"content":m3D},"body":{"wrapper":N3D,"content":J5d},"footer":{"wrapper":P5d,"content":j5d},"form":{"wrapper":Y5d,"content":e5d,"tag":L5L.M4v,"info":F5d,"error":t5d,"buttons":k3D,"button":M5d,"buttonInternal":T3D},"field":{"wrapper":d5d,"typePrefix":R5d,"namePrefix":B5d,"label":q3D,"input":J3D,"inputControl":P3D,"error":W5d,"msg-label":p5d,"msg-error":j3D,"msg-message":f5d,"msg-info":Y3D,"multiValue":o5d,"multiInfo":e3D,"multiRestore":i5d,"multiNoEdit":w5d,"disabled":f1a,"processing":F3D},"actions":{"create":x5d,"edit":h5d,"remove":D5d},"inline":{"wrapper":U5d,"liner":K5d,"buttons":t3D},"bubble":{"wrapper":O0d,"liner":M3D,"table":L0d,"close":d3D,"pointer":R3D,"bg":Q0d}};(function(){var X0d="bleTools";var W0d='buttons-edit';var I0d="ons-cre";var x0d='buttons-remove';L5L.r5L();var c0d="select_sin";var z0d="ditSin";var Z0d="editor_remove";var g0d="fnGetSelectedIndexes";var s0d="selec";var u0d="gle";var a0d="ngle";var V0d="formButtons";var Q7d="editSingle";var v0d="butt";var H0d="tedSingle";var n0d="editor_edit";var J0d="18n";var s7d="removeSingle";var b0d="edSi";var r0d="editor_create";var M0d="formTitle";var V9D=s0d;V9D+=H0d;var g9D=L5L.Y4v;g9D+=B2r;g9D+=y8a;var n9D=s0d;n9D+=a6a;n9D+=b0d;n9D+=a0d;var S9D=F2r;S9D+=y8a;var A9D=L5L.Y4v;A9D+=z0d;A9D+=u0d;var C9D=L5L.Y4v;C9D+=Y0n;var x2D=w2a;x2D+=S9d;var g2D=v0d;g2D+=I0d;g2D+=L5L.J4v;g2D+=l6a;var l2D=L5L.Y4v;l2D+=D2a;l2D+=l6a;l2D+=y8a;var r2D=b9a;r2D+=a6a;r2D+=h4v;r2D+=g8a;var c2D=L5L.Y4v;c2D+=D2a;c2D+=a6a;var B3D=a8a;B3D+=L5L.J4v;B3D+=X0d;if(DataTable[B3D]){var h3D=c0d;h3D+=u0d;var ttButtons=DataTable[s0r][H0r];var ttButtonBase={sButtonText:O1a,editor:O1a,formTitle:O1a};ttButtons[r0d]=$[I7a](e5a,ttButtons[l0d],ttButtonBase,{formButtons:[{label:O1a,fn:function(e){this[T6n]();}}],fnClick:function(button,config){var C0d="reate";var S0d="ttons";var A0d="rmBu";var x3D=Y6n;x3D+=a6a;x3D+=u8a;x3D+=L5L.Y4v;var w3D=L5L.F4v;w3D+=C0d;L5L.r5L();var f3D=w0a;f3D+=U1n;var p3D=X7n;p3D+=A0d;p3D+=S0d;var W3D=K6n;W3D+=W1n;var editor=config[z0r];var i18nCreate=editor[W3D][M4n];var buttons=config[p3D];if(!buttons[R1v][f3D]){var i3D=s9a;i3D+=B1n;var o3D=u8a;o3D+=L5L.J4v;o3D+=O0a;o3D+=u8a;buttons[R1v][o3D]=i18nCreate[i3D];}editor[w3D]({title:i18nCreate[x3D],buttons:buttons});}});ttButtons[n0d]=$[I7a](e5a,ttButtons[h3D],ttButtonBase,{formButtons:[{label:O1a,fn:function(e){var D3D=u6d;L5L.r5L();D3D+=a6a;this[D3D]();}}],fnClick:function(button,config){var K3D=L5L.Y4v;K3D+=Y0n;K3D+=K4v;K3D+=D4v;var U3D=p2r;U3D+=q8a;var selected=this[g0d]();if(selected[U3D] !== B1v){return;}var editor=config[K3D];var i18nEdit=editor[S2r][T3a];L5L.r5L();var buttons=config[V0d];if(!buttons[R1v][P7a]){buttons[R1v][P7a]=i18nEdit[T6n];}editor[T3a](selected[R1v],{title:i18nEdit[H1n],buttons:buttons});}});ttButtons[Z0d]=$[I7a](e5a,ttButtons[G0d],ttButtonBase,{question:O1a,formButtons:[{label:O1a,fn:function(e){var O2D=O4n;O2D+=x4v;O2D+=a6a;var that=this;L5L.g5L();this[O2D](function(json){var y0d="tance";var m0d="DataTable";var N0d="fnSelectNone";var E0d="fnGetI";var L2D=E0d;L2D+=i4v;L2D+=b3a;L5L.r5L();L2D+=y0d;var tt=$[k4a][i5r][s0r][L2D]($(that[b3a][A0n])[m0d]()[A0n]()[V0n]());tt[N0d]();});}}],fnClick:function(button,config){var q0d="mButtons";var T0d="nfirm";var k0d="firm";var X2D=a6a;X2D+=x4v;X2D+=A2r;X2D+=L5L.Y4v;var u2D=Q4a;u2D+=K3a;u2D+=x4v;u2D+=T4n;var z2D=Q4a;z2D+=k0d;var a2D=L5L.F4v;a2D+=K4v;a2D+=T0d;var b2D=Q5r;b2D+=q0d;var H2D=D4v;H2D+=L5L.Y4v;H2D+=X8a;H2D+=f4v;L5L.g5L();var s2D=x4v;s2D+=v7a;s2D+=T9a;s2D+=i4v;var Q2D=L5L.Y4v;Q2D+=L5L.j4v;Q2D+=H9a;Q2D+=A9a;var rows=this[g0d]();if(rows[j5a] === R1v){return;}var editor=config[Q2D];var i18nRemove=editor[s2D][H2D];var buttons=config[b2D];var question=typeof i18nRemove[a2D] === A4n?i18nRemove[g2r]:i18nRemove[g2r][rows[j5a]]?i18nRemove[z2D][rows[j5a]]:i18nRemove[u2D][a3a];if(!buttons[R1v][P7a]){var I2D=R1n;I2D+=w6a;I2D+=L5L.P4v;I2D+=H9a;var v2D=w0a;v2D+=w6a;v2D+=L5L.Y4v;v2D+=u8a;buttons[R1v][v2D]=i18nRemove[I2D];}editor[D2n](rows,{message:question[s6n](/%d/g,rows[j5a]),title:i18nRemove[X2D],buttons:buttons});}});}var _buttons=DataTable[c2D][r2D];$[l2D](_buttons,{create:{text:function(dt,node,config){var P0d="buttons.c";var n2D=b9a;n2D+=a9a;var S2D=x4v;S2D+=J0d;var A2D=P0d;A2D+=D4v;A2D+=Z8d;var C2D=K6n;C2D+=W1n;return dt[C2D](A2D,config[z0r][S2D][M4n][n2D]);},className:g2D,editor:O1a,formButtons:{text:function(editor){var Z2D=R1n;Z2D+=Y4r;Z2D+=x4v;Z2D+=a6a;var V2D=x4v;V2D+=j0d;L5L.g5L();V2D+=i4v;return editor[V2D][M4n][Z2D];},action:function(e){this[T6n]();}},formMessage:O1a,formTitle:O1a,action:function(e,dt,node,config){var Y0d="formMessag";var e0d="ormButto";var F0d="reO";var J2D=a6a;J2D+=x4v;J2D+=A2r;J2D+=L5L.Y4v;var q2D=L5L.F4v;q2D+=n9r;q2D+=l6a;var T2D=L5L.P4v;T2D+=L5L.Y4v;T2D+=E0a;var k2D=x4v;k2D+=v7a;k2D+=T9a;k2D+=i4v;var N2D=Y0d;N2D+=L5L.Y4v;var m2D=K3a;m2D+=e0d;m2D+=g8a;var E2D=z3a;E2D+=F0d;E2D+=L6a;E2D+=i4v;var G2D=K4v;G2D+=i4v;G2D+=L5L.Y4v;var that=this;var editor=config[z0r];this[w4a](e5a);editor[G2D](E2D,function(){var t0d="sin";var y2D=I0a;y2D+=t0d;y2D+=N2a;that[y2D](Y5a);})[M4n]({buttons:config[m2D],message:config[N2D] || editor[k2D][M4n][T2D],title:config[M0d] || editor[S2r][q2D][J2D]});}},edit:{extend:d0d,text:function(dt,node,config){var B0d="ns.";var F2D=b9a;F2D+=a9a;var e2D=L5L.Y4v;e2D+=U2a;e2D+=a6a;var Y2D=x4v;Y2D+=j0d;Y2D+=i4v;var j2D=w6a;j2D+=R0d;j2D+=B0d;j2D+=T3a;var P2D=x4v;L5L.r5L();P2D+=J0d;return dt[P2D](j2D,config[z0r][Y2D][e2D][F2D]);},className:W0d,editor:O1a,formButtons:{text:function(editor){return editor[S2r][T3a][T6n];},action:function(e){var t2D=b3a;t2D+=n3d;this[t2D]();}},formMessage:O1a,formTitle:O1a,action:function(e,dt,node,config){var o0d="ndexe";var p0d="rmMess";var f0d="reOp";var w2D=x4v;w2D+=J0d;var i2D=L5L.Y4v;i2D+=L5L.j4v;i2D+=x4v;i2D+=a6a;var o2D=x4v;o2D+=v7a;o2D+=T9a;o2D+=i4v;var f2D=X7n;f2D+=p0d;f2D+=x8r;var p2D=z3a;L5L.g5L();p2D+=f0d;p2D+=L5L.Y4v;p2D+=i4v;var W2D=K4v;W2D+=i4v;W2D+=L5L.Y4v;var B2D=x4v;B2D+=o0d;B2D+=b3a;var R2D=L0a;R2D+=L5L.j4v;R2D+=m2d;R2D+=b3a;var d2D=D4v;d2D+=h8n;d2D+=b3a;var M2D=L5L.Y4v;M2D+=U2a;M2D+=a6a;M2D+=A9a;var that=this;var editor=config[M2D];var rows=dt[d2D]({selected:e5a})[R2D]();var columns=dt[L9d]({selected:e5a})[B2D]();var cells=dt[Q9d]({selected:e5a})[F2d]();var items=columns[j5a] || cells[j5a]?{rows:rows,columns:columns,cells:cells}:rows;this[w4a](e5a);editor[W2D](p2D,function(){that[w4a](Y5a);})[T3a](items,{buttons:config[V0d],message:config[f2D] || editor[o2D][i2D][h7a],title:config[M0d] || editor[w2D][T3a][H1n]});}},remove:{extend:d0d,limitTo:[x2D],text:function(dt,node,config){var w0d='buttons.remove';var D2D=m2r;D2D+=i0d;var h2D=K6n;h2D+=T9a;h2D+=i4v;return dt[h2D](w0d,config[D2D][S2r][D2n][Q4n]);},className:x0d,editor:O1a,formButtons:{text:function(editor){var K2D=k2r;K2D+=N3a;K2D+=L5L.Y4v;var U2D=x4v;U2D+=v7a;U2D+=W1n;return editor[U2D][K2D][T6n];},action:function(e){this[T6n]();}},formMessage:function(editor,dt){var h0d="irm";var U0d="ndex";var D0d="onfirm";var a9D=S6a;a9D+=S1n;var b9D=p2r;b9D+=q8a;var H9D=Z2n;H9D+=h0d;var s9D=p2r;s9D+=q8a;var Q9D=L5L.F4v;Q9D+=D0d;var L9D=u3a;L9D+=L5L.P4v;L9D+=G6n;L9D+=L5L.Y4v;var O9D=x4v;O9D+=U0d;O9D+=H8a;var rows=dt[X6r]({selected:e5a})[O9D]();L5L.g5L();var i18n=editor[S2r][L9D];var question=typeof i18n[g2r] === A4n?i18n[g2r]:i18n[Q9D][rows[s9D]]?i18n[H9D][rows[b9D]]:i18n[g2r][a3a];return question[s6n](/%d/g,rows[a9D]);},formTitle:O1a,action:function(e,dt,node,config){var L7d="roces";var O7d="mB";var K0d="formMess";var l9D=Y6n;l9D+=a6a;l9D+=u8a;l9D+=L5L.Y4v;var r9D=K6n;r9D+=W1n;var c9D=K0d;c9D+=L5L.J4v;c9D+=U8r;var X9D=K3a;X9D+=A9a;X9D+=O7d;X9D+=D6a;var I9D=D4v;I9D+=K4v;I9D+=r2a;I9D+=b3a;var v9D=U4v;v9D+=L5L.Y4v;v9D+=j8a;v9D+=I7n;var u9D=n3a;u9D+=L5L.Y4v;var z9D=z3a;z9D+=L7d;z9D+=b8a;var that=this;var editor=config[z0r];this[z9D](e5a);editor[u9D](v9D,function(){L5L.r5L();that[w4a](Y5a);})[D2n](dt[I9D]({selected:e5a})[F2d](),{buttons:config[X9D],message:config[c9D],title:config[M0d] || editor[r9D][D2n][l9D]});}}});_buttons[Q7d]=$[I7a]({},_buttons[C9D]);_buttons[A9D][S9D]=n9D;_buttons[s7d]=$[g9D]({},_buttons[D2n]);_buttons[s7d][I7a]=V9D;})();Editor[C7a]={};Editor[H7d]=function(input,opts){var q7d="efix";var b7d="tim";var o7d='-label">';var p7d='<select class="';var A7d="nutes\"/>";var Z7d="span";var D7d='-title';var g7d="<select ";var n7d="alendar\"";var Y7d="t momentjs only the format 'YYYY-MM-DD' can be used";var d7d='<button>';var C7d="-mi";var x7d='-seconds"/>';var z7d="tc";var v7d="tanc";var l7d="r\"/>";var S7d="e\"";var m7d=" class";var M7d='-iconLeft">';var f7d='-month"/>';var j7d="Editor datetime: Withou";var L1d=/[Hhm]|LT|LTS/;var V7d="an/>";var y7d="div ";var J7d="au";var H1d="calendar";L5L.g5L();var Q1d=/[haA]/;var X7d="-c";var E7d="title\">";var k7d="DD";var i7d='-year"/>';var h7d='-date';var c7d="alen";var N7d="YYYY-MM-";var W7d='-iconRight">';var w7d='-hours"/>';var U7d='editor-dateime-';var R7d="previous";var G7d="-label\"";var t7d='-date">';var K7d=/[YMD]|L(?!T)|l/;var C5D=L5L.j4v;C5D+=W5a;var l5D=i8n;l5D+=J4a;var r5D=a6a;r5D+=x4v;r5D+=a6a;r5D+=S6a;var c5D=L5L.J4v;c5D+=q4a;c5D+=V7n;c5D+=L5L.j4v;var X5D=L5L.j4v;X5D+=W5a;var I5D=b7d;I5D+=L5L.Y4v;var v5D=L5L.j4v;v5D+=W5a;var u5D=L5L.j4v;u5D+=K4v;u5D+=L5L.P4v;var z5D=n3n;z5D+=L6a;z5D+=y8a;var a5D=L5L.j4v;a5D+=W5a;var b5D=L0r;b5D+=L7a;var H5D=X7n;H5D+=a7d;var s5D=h9n;s5D+=z7d;s5D+=q8a;var Q5D=u7d;Q5D+=b3a;Q5D+=v7d;Q5D+=L5L.Y4v;var L5D=D9d;L5D+=L5L.Y4v;L5D+=r7r;L5D+=A9a;var O5D=I7d;O5D+=x4v;O5D+=u6a;var K9D=X7d;K9D+=c7d;K9D+=Z9a;K9D+=D4v;var U9D=r7d;U9D+=L5L.j4v;var D9D=X0a;D9D+=Z7n;D9D+=C0a;var h9D=D9d;h9D+=p6r;h9D+=K4v;h9D+=l7d;var x9D=C7d;x9D+=A7d;var w9D=X9n;w9D+=M7n;var i9D=I7d;i9D+=G3n;i9D+=S7d;i9D+=C0a;var o9D=D9d;o9D+=L5L.F4v;o9D+=n7d;o9D+=P7n;var f9D=y7n;f9D+=x9a;f9D+=Y2n;f9D+=g0a;var p9D=F0a;p9D+=t0a;var W9D=g7d;W9D+=e7n;var B9D=u0a;B9D+=b3a;B9D+=z3a;B9D+=V7d;var R9D=u0a;R9D+=S8r;var d9D=u0a;d9D+=V0a;d9D+=x4v;d9D+=Z0a;var M9D=u0a;M9D+=Z7d;M9D+=P7n;var t9D=G7d;t9D+=C0a;var F9D=u0a;F9D+=r0a;F9D+=l0a;F9D+=C0a;var e9D=i4v;e9D+=L5L.Y4v;e9D+=D2a;e9D+=a6a;var Y9D=t7n;Y9D+=N7n;var j9D=D9d;j9D+=E7d;var P9D=u0a;P9D+=y7d;P9D+=L5L.F4v;P9D+=X5r;var J9D=j7n;J9D+=Y7n;J9D+=e7n;var q9D=S0a;q9D+=N3a;q9D+=m7d;q9D+=M7n;var m9D=N7d;m9D+=k7d;var y9D=L5L.P4v;y9D+=W5a;y9D+=V7n;y9D+=a6a;var E9D=L5L.F4v;E9D+=u8a;E9D+=T7d;E9D+=q7d;var G9D=F1a;G9D+=J7d;G9D+=u7a;G9D+=b3a;var Z9D=b0a;Z9D+=J4a;this[L5L.F4v]=$[Z9D](e5a,{},Editor[H7d][G9D],opts);var classPrefix=this[L5L.F4v][E9D];var i18n=this[L5L.F4v][S2r];if(!window[y9D] && this[L5L.F4v][P7d] !== m9D){var N9D=j7d;N9D+=Y7d;throw N9D;}var timeBlock=function(type){var e7d='-timeblock">';var k9D=F0a;L5L.r5L();k9D+=t0a;return k7a + classPrefix + e7d + k9D;};var gap=function(){var F7d="an>:</span>";var T9D=u0a;L5L.g5L();T9D+=K2a;T9D+=F7d;return T9D;};var structure=$(q9D + classPrefix + Y7a + J9D + classPrefix + t7d + P9D + classPrefix + j9D + k7a + classPrefix + M7d + d7d + i18n[R7d] + B7d + M7a + Y9D + classPrefix + W7d + d7d + i18n[e9D] + B7d + F9D + k7a + classPrefix + t9D + M9D + p7d + classPrefix + f7d + d9D + R9D + classPrefix + o7d + B9D + W9D + classPrefix + i7d + p9D + M7a + f9D + classPrefix + o9D + M7a + k7a + classPrefix + i9D + w9D + classPrefix + w7d + k7a + classPrefix + x9D + k7a + classPrefix + x7d + M7a + k7a + classPrefix + h9D + D9D);this[V1a]={container:structure,date:structure[e8r](P8r + classPrefix + h7d),title:structure[e8r](P8r + classPrefix + D7d),calendar:structure[U9D](P8r + classPrefix + K9D),time:structure[e8r](P8r + classPrefix + O5D),error:structure[e8r](P8r + classPrefix + L5D),input:$(input)};this[b3a]={d:O1a,display:O1a,minutesRange:O1a,secondsRange:O1a,namespace:U7d + Editor[H7d][Q5D]++,parts:{date:this[L5L.F4v][P7d][s5D](K7d) !== O1a,time:this[L5L.F4v][H5D][O1d](L1d) !== O1a,seconds:this[L5L.F4v][b5D][Q7r](K9a) !== -B1v,hours12:this[L5L.F4v][P7d][O1d](Q1d) !== O1a}};this[a5D][w1a][z5D](this[u5D][s1d])[O3n](this[v5D][I5D])[O3n](this[V1a][z4a]);this[X5D][s1d][c5D](this[V1a][r5D])[l5D](this[C5D][H1d]);this[z5a]();};$[I7a](Editor[A5D][S5D],{destroy:function(){var z1d="mpty";var v1d='.editor-datetime';var G5D=K4v;G5D+=K3a;G5D+=K3a;var Z5D=x4v;Z5D+=b1d;Z5D+=a1d;var V5D=v1a;V5D+=L5L.P4v;var g5D=L5L.Y4v;g5D+=z1d;var n5D=Q3n;n5D+=u1d;this[n5D]();this[V1a][w1a][E5n]()[g5D]();this[V5D][Z5D][G5D](v1d);},errorMsg:function(msg){var y5D=p6r;y5D+=A9a;var E5D=L5L.j4v;L5L.r5L();E5D+=K4v;E5D+=L5L.P4v;var error=this[E5D][y5D];if(msg){var m5D=q8a;m5D+=a6a;m5D+=L5L.P4v;m5D+=u8a;error[m5D](msg);}else {var N5D=L5L.Y4v;N5D+=L5L.P4v;N5D+=C8a;N5D+=B8a;error[N5D]();}},hide:function(){this[y9n]();},max:function(date){var I1d="_optionsTi";L5L.g5L();var k5D=I1d;k5D+=a6a;k5D+=S6a;this[L5L.F4v][X1d]=date;this[k5D]();this[c1d]();},min:function(date){var l1d="ander";var r1d="setCal";var A1d="_optionsTitle";var T5D=a3a;T5D+=r1d;T5D+=l1d;this[L5L.F4v][C1d]=date;this[A1d]();this[T5D]();},owns:function(node){var S1d="ntai";var j5D=u8a;j5D+=B9d;j5D+=a6a;j5D+=q8a;var P5D=R1a;P5D+=S1d;P5D+=m6a;var J5D=L5L.j4v;J5D+=K4v;J5D+=L5L.P4v;var q5D=z3a;q5D+=W2a;q5D+=R8r;return $(node)[q5D]()[f9d](this[J5D][P5D])[j5D] > R1v;},val:function(set,write){var g1d="_dateTo";var q1d=/(\d{4})\-(\d{2})\-(\d{2})/;var m1d="entStri";var Z1d='--now';var e1d="_setTitle";var E1d="sValid";var n1d="isp";var j1d="Ut";var V1d="Utc";var k1d="toDate";var P1d="dateTo";var w5D=U2a;w5D+=b3a;w5D+=t3r;var i5D=c1r;i5D+=V6n;i5D+=L0a;i5D+=N2a;var o5D=L5L.j4v;o5D+=n1d;o5D+=u8a;o5D+=q9n;var e5D=b3a;e5D+=V6n;e5D+=L0a;e5D+=N2a;if(set === undefined){return this[b3a][L5L.j4v];}if(set instanceof Date){var Y5D=g1d;Y5D+=V1d;this[b3a][L5L.j4v]=this[Y5D](set);}else if(set === O1a || set === U9a){this[b3a][L5L.j4v]=O1a;}else if(set === Z1d){this[b3a][L5L.j4v]=new Date();}else if(typeof set === e5D){if(window[G1d]){var R5D=x4v;R5D+=E1d;var d5D=y1d;d5D+=m1d;d5D+=Y8a;var M5D=X8a;M5D+=N1d;M5D+=L5L.J4v;M5D+=S6a;var t5D=T8a;t5D+=a6a;t5D+=L5L.F4v;var F5D=y1d;F5D+=k3a;var m=window[F5D][t5D](set,this[L5L.F4v][P7d],this[L5L.F4v][M5D],this[L5L.F4v][d5D]);this[b3a][L5L.j4v]=m[R5D]()?m[k1d]():O1a;}else {var B5D=V5a;B5D+=T1d;var match=set[O1d](q1d);this[b3a][L5L.j4v]=match?new Date(Date[B5D](match[B1v],match[W1v] - B1v,match[p1v])):O1a;}}if(write || write === undefined){if(this[b3a][L5L.j4v]){this[J1d]();}else {var p5D=N5d;p5D+=u8a;var W5D=f0a;W5D+=a1d;this[V1a][W5D][p5D](set);}}if(!this[b3a][L5L.j4v]){var f5D=a3a;f5D+=P1d;f5D+=j1d;f5D+=L5L.F4v;this[b3a][L5L.j4v]=this[f5D](new Date());}this[b3a][o5D]=new Date(this[b3a][L5L.j4v][i5D]());this[b3a][w5D][Y1d](B1v);this[e1d]();this[c1d]();this[F1d]();},_constructor:function(){var x1d="parts";var K1d="ldre";var t1d="ain";var B1d="comp";var D1d="seconds";var M1d="focus.editor-datetime click.edito";var a4d='keyup.editor-datetime';var U1d="ldr";var R1d="ff";var d1d="r-datetime";var O4d='-seconds';var h1d="time";var n4d="_correctMonth";var p1d="rts";var v4d='select';var W1d="optionsTit";var h0D=L5L.F4v;h0D+=u8a;h0D+=r1r;h0D+=o6n;var x0D=K4v;x0D+=i4v;var y0D=M9n;y0D+=t1d;y0D+=j3a;var V0D=K4v;V0D+=i4v;var l0D=M1d;l0D+=d1d;var r0D=K4v;r0D+=R1d;var c0D=L5L.J4v;c0D+=c5n;c0D+=B1d;c0D+=I7r;var X0D=d2d;X0D+=D4v;var I0D=x4v;I0D+=i4v;I0D+=z3a;I0D+=a1d;var v0D=a3a;v0D+=W1d;v0D+=S6a;var K5D=a6a;K5D+=G3n;K5D+=L5L.Y4v;var U5D=a5n;U5D+=p1d;var h5D=d6d;h5D+=L5L.Y4v;var that=this;var classPrefix=this[L5L.F4v][f1d];var onChange=function(){var i1d="onChange";L5L.g5L();var x5D=o1d;x5D+=a6a;that[L5L.F4v][i1d][z4n](that,that[V1a][x5D][g1a](),that[b3a][L5L.j4v],that[V1a][w1d]);};if(!this[b3a][x1d][h5D]){var D5D=L5L.j4v;D5D+=L5L.J4v;D5D+=a6a;D5D+=L5L.Y4v;this[V1a][D5D][s1a](H1a,h1a);}if(!this[b3a][U5D][K5D]){var L0D=T9n;L0D+=O9a;var O0D=L5L.F4v;O0D+=b3a;O0D+=b3a;this[V1a][h1d][O0D](L0D,h1a);}if(!this[b3a][x1d][D1d]){var u0D=u3a;u0D+=m0r;var z0D=b3a;z0D+=z3a;z0D+=L5L.J4v;z0D+=i4v;var a0D=f4a;a0D+=x4v;a0D+=U1d;a0D+=V7n;var b0D=L5L.j4v;b0D+=K4v;b0D+=L5L.P4v;var H0D=L5L.j4v;H0D+=x4v;H0D+=N3a;H0D+=B7n;var s0D=f4a;s0D+=x4v;s0D+=K1d;s0D+=i4v;var Q0D=L5L.j4v;Q0D+=K4v;Q0D+=L5L.P4v;this[Q0D][h1d][s0D](H0D + classPrefix + O4d)[D2n]();this[b0D][h1d][a0D](z0D)[O1n](B1v)[u0D]();}this[v0D]();this[V1a][I0D][X0D](c0D,r0D)[n3a](l0D,function(){var b4d=':visible';var L4d="sho";var H4d="ntaine";var s4d=":dis";var g0D=a3a;g0D+=L4d;L5L.r5L();g0D+=r2a;var n0D=x4v;n0D+=Q4d;n0D+=a6a;var S0D=s4d;S0D+=c1a;var A0D=R1a;A0D+=H4d;A0D+=D4v;var C0D=L5L.j4v;C0D+=K4v;C0D+=L5L.P4v;if(that[C0D][A0D][P9n](b4d) || that[V1a][w1d][P9n](S0D)){return;}that[g1a](that[V1a][n0D][g1a](),Y5a);that[g0D]();})[V0D](a4d,function(){var u4d="isible";var z4d=":v";var G0D=z4d;G0D+=u4d;var Z0D=x4v;Z0D+=b3a;if(that[V1a][w1a][Z0D](G0D)){var E0D=N3a;E0D+=L5L.J4v;E0D+=u8a;that[E0D](that[V1a][w1d][g1a](),Y5a);}});this[V1a][y0D][n3a](O6r,v4d,function(){var l4d="-hou";var r4d="asCl";var G4d="hours";var X4d="osi";var V4d="itle";var E4d="ntain";var y4d='-ampm';var g4d='-year';var Z4d="tUTCFullYear";var N4d='-minutes';var S4d="_setT";var A4d='-month';var w0D=I4d;w0D+=X4d;w0D+=c4d;w0D+=i4v;var i0D=f8d;i0D+=b3a;var o0D=L0a;o0D+=z3a;o0D+=a1d;var f0D=r1a;f0D+=T6d;var Y0D=D9d;Y0D+=V7a;Y0D+=z3a;Y0D+=L5L.P4v;var j0D=q8a;j0D+=r4d;j0D+=v8a;j0D+=b3a;L5L.r5L();var P0D=l4d;P0D+=C4d;var J0D=q8a;J0D+=W3n;var m0D=C4a;m0D+=w0a;m0D+=b3a;m0D+=b3a;var select=$(this);var val=select[g1a]();if(select[m0D](classPrefix + A4d)){var k0D=S4d;k0D+=X2a;k0D+=L5L.Y4v;var N0D=U2a;N0D+=b3a;N0D+=t3r;that[n4d](that[b3a][N0D],val);that[k0D]();that[c1d]();}else if(select[e5n](classPrefix + g4d)){var q0D=S4d;q0D+=V4d;var T0D=Q9a;T0D+=Z4d;that[b3a][j2a][T0D](val);that[q0D]();that[c1d]();}else if(select[J0D](classPrefix + P0D) || select[j0D](classPrefix + Y0D)){var e0D=G4d;e0D+=v7a;e0D+=p4v;if(that[b3a][x1d][e0D]){var W0D=z3a;W0D+=L5L.P4v;var B0D=N3a;B0D+=L5L.J4v;B0D+=u8a;var R0D=r7d;R0D+=L5L.j4v;var d0D=L5L.F4v;d0D+=K4v;d0D+=E4d;d0D+=j3a;var M0D=L5L.j4v;M0D+=W5a;var t0D=D9d;t0D+=t6n;t0D+=B3a;t0D+=b3a;var F0D=L5L.j4v;F0D+=K4v;F0D+=L5L.P4v;var hours=$(that[F0D][w1a])[e8r](P8r + classPrefix + t0D)[g1a]() * B1v;var pm=$(that[M0D][d0D])[R0D](P8r + classPrefix + y4d)[B0D]() === W0D;that[b3a][L5L.j4v][m4d](hours === D1v && !pm?R1v:pm && hours !== D1v?hours + D1v:hours);}else {that[b3a][L5L.j4v][m4d](val);}that[F1d]();that[J1d](e5a);onChange();}else if(select[e5n](classPrefix + N4d)){var p0D=S4d;p0D+=G3n;p0D+=L5L.Y4v;that[b3a][L5L.j4v][k4d](val);that[p0D]();that[J1d](e5a);onChange();}else if(select[f0D](classPrefix + O4d)){that[b3a][L5L.j4v][T4d](val);that[F1d]();that[J1d](e5a);onChange();}that[V1a][o0D][i0D]();that[w0D]();})[x0D](h0D,function(e){var Y4d="targe";var K4d="TCMonth";var C6S="TCHours";var k6S="setUTCFullYear";var h4d="nder";var s6S="Second";var D4d="etTitl";var d4d="onR";var w4d="setUTCMont";var W4d="ha";var R4d="sClass";var Z6S="utput";var S6S="getUTCHours";var V6S="_writeO";var f4d="tTitle";var H6S="minut";var P4d="owerC";var x4d="_setCala";var O6S='-time';var L6S="_se";var Q6S="tTim";var E6S="tUTCMo";var g6S='setUTCMinutes';var r6S="nge";var A6S="getUTCHou";var c6S="sRa";var B4d="conLef";var o4d="TCM";var J4d="toL";var U4d="getU";var n6S='setUTCHours';var u6S='seconds';var F4d="werCase";var j4d="parentNo";var e4d="Lo";var q4d="opPropagati";var p4d='range';var t4d="eN";var s7D=b9a;s7D+=a6a;s7D+=h4v;s7D+=i4v;var Q7D=b3a;Q7D+=a6a;Q7D+=q4d;Q7D+=n3a;var L7D=J4d;L7D+=P4d;L7D+=v8a;L7D+=L5L.Y4v;var O7D=j4d;O7D+=V8a;var K0D=Y4d;K0D+=a6a;var U0D=h4v;U0D+=e4d;U0D+=F4d;var D0D=F3r;D0D+=t4d;D0D+=L5L.J4v;D0D+=u6a;var d=that[b3a][L5L.j4v];var nodeName=e[o8r][D0D][U0D]();var target=nodeName === M4d?e[K0D][O7D]:e[o8r];nodeName=target[v5d][L7D]();if(nodeName === v4d){return;}e[Q7D]();if(nodeName === s7D){var G7D=n6d;G7D+=k3a;G7D+=b3a;var l7D=I5d;l7D+=L5L.F4v;l7D+=d4d;l7D+=p5n;var r7D=q8a;r7D+=L5L.J4v;r7D+=R4d;var z7D=I5d;z7D+=B4d;z7D+=a6a;var b7D=y6r;b7D+=L5L.j4v;var H7D=W4d;H7D+=R4d;var button=$(target);var parent=button[M6n]();if(parent[H7D](b7D) && !parent[e5n](p4d)){var a7D=w6a;a7D+=u8a;a7D+=T8a;a7D+=D4v;button[a7D]();return;}if(parent[e5n](classPrefix + z7D)){var c7D=v1a;c7D+=L5L.P4v;var X7D=x8n;X7D+=L5L.Y4v;X7D+=f4d;var I7D=N9a;I7D+=V5a;I7D+=o4d;I7D+=i4d;var v7D=L5L.j4v;v7D+=P9n;v7D+=t3r;var u7D=w4d;u7D+=q8a;that[b3a][j2a][u7D](that[b3a][v7D][I7D]() - B1v);that[X7D]();that[c1d]();that[c7D][w1d][y3r]();}else if(parent[r7D](classPrefix + l7D)){var Z7D=K3a;Z7D+=i8d;var V7D=x4v;V7D+=g4a;var g7D=L5L.j4v;g7D+=K4v;g7D+=L5L.P4v;var n7D=x4d;n7D+=h4d;var S7D=a3a;S7D+=b3a;S7D+=D4d;S7D+=L5L.Y4v;var A7D=U4d;A7D+=K4d;var C7D=g0r;C7D+=q9n;that[n4d](that[b3a][j2a],that[b3a][C7D][A7D]() + B1v);that[S7D]();that[n7D]();that[g7D][V7D][Z7D]();}else if(button[G7D](P8r + classPrefix + O6S)[j5a]){var M7D=L6S;M7D+=Q6S;M7D+=L5L.Y4v;var t7D=Q9a;t7D+=a6a;t7D+=s6S;t7D+=b3a;var F7D=H6S;F7D+=L5L.Y4v;F7D+=b3a;var e7D=t6n;e7D+=T8a;e7D+=D4v;e7D+=b3a;var J7D=L5L.J4v;J7D+=L5L.P4v;var y7D=m2n;y7D+=x4v;y7D+=a6a;var E7D=Z9a;E7D+=E9n;var val=button[Z7a](W2r);var unit=button[E7D](y7D);if(unit === b6S){var N7D=W4d;N7D+=R4d;var m7D=r1a;m7D+=T6d;if(parent[m7D](a6S) && parent[N7D](p4d)){that[b3a][z6S]=val;that[F1d]();return;}else {that[b3a][z6S]=O1a;}}if(unit === u6S){var T7D=D4v;T7D+=v6S;var k7D=q8a;k7D+=v8a;k7D+=t6d;k7D+=T0r;if(parent[e5n](a6S) && parent[k7D](T7D)){that[b3a][I6S]=val;that[F1d]();return;}else {var q7D=X6S;q7D+=L5L.j4v;q7D+=c6S;q7D+=r6S;that[b3a][q7D]=O1a;}}if(val === J7D){var P7D=U4d;P7D+=T1d;P7D+=l6S;if(d[P7D]() >= D1v){var j7D=U4d;j7D+=C6S;val=d[j7D]() - D1v;}else {return;}}else if(val === b2d){var Y7D=A6S;Y7D+=C4d;if(d[Y7D]() < D1v){val=d[S6S]() + D1v;}else {return;}}var set=unit === e7D?n6S:unit === F7D?g6S:t7D;d[set](val);that[M7D]();that[J1d](e5a);onChange();}else {var i7D=a5n;i7D+=D4v;i7D+=O3a;var o7D=V6S;o7D+=Z6S;var f7D=L5L.j4v;f7D+=q9n;var p7D=L5L.j4v;p7D+=Q7a;var W7D=Q9a;W7D+=a6a;W7D+=G6S;var B7D=L5L.P4v;B7D+=i4d;var R7D=Q9a;R7D+=E6S;R7D+=y6S;var d7D=B8a;d7D+=m6S;if(!d){d=that[N6S](new Date());}d[Y1d](B1v);d[k6S](button[Z7a](d7D));d[R7D](button[Z7a](B7D));d[W7D](button[p7D](f7D));that[o7D](e5a);if(!that[b3a][i7D][h1d]){setTimeout(function(){that[y9n]();},x1v);}else {that[c1d]();}onChange();}}else {var w7D=L5L.j4v;w7D+=K4v;w7D+=L5L.P4v;that[w7D][w1d][y3r]();}});},_compareDates:function(a,b){var q6S="_dateToUtcString";var T6S="_dateToUtcStr";var x7D=T6S;x7D+=g2n;return this[q6S](a) === this[x7D](b);},_correctMonth:function(date,month){var Y6S="setUT";var J6S="setUTCMo";var D7D=J6S;D7D+=y6S;var h7D=N9a;L5L.r5L();h7D+=G6S;var days=this[P6S](date[j6S](),month);var correctDays=date[h7D]() > days;date[D7D](month);if(correctDays){var U7D=Y6S;U7D+=t6d;U7D+=R8a;U7D+=i4d;date[Y1d](days);date[U7D](month);}},_daysInMonth:function(year,month){var u4v=30;var a4v=28;L5L.r5L();var z4v=29;var v4v=31;var isLeap=year % f1v === R1v && (year % S4v !== R1v || year % g4v === R1v);var months=[v4v,isLeap?z4v:a4v,v4v,u4v,v4v,u4v,v4v,v4v,u4v,v4v,u4v,v4v];return months[month];},_dateToUtc:function(s){var p6S="getMinutes";var t6S="tH";var B6S="getMonth";var F6S="conds";var e6S="getSe";L5L.r5L();var M6S="our";var O1D=e6S;O1D+=F6S;var K7D=U8r;K7D+=t6S;K7D+=M6S;K7D+=b3a;return new Date(Date[d6S](s[R6S](),s[B6S](),s[W6S](),s[K7D](),s[p6S](),s[O1D]()));},_dateToUtcString:function(d){var f6S="_pa";var s1D=N9a;s1D+=G6S;var Q1D=a3a;Q1D+=z3a;Q1D+=g2d;var L1D=f6S;L1D+=L5L.j4v;return d[j6S]() + J3r + this[L1D](d[o6S]() + B1v) + J3r + this[Q1D](d[s1D]());},_hide:function(){var x6S="y_Content";var w6S="div.DTE_B";var D6S="div.dataTables_scrollB";var C1D=Y2n;C1D+=r1r;C1D+=o6n;C1D+=B7n;var l1D=w6a;l1D+=K6a;var r1D=b3a;r1D+=P4n;r1D+=r8n;r1D+=i6S;var c1D=K4v;c1D+=K3a;c1D+=K3a;var X1D=w6S;X1D+=p7r;X1D+=x6S;var I1D=h6S;I1D+=u8a;I1D+=i6S;var v1D=K4v;v1D+=K3a;v1D+=K3a;var u1D=D6S;u1D+=K6a;var z1D=Q5n;z1D+=K3a;var a1D=K4v;a1D+=K3a;a1D+=K3a;var b1D=L5L.j4v;b1D+=W5a;var H1D=j2r;H1D+=Y2r;var namespace=this[b3a][H1D];this[b1D][w1a][P4a]();$(window)[a1D](P8r + namespace);$(document)[z1D](U6S + namespace);$(u1D)[v1D](I1D + namespace);$(X1D)[c1D](r1D + namespace);$(l1D)[E5n](C1D + namespace);},_hours24To12:function(val){L5L.g5L();return val === R1v?D1v:val > D1v?val - D1v:val;},_htmlDay:function(day){var l8S="ix";var K6S="</button";var L8S="onth=\"";var H8S="-da";var V8S='" class="';var C8S="electab";var g8S="day";var Q8S="ata-ye";var X8S="<td d";var u8S="-butto";var O8S="\" data-m";var A8S="<td class=\"empty\"></t";var s8S="ar=\"";var c8S="ata-day=\"";var G8S='" data-day="';var a8S="pe=\"but";var z8S="ton\" ";var b8S="y\" ty";var Z8S="month";var r8S="disa";var E8S='<span>';var Y1D=K6S;Y1D+=C0a;var j1D=L5L.j4v;j1D+=L5L.J4v;j1D+=B8a;var P1D=L5L.j4v;P1D+=q9n;var J1D=O8S;J1D+=L8S;var q1D=B8a;q1D+=m6S;var T1D=L5L.j4v;T1D+=Q8S;T1D+=s8S;var k1D=H8S;k1D+=b8S;k1D+=a8S;k1D+=z8S;var N1D=u8S;N1D+=V6a;var m1D=v8S;m1D+=I8S;var y1D=J5a;y1D+=K4v;L5L.g5L();y1D+=L0a;var E1D=X8S;E1D+=c8S;var Z1D=a6a;Z1D+=K4v;Z1D+=Z9a;Z1D+=B8a;var V1D=r8S;V1D+=i2a;V1D+=P2a;var g1D=Y2n;g1D+=T7d;g1D+=I9a;g1D+=l8S;var n1D=b3a;n1D+=C8S;n1D+=S6a;var A1D=L5L.Y4v;A1D+=L5L.P4v;A1D+=z3a;A1D+=R2a;if(day[A1D]){var S1D=A8S;S1D+=S8S;return S1D;}var classes=[n1D];var classPrefix=this[L5L.F4v][g1D];if(day[V1D]){classes[C5a](a6S);}if(day[Z1D]){var G1D=i4v;G1D+=K4v;G1D+=r2a;classes[C5a](G1D);}if(day[n8S]){classes[C5a](d0d);}return E1D + day[g8S] + V8S + classes[y1D](q7a) + Y7a + m1D + classPrefix + N1D + classPrefix + k1D + T1D + day[q1D] + J1D + day[Z8S] + G8S + day[P1D] + Y7a + E8S + day[j1D] + y8S + Y1D + m8S;},_htmlMonth:function(year,month){var j8S="lD";var B8S="howWeekNu";var R8S="disableDays";var Q4v=23;var e8S="tUT";var p8S="_htmlWeekOfYear";var W8S="nshift";var w8S=' weekNumber';var U8S='<thead>';var P8S="etSecond";var t8S="nAr";var F8S="Day";var x8S='-iconLeft';var k8S="he";var Q3S='</table>';var D8S='<table class="';var h8S='-iconRight';var O3S='<tbody>';var K8S="_htmlMonthHead";var Y8S="nct";var T8S="-ta";var L3S='</tbody>';var d8S="_compareDates";var q8S="UTCDa";var a4D=N0r;a4D+=x4v;a4D+=i4v;var b4D=N8S;b4D+=k8S;b4D+=L5L.J4v;b4D+=S8S;var H4D=v5a;H4D+=C0a;var w1D=T8S;w1D+=i2a;w1D+=L5L.Y4v;var F1D=L5L.P4v;F1D+=H9r;F1D+=L5L.Y4v;var e1D=U8r;e1D+=a6a;e1D+=q8S;e1D+=B8a;var now=this[N6S](new Date()),days=this[P6S](year,month),before=new Date(Date[d6S](year,month,B1v))[e1D](),data=[],row=[];if(this[L5L.F4v][J8S] > R1v){before-=this[L5L.F4v][J8S];if(before < R1v){before+=i1v;}}var cells=days + before,after=cells;while(after > i1v){after-=i1v;}cells+=i1v - after;var minDate=this[L5L.F4v][C1d];var maxDate=this[L5L.F4v][F1D];if(minDate){var t1D=b3a;t1D+=P8S;t1D+=b3a;minDate[m4d](R1v);minDate[k4d](R1v);minDate[t1D](R1v);}if(maxDate){maxDate[m4d](Q4v);maxDate[k4d](l4v);maxDate[T4d](l4v);}for(var i=R1v,r=R1v;i < cells;i++){var p1D=a3a;p1D+=a2r;p1D+=j8S;p1D+=q9n;var W1D=z3a;W1D+=T8a;W1D+=b3a;W1D+=q8a;var B1D=q4r;B1D+=Y8S;B1D+=n8a;B1D+=i4v;var R1D=U8r;R1D+=e8S;R1D+=t6d;R1D+=F8S;var d1D=x4v;d1D+=t8S;d1D+=D4v;d1D+=q9n;var M1D=M8S;M1D+=t6d;var day=new Date(Date[M1D](year,month,B1v + (i - before))),selected=this[b3a][L5L.j4v]?this[d8S](day,this[b3a][L5L.j4v]):Y5a,today=this[d8S](day,now),empty=i < before || i >= days + before,disabled=minDate && day < minDate || maxDate && day > maxDate;var disableDays=this[L5L.F4v][R8S];if($[X6n](disableDays) && $[d1D](day[R1D](),disableDays) !== -B1v){disabled=e5a;}else if(typeof disableDays === B1D && disableDays(day) === e5a){disabled=e5a;}var dayConfig={day:B1v + (i - before),month:month,year:year,selected:selected,today:today,disabled:disabled,empty:empty};row[W1D](this[p1D](dayConfig));if(++r === i1v){var i1D=N0r;i1D+=x4v;i1D+=i4v;var f1D=b3a;f1D+=B8S;f1D+=L5L.P4v;f1D+=t8a;if(this[L5L.F4v][f1D]){var o1D=T8a;o1D+=W8S;row[o1D](this[p8S](i - before,month,year));}data[C5a](f8S + row[i1D](U9a) + o8S);row=[];r=R1v;}}var classPrefix=this[L5L.F4v][f1d];var className=classPrefix + w1D;if(this[L5L.F4v][i8S]){className+=w8S;}if(minDate){var K1D=w6a;K1D+=i4a;var U1D=q6n;U1D+=i4v;U1D+=L5L.j4v;var D1D=a6a;D1D+=x4v;D1D+=A2r;D1D+=L5L.Y4v;var h1D=L5L.j4v;h1D+=K4v;h1D+=L5L.P4v;var x1D=V5a;x1D+=a8a;x1D+=t6d;var underMin=minDate >= new Date(Date[x1D](year,month,B1v,R1v,R1v,R1v));this[h1D][D1D][U1D](J8r + classPrefix + x8S)[s1a](H1a,underMin?h1a:K1D);}if(maxDate){var s4D=U2a;s4D+=u2r;var Q4D=K3a;Q4D+=b7r;var L4D=L5L.j4v;L4D+=W5a;var O4D=V5a;O4D+=T1d;var overMax=maxDate < new Date(Date[O4D](year,month + B1v,B1v,R1v,R1v,R1v));this[L4D][H1n][Q4D](s4D + classPrefix + h8S)[s1a](H1a,overMax?h1a:X8n);}return D8S + className + H4D + U8S + this[K8S]() + b4D + O3S + data[a4D](U9a) + L3S + Q3S;},_htmlMonthHead:function(){var b3S="pus";var a3S='<th></th>';var z3S="h>";L5L.g5L();var a=[];var firstDay=this[L5L.F4v][J8S];var i18n=this[L5L.F4v][S2r];var dayName=function(day){L5L.r5L();var s3S="we";var H3S="ekdays";var z4D=s3S;z4D+=H3S;day+=firstDay;while(day >= i1v){day-=i1v;}return i18n[z4D][day];};if(this[L5L.F4v][i8S]){var u4D=b3S;u4D+=q8a;a[u4D](a3S);}for(var i=R1v;i < i1v;i++){var X4D=N8S;X4D+=z3S;var I4D=u0a;I4D+=a6a;I4D+=q8a;I4D+=C0a;var v4D=z3a;v4D+=T8a;v4D+=c2a;a[v4D](I4D + dayName(i) + X4D);}return a[q3r](U9a);},_htmlWeekOfYear:function(d,m,y){var c3S='<td class="';var X3S="ceil";var r3S='-week">';var u3S="assPrefix";var N4v=86400000;var v3S="etDate";var I3S="getDay";var r4D=Y2n;r4D+=u3S;var c4D=b3a;c4D+=v3S;var date=new Date(y,m,d,R1v,R1v,R1v,R1v);date[c4D](date[W6S]() + f1v - (date[I3S]() || i1v));var oneJan=new Date(y,R1v,B1v);var weekNum=Math[X3S](((date - oneJan) / N4v + B1v) / i1v);L5L.r5L();return c3S + this[L5L.F4v][r4D] + r3S + weekNum + m8S;},_options:function(selector,values,labels){var l3S="tai";var S3S="</op";var g3S='<option value="';var C3S='select.';var A4D=S6a;A4D+=i4v;A4D+=N2a;A4D+=U4n;var C4D=Q4a;C4D+=l3S;C4D+=y2a;C4D+=D4v;var l4D=L5L.j4v;l4D+=K4v;L5L.r5L();l4D+=L5L.P4v;if(!labels){labels=values;}var select=this[l4D][C4D][e8r](C3S + this[L5L.F4v][f1d] + J3r + selector);select[A3S]();for(var i=R1v,ien=values[A4D];i < ien;i++){var n4D=S3S;n4D+=c4d;n4D+=n3S;var S4D=v5a;S4D+=C0a;select[O3n](g3S + values[i] + S4D + labels[i] + n4D);}},_optionSet:function(selector,val){var G3S="ected";var E3S="are";var y3S="lect";var V3S="nknown";var Z3S=":sel";var m4D=T8a;m4D+=V3S;var y4D=x4v;y4D+=j0d;y4D+=i4v;var E4D=U4r;E4D+=v6r;E4D+=Z3S;E4D+=G3S;var G4D=K3a;G4D+=b7r;var Z4D=N5d;Z4D+=u8a;var V4D=z3a;V4D+=E3S;V4D+=i4v;V4D+=a6a;var g4D=Q9a;g4D+=y3S;g4D+=B7n;var select=this[V1a][w1a][e8r](g4D + this[L5L.F4v][f1d] + J3r + selector);var span=select[V4D]()[a2n](M4d);select[Z4D](val);L5L.g5L();var selected=select[G4D](E4D);span[j4a](selected[j5a] !== R1v?selected[l0d]():this[L5L.F4v][y4D][m4D]);},_optionsTime:function(unit,count,val,allowed,range){var P3S="<table class";var h3S="Pm";var L2S="fl";var o1v=6;var b2S='<thead><tr><th colspan="';var x3S="</tr";var Q2S="oo";var K3S="amPm";var D3S="/t";var O2S="tr>";var j3S="lassPrefix";var U3S="r>";var m3S="/table>";var q3S="</th></tr></";var T3S="dy>";var N3S="tbo";var s2S='</tbody></thead><table class="';var k3S="<tb";var H2S='-nospace"><tbody>';var J3S="thead>";var H6v=u0a;H6v+=m3S;var s6v=F0a;s6v+=N3S;s6v+=H2n;s6v+=C0a;var Q6v=k3S;Q6v+=K4v;Q6v+=T3S;var L6v=q3S;L6v+=J3S;var O6v=v5a;O6v+=C0a;var K4D=P3S;K4D+=M7n;var U4D=e5r;U4D+=R2a;var J4D=j5r;J4D+=i4v;var q4D=I7d;q4D+=L5L.J4v;q4D+=D1a;var T4D=L5L.j4v;T4D+=x4v;T4D+=N3a;T4D+=B7n;var k4D=L5L.j4v;k4D+=K4v;k4D+=L5L.P4v;var N4D=L5L.F4v;N4D+=j3S;var classPrefix=this[L5L.F4v][N4D];var container=this[k4D][w1a][e8r](T4D + classPrefix + J3r + unit);var i,j;var render=count === D1v?function(i){return i;}:this[Y3S];var classPrefix=this[L5L.F4v][f1d];var className=classPrefix + q4D;var i18n=this[L5L.F4v][J4D];if(!container[j5a]){return;}var a=U9a;var span=x1v;var button=function(value,label,className){var w3S='-button ';var p3S="s=\"selec";var F3S="\" dat";var B3S="ton cl";var W3S="<td clas";var M3S="-day\" type=\"";var t3S="a-value=";var f3S=" d";var e3S="<sp";var d3S="button\" data-unit=\"";var d4D=e3S;d4D+=L5L.J4v;d4D+=i4v;d4D+=C0a;var M4D=F3S;M4D+=t3S;M4D+=v5a;var t4D=M3S;t4D+=d3S;var F4D=R3S;F4D+=B3S;F4D+=L5L.J4v;F4D+=N7n;var e4D=v5a;e4D+=C0a;var Y4D=W3S;Y4D+=p3S;Y4D+=A0n;Y4D+=x9a;var P4D=G0d;P4D+=P2a;if(count === D1v && val >= D1v && typeof value === j4n){value+=D1v;}var selected=val === value || value === H2d && val < D1v || value === b2d && val >= D1v?P4D:U9a;if(allowed && $[Z4n](value,allowed) === -B1v){var j4D=f3S;j4D+=o3S;j4D+=w6a;j4D+=i3S;selected+=j4D;}if(className){selected+=q7a + className;}return Y4D + selected + e4D + F4D + classPrefix + w3S + classPrefix + t4D + unit + M4D + value + Y7a + d4D + label + y8S + B7d + m8S;};if(count === D1v){var o4D=x3S;o4D+=C0a;var f4D=L5L.J4v;f4D+=L5L.P4v;f4D+=h3S;var p4D=z3a;p4D+=L5L.P4v;var W4D=u0a;W4D+=a6a;W4D+=D4v;W4D+=C0a;var B4D=u0a;B4D+=D3S;B4D+=D4v;B4D+=C0a;var R4D=u0a;R4D+=a6a;R4D+=U3S;a+=R4D;for(i=B1v;i <= o1v;i++){a+=button(i,render(i));}a+=button(H2d,i18n[K3S][R1v]);a+=B4D;a+=W4D;for(i=i1v;i <= D1v;i++){a+=button(i,render(i));}a+=button(p4D,i18n[f4D][B1v]);a+=o4D;span=i1v;}else if(count === s4v){var c=R1v;for(j=R1v;j < f1v;j++){var w4D=F0a;w4D+=V6n;w4D+=C0a;var i4D=u0a;i4D+=O2S;a+=i4D;for(i=R1v;i < o1v;i++){a+=button(c,render(c));c++;}a+=w4D;}span=o1v;}else {var D4D=u0a;D4D+=r0a;D4D+=O2S;var h4D=L2S;h4D+=Q2S;h4D+=D4v;a+=f8S;for(j=R1v;j < C4v;j+=x1v){var x4D=D4v;x4D+=v6S;a+=button(j,render(j),x4D);}a+=o8S;a+=s2S + className + q7a + className + H2S;var start=range !== O1a?range:Math[h4D](val / x1v) * x1v;a+=f8S;for(j=start + B1v;j < start + x1v;j++){a+=button(j,render(j));}a+=D4D;span=o1v;}container[U4D]()[O3n](K4D + className + O6v + b2S + span + Y7a + i18n[unit] + L6v + Q6v + a + s6v + H6v);},_optionsTitle:function(){var u2S="inDa";var I2S="_options";var r2S='year';var z2S="etFullYear";var a2S="range";var X2S='month';var v2S="yearRange";var I6v=a3a;I6v+=a2S;var v6v=C3a;v6v+=g8a;var u6v=L5L.P4v;u6v+=K4v;u6v+=y6S;u6v+=b3a;var z6v=N2a;z6v+=z2S;var a6v=L5L.P4v;a6v+=u2S;a6v+=a6a;a6v+=L5L.Y4v;var b6v=x4v;b6v+=v7a;b6v+=T9a;b6v+=i4v;var i18n=this[L5L.F4v][b6v];var min=this[L5L.F4v][a6v];var max=this[L5L.F4v][X1d];var minYear=min?min[R6S]():O1a;var maxYear=max?max[R6S]():O1a;var i=minYear !== O1a?minYear:new Date()[z6v]() - this[L5L.F4v][v2S];var j=maxYear !== O1a?maxYear:new Date()[R6S]() + this[L5L.F4v][v2S];this[I2S](X2S,this[c2S](R1v,h1v),i18n[u6v]);this[v6v](r2S,this[I6v](i,j));},_pad:function(i){L5L.g5L();var l2S='0';return i < x1v?l2S + i:i;},_position:function(){var A2S="Top";var V2S="ime";var Z2S='horizontal';var y2S='top';var n2S="outer";var C2S="ei";var G2S="remov";var S2S="uterWidth";var E2S="eClass";var g2S="Heig";var T6v=r2a;T6v+=x4v;T6v+=L5L.j4v;T6v+=U4n;var k6v=u8a;k6v+=I9a;k6v+=a6a;var y6v=q8a;y6v+=C2S;y6v+=k2n;y6v+=a6a;var E6v=h6S;E6v+=q1a;E6v+=A2S;var G6v=K4v;G6v+=S2S;var Z6v=n2S;Z6v+=g2S;Z6v+=q8a;Z6v+=a6a;var g6v=a6a;g6v+=V2S;var n6v=z3a;n6v+=L5L.J4v;n6v+=N3r;n6v+=b3a;var S6v=a5n;S6v+=D4v;S6v+=O3a;var A6v=o1d;A6v+=a6a;var C6v=L5L.j4v;C6v+=K4v;C6v+=L5L.P4v;var l6v=L5L.j4v;l6v+=W5a;var r6v=K4v;r6v+=u5n;var c6v=x4v;c6v+=Q4d;c6v+=a6a;var X6v=L5L.j4v;X6v+=K4v;X6v+=L5L.P4v;var offset=this[X6v][c6v][r6v]();var container=this[l6v][w1a];var inputHeight=this[C6v][A6v][E2n]();if(this[b3a][S6v][s1d] && this[b3a][n6v][g6v] && $(window)[P1n]() > Z4v){container[p1a](Z2S);}else {var V6v=G2S;V6v+=E2S;container[V6v](Z2S);}L5L.g5L();container[s1a]({top:offset[N5n] + inputHeight,left:offset[T1n]})[L1r](x1a);var calHeight=container[Z6v]();var calWidth=container[G6v]();var scrollTop=$(window)[E6v]();if(offset[N5n] + inputHeight + calHeight - scrollTop > $(window)[y6v]()){var N6v=L5L.F4v;N6v+=b3a;N6v+=b3a;var m6v=a6a;m6v+=A1a;var newTop=offset[m6v] - calHeight;container[N6v](y2S,newTop < R1v?R1v:newTop);}if(calWidth + offset[k6v] > $(window)[T6v]()){var J6v=u8a;J6v+=L5L.Y4v;J6v+=k1a;var q6v=L5L.F4v;q6v+=b3a;q6v+=b3a;var newLeft=$(window)[P1n]() - calWidth;container[q6v](J6v,newLeft < R1v?R1v:newLeft);}},_range:function(start,end,inc){var a=[];if(!inc){inc=B1v;}for(var i=start;i <= end;i+=inc){var P6v=z3a;P6v+=T8a;P6v+=c2a;a[P6v](i);}return a;},_setCalander:function(){var m2S="CMonth";var T2S="_htmlMonth";var k2S="ndar";var j6v=X1a;L5L.g5L();j6v+=z3a;j6v+=u8a;j6v+=q9n;if(this[b3a][j6v]){var F6v=N9a;F6v+=M8S;F6v+=m2S;var e6v=L5L.F4v;e6v+=N2S;e6v+=L5L.Y4v;e6v+=k2S;var Y6v=L5L.j4v;Y6v+=K4v;Y6v+=L5L.P4v;this[Y6v][e6v][A3S]()[O3n](this[T2S](this[b3a][j2a][j6S](),this[b3a][j2a][F6v]()));}},_setTitle:function(){var J2S="TCFullYear";var j2S="nSet";var e2S="ptio";var Y2S="_o";var P2S="_opt";var q2S="etU";var W6v=N2a;W6v+=q2S;L5L.r5L();W6v+=J2S;var B6v=B8a;B6v+=L5L.Y4v;B6v+=L5L.J4v;B6v+=D4v;var R6v=P2S;R6v+=x4v;R6v+=K4v;R6v+=j2S;var d6v=L5L.j4v;d6v+=x4v;d6v+=b3a;d6v+=t3r;var M6v=L5L.P4v;M6v+=n3a;M6v+=U4n;var t6v=Y2S;t6v+=e2S;t6v+=j2S;this[t6v](M6v,this[b3a][d6v][o6S]());this[R6v](B6v,this[b3a][j2a][W6v]());},_setTime:function(){var t2S="sTime";var F2S="seco";var B2S="vail";var M2S="minu";var h2S="getSeconds";var x2S="getUTCMinutes";var w2S="_optionsTime";var d2S="tes";var W2S="hou";var p2S="tUTC";var R2S="oursA";var K6v=X6S;K6v+=L5L.j4v;K6v+=b3a;var U6v=F2S;L5L.r5L();U6v+=y8a;U6v+=b3a;var D6v=S0r;D6v+=C7n;D6v+=t2S;var h6v=M2S;h6v+=d2S;var x6v=q8a;x6v+=R2S;x6v+=B2S;x6v+=I2r;var w6v=W2S;w6v+=C4d;w6v+=v7a;w6v+=p4v;var i6v=z3a;i6v+=L5L.J4v;i6v+=N3r;i6v+=b3a;var o6v=q8a;o6v+=x9n;o6v+=C4d;var p6v=U8r;p6v+=p2S;p6v+=l6S;var that=this;var d=this[b3a][L5L.j4v];var hours=d?d[p6v]():R1v;var allowed=function(prop){var i2S='Available';var f2S="In";var o2S="crem";var f6v=f2S;f6v+=o2S;f6v+=k3a;return that[L5L.F4v][prop + i2S]?that[L5L.F4v][prop + i2S]:that[c2S](R1v,l4v,that[L5L.F4v][prop + f6v]);};this[w2S](o6v,this[b3a][i6v][w6v]?D1v:s4v,hours,this[L5L.F4v][x6v]);this[w2S](b6S,C4v,d?d[x2S]():R1v,allowed(h6v),this[b3a][z6S]);this[D6v](U6v,C4v,d?d[h2S]():R1v,allowed(K6v),this[b3a][I6S]);},_show:function(){var O9S='scroll.';var s9S='div.dataTables_scrollBody';var U2S="namespace";var D2S="oll.";var L9S=' resize.';var K2S="_position";var z8v=K4v;z8v+=i4v;var b8v=t4r;b8v+=D4v;b8v+=D2S;var s8v=b3a;s8v+=P4n;s8v+=r8n;s8v+=i6S;var Q8v=K4v;Q8v+=i4v;var O8v=K4v;O8v+=i4v;var that=this;var namespace=this[b3a][U2S];this[K2S]();$(window)[O8v](O9S + namespace + L9S + namespace,function(){var L8v=Q3n;L8v+=u1d;that[L8v]();});$(y2n)[Q8v](s8v + namespace,function(){var Q9S="_hid";var H8v=Q9S;H8v+=L5L.Y4v;that[H8v]();});L5L.r5L();$(s9S)[n3a](b8v + namespace,function(){var a8v=a3a;a8v+=q8a;a8v+=x4v;a8v+=V8a;L5L.g5L();that[a8v]();});$(document)[z8v](U6S + namespace,function(e){var w1v=9;if(e[B4r] === w1v || e[B4r] === b4v || e[B4r] === U1v){that[y9n]();}});setTimeout(function(){var H9S='click.';L5L.r5L();$(x1a)[n3a](H9S + namespace,function(e){var b9S="arget";var I8v=O8n;I8v+=U4n;var v8v=L5L.j4v;L5L.g5L();v8v+=K4v;v8v+=L5L.P4v;var u8v=a6a;u8v+=b9S;var parents=$(e[u8v])[S5d]();if(!parents[f9d](that[v8v][w1a])[I8v] && e[o8r] !== that[V1a][w1d][R1v]){var X8v=a3a;X8v+=m2a;X8v+=L5L.Y4v;that[X8v]();}});},x1v);},_writeOutput:function(focus){var u9S="entStrict";var v9S="ale";var I9S="utc";var a9S="Date";var n8v=x4v;n8v+=g4a;var S8v=U8r;S8v+=a6a;L5L.g5L();S8v+=d6S;S8v+=a9S;var A8v=a3a;A8v+=a5n;A8v+=L5L.j4v;var C8v=K3a;C8v+=z9S;var l8v=X7n;l8v+=a7d;var r8v=y1d;r8v+=u9S;var c8v=X8a;c8v+=N1d;c8v+=v9S;var date=this[b3a][L5L.j4v];var out=window[G1d]?window[G1d][I9S](date,undefined,this[L5L.F4v][c8v],this[L5L.F4v][r8v])[l8v](this[L5L.F4v][C8v]):date[j6S]() + J3r + this[Y3S](date[o6S]() + B1v) + J3r + this[A8v](date[S8v]());this[V1a][n8v][g1a](out);if(focus){var V8v=f8d;V8v+=b3a;var g8v=L5L.j4v;g8v+=K4v;g8v+=L5L.P4v;this[g8v][w1d][V8v]();}}});Editor[H7d][Z8v]=R1v;Editor[G8v][p5r]={classPrefix:X9S,disableDays:O1a,firstDay:B1v,format:c9S,hoursAvailable:O1a,i18n:Editor[p5r][S2r][r9S],maxDate:O1a,minDate:O1a,minutesAvailable:O1a,minutesIncrement:B1v,momentStrict:e5a,momentLocale:E8v,onChange:function(){},secondsAvailable:O1a,secondsIncrement:B1v,showWeekNumber:Y5a,yearRange:x1v};(function(){var B5S='text';var k1S="_picker";var C9S="oad";var p5S="_i";var b1S="datepicker";var S9S="den";var V7S="checked";var I0S="air";var h7S="datepicke";var y7S="radio";var g9S="dType";var K0S='_';var A9S="passw";var C1S="bled";var Y0S="separator";var l9S="ploadMany";var x5S="<inp";var T9S="File";var H4S="_v";L5L.r5L();var g0S="_addOptions";var O7S='input:last';var a7S='<div />';var D7S="sa";var p0S='input';var a4S='div.rendered';var n0S="_lastSet";var b4S="ad.edi";var F5S="readonly";var j5S="prop";var e5S="_val";var t7S="cked";var W5S="_inpu";var d5S='<input/>';var G7S="dO";var V4S="_container";var Q5S="_input";var D5S="textarea";var R5S="safeId";var j1S='keydown';var m4S="uploadMany";var n9S="ldTy";var L0S="disab";var l5S="_ena";var W0S="checkbox";var u0S="_editor_val";var s5S="_enabled";var X0S="ip";var f5S="_inp";var j7v=T8a;j7v+=l9S;var H7v=T8a;H7v+=z3a;H7v+=u8a;H7v+=C9S;var j5v=Z9a;j5v+=a6a;j5v+=L5L.Y4v;var i9v=L5L.Y4v;i9v+=D2a;i9v+=l6a;i9v+=y8a;var s9v=F2r;s9v+=y8a;var r2v=D4n;r2v+=L5L.j4v;var Q2v=A9S;Q2v+=K4v;Q2v+=l2a;var w3v=D4n;w3v+=L5L.j4v;var R3v=m2a;R3v+=S9S;var Y3v=T2a;Y3v+=n9S;Y3v+=L6a;var j3v=X8a;j3v+=V8a;j3v+=Z8a;var y8v=q6n;y8v+=x6a;y8v+=g9S;y8v+=b3a;var fieldTypes=Editor[y8v];function _buttonText(conf,text){var E9S='div.upload button';var Z9S="...";var V9S="Choose file";var G9S="uploadText";var N8v=a3a;N8v+=w1d;if(text === O1a || text === undefined){var m8v=V9S;m8v+=Z9S;text=conf[G9S] || m8v;}conf[N8v][e8r](E9S)[j4a](text);}function _commonUpload(editor,conf,dropCallback,multiple){var T5S="ddCl";var Y9S="s=\"cell\">";var r5S='drop';var f9S="<div ";var H5S="safeI";var I5S="pTe";var t9S=" cla";var k5S="noDr";var i9S="ditor_upload\"";var m9S="lea";var X5S="op s";var c5S="Drag and drop a file here to upload";var B9S="<div class=\"e";var d9S="cond\">";var q9S="Re";var F9S="ide\">";var u5S="div.d";var N9S="rValue butt";var D9S='multiple';var z5S="agexit";var U9S='/>';var n5S='dragover';var p9S="le\">";var o9S="class=\"e";var y9S="div.c";var P9S="/di";var k9S="dragDr";var b5S='input[type=file]';var J9S="ader";var v5S="dragDro";var M9S="ss=\"row se";var L5S='<div class="rendered"/>';var O5S='<div class="drop"><span/></div>';var a5S="dragleave dr";var W9S="u_ta";var j9S="</div";var x9S='<div class="cell upload limitHide">';var h9S='<input type="file" ';var w9S="buttonInternal";var e9S="v class=\"cell limitH";var N5S=".rendered";var K9S='<div class="cell clearValue">';var R9S="ton ";var q3v=K4v;q3v+=i4v;var T3v=K3a;T3v+=x4v;T3v+=i4v;T3v+=L5L.j4v;var m3v=Y2n;m3v+=x4v;m3v+=L5L.F4v;m3v+=o6n;var y3v=K4v;y3v+=i4v;var E3v=y9S;E3v+=m9S;E3v+=N9S;E3v+=n3a;var U8v=k9S;U8v+=K4v;U8v+=z3a;var D8v=T9S;D8v+=q9S;D8v+=J9S;var w8v=L5L.J4v;w8v+=a6a;w8v+=a6a;w8v+=D4v;var p8v=x4v;p8v+=L5L.j4v;var W8v=u0a;W8v+=P9S;W8v+=N3a;W8v+=C0a;var B8v=j9S;B8v+=C0a;var R8v=X0a;R8v+=c0a;var d8v=P8n;d8v+=Y9S;var M8v=S0a;M8v+=e9S;M8v+=F9S;var t8v=y7n;t8v+=t9S;t8v+=M9S;t8v+=d9S;var F8v=F0a;F8v+=L5L.j4v;F8v+=c0a;var e8v=v8S;e8v+=I8S;var Y8v=u0a;Y8v+=r0a;Y8v+=L5L.j4v;Y8v+=c0a;var j8v=J7n;j8v+=r0a;j8v+=C0a;var P8v=R3S;P8v+=R9S;P8v+=x1n;P8v+=q0a;var J8v=X9n;J8v+=M7n;J8v+=H2a;J8v+=z0a;var q8v=B9S;q8v+=W9S;q8v+=w6a;q8v+=p9S;var T8v=f9S;T8v+=o9S;T8v+=i9S;T8v+=C0a;var k8v=X7n;k8v+=T4n;var btnClass=editor[O4a][k8v][w9S];var container=$(T8v + q8v + J8v + x9S + P8v + btnClass + j8v + h9S + (multiple?D9S:U9a) + U9S + Y8v + K9S + e8v + btnClass + h7n + M7a + F8v + t8v + M8v + O5S + M7a + d8v + L5S + R8v + M7a + B8v + W8v);conf[Q5S]=container;conf[s5S]=e5a;if(conf[p8v]){var i8v=x4v;i8v+=L5L.j4v;var o8v=H5S;o8v+=L5L.j4v;var f8v=q6n;f8v+=y8a;container[f8v](b5S)[o9d](b3d,Editor[o8v](conf[i8v]));}if(conf[w8v]){var h8v=L5L.J4v;h8v+=a6a;h8v+=V6n;var x8v=L5L.J4v;x8v+=A1n;x8v+=D4v;container[e8r](b5S)[x8v](conf[h8v]);}_buttonText(conf);if(window[D8v] && conf[U8v] !== Y5a){var n3v=L5L.F4v;n3v+=u8a;n3v+=t3a;n3v+=L5L.Y4v;var S3v=K4v;S3v+=i4v;var l3v=A1a;l3v+=V7n;var u3v=a5S;u3v+=z5S;var s3v=K4v;s3v+=i4v;var Q3v=u5S;Q3v+=D4v;Q3v+=A1a;var L3v=v5S;L3v+=I5S;L3v+=D2a;L3v+=a6a;var O3v=a6a;O3v+=L5L.Y4v;O3v+=D2a;O3v+=a6a;var K8v=V1n;K8v+=g7n;K8v+=X5S;K8v+=d0a;container[e8r](K8v)[O3v](conf[L3v] || c5S);var dragDrop=container[e8r](Q3v);dragDrop[s3v](r5S,function(e){var C5S="ginalEv";var A5S="dataTransfer";var H3v=l5S;H3v+=i2a;H3v+=P2a;L5L.r5L();if(conf[H3v]){var z3v=G6n;z3v+=L5L.Y4v;z3v+=D4v;var a3v=A9a;a3v+=x4v;a3v+=C5S;a3v+=k3a;var b3v=T8a;b3v+=b9r;Editor[b3v](editor,conf,e[a3v][A5S][A5a],_buttonText,dropCallback);dragDrop[v4a](z3v);}return Y5a;})[n3a](u3v,function(e){var S5S="moveClas";var v3v=j6r;v3v+=i4v;v3v+=c1a;if(conf[v3v]){var X3v=K4v;X3v+=y0n;var I3v=u3a;I3v+=S5S;I3v+=b3a;dragDrop[I3v](X3v);}return Y5a;})[n3a](n5S,function(e){var g5S="_enabl";var Z5S='over';var V5S="Cla";L5L.g5L();var c3v=g5S;c3v+=P2a;if(conf[c3v]){var r3v=g2d;r3v+=L5L.j4v;r3v+=V5S;r3v+=x0a;dragDrop[r3v](Z5S);}return Y5a;});editor[n3a](l3v,function(){var G5S="dragover.DTE_Upl";var y5S="Upload";var E5S="oad drop.DTE_";var A3v=G5S;A3v+=E5S;A3v+=y5S;var C3v=K4v;C3v+=i4v;$(x1a)[C3v](A3v,function(e){L5L.r5L();return Y5a;});})[S3v](n3v,function(){var m5S='dragover.DTE_Upload drop.DTE_Upload';$(x1a)[E5n](m5S);});}else {var G3v=L5L.j4v;G3v+=x4v;G3v+=N3a;G3v+=N5S;var Z3v=n3n;Z3v+=z3a;Z3v+=V7n;Z3v+=L5L.j4v;var V3v=k5S;V3v+=A1a;var g3v=L5L.J4v;g3v+=T5S;g3v+=L5L.J4v;g3v+=x0a;container[g3v](V3v);container[Z3v](container[e8r](G3v));}container[e8r](E3v)[y3v](m3v,function(e){var q5S="entDefault";var N3v=X4n;L5L.g5L();N3v+=q5S;e[N3v]();if(conf[s5S]){var k3v=L5L.F4v;k3v+=B7r;Editor[C7a][o2r][l8n][k3v](editor,conf,U9a);}});container[T3v](b5S)[q3v](O6r,function(){Editor[o2r](editor,conf,this[A5a],_buttonText,function(ids){var J5S="t[typ";var P5S="e=file]";var P3v=N3a;P3v+=L5L.J4v;P3v+=u8a;var J3v=x4v;L5L.r5L();J3v+=Q4d;J3v+=J5S;J3v+=P5S;dropCallback[z4n](editor,ids);container[e8r](J3v)[P3v](U9a);});});return container;}function _triggerChange(input){L5L.r5L();setTimeout(function(){input[y0r](O6r,{editor:e5a,editorSet:e5a});L5L.g5L();;},R1v);}var baseFieldType=$[I7a](e5a,{},Editor[j3v][Y3v],{get:function(conf){var e3v=u7d;e3v+=z3a;e3v+=T8a;e3v+=a6a;return conf[e3v][g1a]();},set:function(conf,val){var M3v=a3a;M3v+=f0a;M3v+=T8a;M3v+=a6a;var t3v=N3a;t3v+=L5L.J4v;t3v+=u8a;var F3v=u7d;F3v+=z3a;F3v+=a1d;conf[F3v][t3v](val);_triggerChange(conf[M3v]);},enable:function(conf){conf[Q5S][j5S](a6S,Y5a);},disable:function(conf){var d3v=U4v;d3v+=K4v;d3v+=z3a;conf[Q5S][d3v](a6S,e5a);},canReturnSubmit:function(conf,node){return e5a;}});fieldTypes[R3v]={create:function(conf){var Y5S="alu";var W3v=N3a;W3v+=Y5S;L5L.r5L();W3v+=L5L.Y4v;var B3v=a3a;B3v+=g1a;conf[B3v]=conf[W3v];return O1a;},get:function(conf){L5L.r5L();return conf[e5S];},set:function(conf,val){conf[e5S]=val;}};fieldTypes[F5S]=$[I7a](e5a,{},baseFieldType,{create:function(conf){var t5S="read";var M5S="nl";var i3v=L5L.J4v;i3v+=a6a;i3v+=V6n;var o3v=t5S;o3v+=K4v;o3v+=M5S;o3v+=B8a;var f3v=x4v;f3v+=L5L.j4v;var p3v=L5L.Y4v;p3v+=H6a;p3v+=V7n;p3v+=L5L.j4v;conf[Q5S]=$(d5S)[o9d]($[p3v]({id:Editor[R5S](conf[f3v]),type:B5S,readonly:o3v},conf[i3v] || ({})));return conf[Q5S][R1v];}});fieldTypes[l0d]=$[w3v](e5a,{},baseFieldType,{create:function(conf){var L2v=W5S;L2v+=a6a;var O2v=L7a;O2v+=a6a;O2v+=D4v;var K3v=a6a;K3v+=L5L.Y4v;K3v+=D2a;K3v+=a6a;var U3v=x4v;U3v+=L5L.j4v;var D3v=L5L.Y4v;D3v+=B2r;D3v+=i4v;D3v+=L5L.j4v;var h3v=d2d;h3v+=D4v;var x3v=p5S;x3v+=b1d;x3v+=a1d;conf[x3v]=$(d5S)[h3v]($[D3v]({id:Editor[R5S](conf[U3v]),type:K3v},conf[O2v] || ({})));return conf[L2v][R1v];}});fieldTypes[Q2v]=$[I7a](e5a,{},baseFieldType,{create:function(conf){var w5S="eId";var o5S="pas";var i5S="sword";var h5S="ut/";var v2v=f5S;v2v+=T8a;v2v+=a6a;var u2v=L5L.J4v;u2v+=A1n;u2v+=D4v;var z2v=o5S;z2v+=i5S;var a2v=b3a;a2v+=w3a;a2v+=w5S;var b2v=b6a;b2v+=z7r;var H2v=x5S;H2v+=h5S;L5L.r5L();H2v+=C0a;var s2v=a3a;s2v+=f0a;s2v+=a1d;conf[s2v]=$(H2v)[o9d]($[b2v]({id:Editor[a2v](conf[A7a]),type:z2v},conf[u2v] || ({})));return conf[v2v][R1v];}});fieldTypes[D5S]=$[I7a](e5a,{},baseFieldType,{create:function(conf){var U5S="<textarea/";var c2v=L5L.J4v;c2v+=a6a;c2v+=a6a;c2v+=D4v;var X2v=d2d;X2v+=D4v;var I2v=U5S;I2v+=C0a;conf[Q5S]=$(I2v)[X2v]($[I7a]({id:Editor[R5S](conf[A7a])},conf[c2v] || ({})));L5L.r5L();return conf[Q5S][R1v];},canReturnSubmit:function(conf,node){return Y5a;}});fieldTypes[G0d]=$[r2v](e5a,{},baseFieldType,{_addOptions:function(conf,opts,append){var z0S="hidden";var H0S="cehol";var b0S="erValue";var O0S="lder";var K5S="placeho";var Q0S="placehol";var a0S="placeholderDisabled";var s0S="lderValue";var v0S="optionsPai";var l2v=u7d;l2v+=X1r;l2v+=a6a;var elOpts=conf[l2v][R1v][D4r];var countOffset=R1v;if(!append){var C2v=K5S;C2v+=O0S;elOpts[j5a]=R1v;if(conf[C2v] !== undefined){var g2v=L0S;g2v+=i3S;var n2v=Q0S;n2v+=k3r;var S2v=K5S;S2v+=s0S;var A2v=b9n;A2v+=H0S;A2v+=L5L.j4v;A2v+=b0S;var placeholderValue=conf[A2v] !== undefined?conf[S2v]:U9a;countOffset+=B1v;elOpts[R1v]=new Option(conf[n2v],placeholderValue);var disabled=conf[a0S] !== undefined?conf[a0S]:e5a;elOpts[R1v][z0S]=disabled;elOpts[R1v][g2v]=disabled;elOpts[R1v][u0S]=placeholderValue;}}else {countOffset=elOpts[j5a];}if(opts){var Z2v=v0S;Z2v+=D4v;var V2v=z3a;V2v+=I0S;V2v+=b3a;Editor[V2v](opts,conf[Z2v],function(val,label,i,attr){var option=new Option(label,val);option[u0S]=val;L5L.r5L();if(attr){var G2v=L5L.J4v;G2v+=a6a;G2v+=V6n;$(option)[G2v](attr);}elOpts[i + countOffset]=option;});}},create:function(conf){var A0S="ect/";var C0S="<sel";var r0S="hange.dte";var c0S="pts";var l0S="ple";var e2v=X0S;e2v+=j8a;e2v+=c0S;var Y2v=K4v;Y2v+=z3a;Y2v+=c4d;Y2v+=g8a;var j2v=Q9a;j2v+=u8a;j2v+=P2d;var q2v=L5L.F4v;q2v+=r0S;var T2v=K4v;T2v+=i4v;var k2v=L7a;k2v+=V6n;var N2v=h6n;N2v+=a6a;N2v+=x4v;N2v+=l0S;var m2v=b6a;m2v+=l6a;m2v+=y8a;var y2v=C0S;y2v+=A0S;y2v+=C0a;var E2v=u7d;E2v+=z3a;E2v+=a1d;conf[E2v]=$(y2v)[o9d]($[m2v]({id:Editor[R5S](conf[A7a]),multiple:conf[N2v] === e5a},conf[k2v] || ({})))[T2v](q2v,function(e,d){var S0S="lec";if(!d || !d[z0r]){var P2v=U8r;P2v+=a6a;var J2v=b3a;J2v+=L5L.Y4v;J2v+=S0S;J2v+=a6a;conf[n0S]=fieldTypes[J2v][P2v](conf);}});fieldTypes[j2v][g0S](conf,conf[Y2v] || conf[e2v]);return conf[Q5S][R1v];},update:function(conf,options,append){var Z0S="tSet";var E0S="elect";var G0S="_addOpti";var V0S="_la";var M2v=V0S;M2v+=b3a;M2v+=Z0S;var t2v=G0S;t2v+=K4v;L5L.r5L();t2v+=i4v;t2v+=b3a;var F2v=b3a;F2v+=E0S;fieldTypes[F2v][t2v](conf,options,append);var lastSet=conf[M2v];if(lastSet !== undefined){var d2v=Q9a;d2v+=a6a;fieldTypes[G0d][d2v](conf,lastSet,e5a);}_triggerChange(conf[Q5S]);},get:function(conf){var N0S="electe";var y0S="ultiple";var k0S="separato";var m0S="option:s";var q0S="parator";var T0S="oi";var p2v=L5L.P4v;p2v+=y0S;var W2v=m0S;W2v+=N0S;W2v+=L5L.j4v;var B2v=K3a;B2v+=x4v;B2v+=i4v;B2v+=L5L.j4v;var R2v=W5S;R2v+=a6a;var val=conf[R2v][B2v](W2v)[T6r](function(){L5L.g5L();return this[u0S];})[y5d]();if(conf[p2v]){var i2v=k0S;i2v+=D4v;var o2v=J5a;o2v+=T0S;o2v+=i4v;var f2v=Q9a;f2v+=q0S;return conf[f2v]?val[o2v](conf[i2v]):val;}L5L.r5L();return val[j5a]?val[R1v]:O1a;},set:function(conf,val,localUpdate){var t0S="split";var e0S="ep";var R0S="cted";var M0S='option';var J0S="ultip";var d0S="sele";var F0S="ara";var j0S="ltiple";var P0S="aceholder";var K2v=L5L.P4v;K2v+=J0S;K2v+=S6a;var U2v=I9d;U2v+=P0S;var D2v=f5S;D2v+=a1d;var x2v=F0r;x2v+=r7r;x2v+=L5L.J4v;x2v+=B8a;var w2v=L5L.P4v;w2v+=T8a;w2v+=j0S;if(!localUpdate){conf[n0S]=val;}if(conf[w2v] && conf[Y0S] && !$[x2v](val)){var h2v=b3a;h2v+=e0S;h2v+=F0S;h2v+=i0d;val=typeof val === A4n?val[t0S](conf[h2v]):[];}else if(!$[X6n](val)){val=[val];}var i,len=val[j5a],found,allFound=Y5a;var options=conf[Q5S][e8r](M0S);conf[D2v][e8r](M0S)[y1a](function(){found=Y5a;for(i=R1v;i < len;i++){if(this[u0S] == val[i]){found=e5a;allFound=e5a;break;}}L5L.r5L();this[n8S]=found;});if(conf[U2v] && !allFound && !conf[K2v] && options[j5a]){var O9v=d0S;O9v+=R0S;options[R1v][O9v]=e5a;}if(!localUpdate){_triggerChange(conf[Q5S]);}return allFound;},destroy:function(conf){var B0S='change.dte';var Q9v=K4v;Q9v+=K3a;Q9v+=K3a;var L9v=W5S;L9v+=a6a;conf[L9v][Q9v](B0S);}});fieldTypes[W0S]=$[s9v](e5a,{},baseFieldType,{_addOptions:function(conf,opts,append){var f0S="pairs";var H9v=a3a;H9v+=f0a;H9v+=a1d;var val,label;var jqInput=conf[H9v];var offset=R1v;L5L.g5L();if(!append){var b9v=F1n;b9v+=z3a;b9v+=R2a;jqInput[b9v]();}else {offset=$(p0S,jqInput)[j5a];}if(opts){var a9v=K4v;a9v+=O6d;a9v+=M0r;a9v+=I0S;Editor[f0S](opts,conf[a9v],function(val,label,i,attr){var h0S="<inpu";var D0S="t ";var L7S="t:la";var U0S="d=\"";var i0S="for=\"";var o0S="<label ";var x0S="checkbox\" />";var w0S="\" type=\"";var C9v=L5L.J4v;C9v+=a6a;C9v+=V6n;var l9v=F0a;l9v+=t0a;var r9v=v5a;r9v+=C0a;var c9v=o0S;c9v+=i0S;var X9v=w0S;X9v+=x0S;var I9v=x4v;I9v+=L5L.j4v;var v9v=h0S;v9v+=D0S;v9v+=x4v;v9v+=U0S;var u9v=S0a;u9v+=N3a;u9v+=C0a;var z9v=i8n;z9v+=J4a;jqInput[z9v](u9v + v9v + Editor[R5S](conf[I9v]) + K0S + (i + offset) + X9v + c9v + Editor[R5S](conf[A7a]) + K0S + (i + offset) + r9v + label + d7a + l9v);$(O7S,jqInput)[C9v](W2r,val)[R1v][u0S]=val;if(attr){var A9v=o1d;A9v+=L7S;A9v+=L6n;$(A9v,jqInput)[o9d](attr);}});}},create:function(conf){var H7S="ddOptions";var b7S="eckbox";var s7S="_a";var z7S="ipOpts";var Q7S="ption";var Z9v=f5S;Z9v+=a1d;var V9v=K4v;V9v+=Q7S;V9v+=b3a;var g9v=s7S;g9v+=H7S;var n9v=f4a;n9v+=b7S;var S9v=p5S;S9v+=i4v;S9v+=Q0a;conf[S9v]=$(a7S);fieldTypes[n9v][g9v](conf,conf[V9v] || conf[z7S]);return conf[Z9v][R1v];},get:function(conf){var C7S="ted";var c7S='input:checked';var u7S="arator";var v7S="separa";var I7S="unsel";var l7S="unselec";var X7S="dValue";var A7S="Value";var T9v=Q9a;T9v+=z3a;T9v+=u7S;var k9v=J5a;k9v+=K4v;k9v+=x4v;k9v+=i4v;var N9v=v7S;N9v+=h4v;N9v+=D4v;var y9v=I7S;y9v+=P2d;y9v+=L5L.Y4v;y9v+=X7S;var G9v=q6n;G9v+=i4v;L5L.g5L();G9v+=L5L.j4v;var out=[];var selected=conf[Q5S][G9v](c7S);if(selected[j5a]){selected[y1a](function(){var r7S="or_val";var E9v=j6r;E9v+=Y0n;E9v+=r7S;out[C5a](this[E9v]);});}else if(conf[y9v] !== undefined){var m9v=l7S;m9v+=C7S;m9v+=A7S;out[C5a](conf[m9v]);}return conf[N9v] === undefined || conf[Y0S] === O1a?out:out[k9v](conf[T9v]);},set:function(conf,val){var n7S="parat";var S7S="ri";var g7S='|';var t9v=u8a;t9v+=L5L.Y4v;t9v+=k9d;t9v+=q8a;var F9v=x4v;F9v+=b3a;F9v+=F6n;F9v+=t0r;L5L.g5L();var j9v=L6n;j9v+=S7S;j9v+=k9r;var P9v=L0a;P9v+=z3a;P9v+=T8a;P9v+=a6a;var J9v=K3a;J9v+=x4v;J9v+=i4v;J9v+=L5L.j4v;var q9v=f5S;q9v+=a1d;var jqInputs=conf[q9v][J9v](P9v);if(!$[X6n](val) && typeof val === j9v){var e9v=Q9a;e9v+=n7S;e9v+=A9a;var Y9v=b3a;Y9v+=I9d;Y9v+=H9a;val=val[Y9v](conf[e9v] || g7S);}else if(!$[F9v](val)){val=[val];}var i,len=val[t9v],found;jqInputs[y1a](function(){found=Y5a;for(i=R1v;i < len;i++){if(this[u0S] == val[i]){found=e5a;break;}}this[V7S]=found;});_triggerChange(jqInputs);},enable:function(conf){var R9v=z3a;R9v+=D4v;R9v+=K4v;R9v+=z3a;var d9v=x4v;d9v+=b1d;d9v+=a1d;var M9v=a3a;M9v+=L0a;M9v+=z3a;M9v+=a1d;conf[M9v][e8r](d9v)[R9v](a6S,Y5a);},disable:function(conf){var W9v=x4v;W9v+=i4v;W9v+=X1r;W9v+=a6a;var B9v=a3a;B9v+=w1d;conf[B9v][e8r](W9v)[j5S](a6S,e5a);},update:function(conf,options,append){var Z7S="_ad";var E7S="tions";var o9v=b3a;L5L.g5L();o9v+=L5L.Y4v;o9v+=a6a;var f9v=Z7S;f9v+=G7S;f9v+=z3a;f9v+=E7S;var p9v=N2a;p9v+=L5L.Y4v;p9v+=a6a;var checkbox=fieldTypes[W0S];var currVal=checkbox[p9v](conf);checkbox[f9v](conf,options,append);checkbox[o9v](conf,currVal);}});fieldTypes[y7S]=$[i9v](e5a,{},baseFieldType,{_addOptions:function(conf,opts,append){var m7S="pai";var N7S="optionsPair";var val,label;var jqInput=conf[Q5S];var offset=R1v;if(!append){jqInput[A3S]();}else {offset=$(p0S,jqInput)[j5a];}if(opts){var w9v=m7S;w9v+=C4d;Editor[w9v](opts,conf[N7S],function(val,label,i,attr){var q7S="<la";var Y7S='<div>';var P7S="or=\"";var j7S="ut id";L5L.g5L();var e7S='" type="radio" name="';var k7S="</labe";var J7S=" f";var T7S="l>";var s5v=N3a;s5v+=s8n;var Q5v=u0a;Q5v+=T7n;var L5v=k7S;L5v+=T7S;var O5v=x4v;O5v+=L5L.j4v;var K9v=q7S;K9v+=U1n;K9v+=J7S;K9v+=P7S;var U9v=H7a;U9v+=L5L.P4v;U9v+=L5L.Y4v;var D9v=x4v;D9v+=L5L.j4v;var h9v=x5S;h9v+=j7S;h9v+=M7n;var x9v=L5L.J4v;x9v+=z3a;x9v+=L6a;x9v+=y8a;jqInput[x9v](Y7S + h9v + Editor[R5S](conf[D9v]) + K0S + (i + offset) + e7S + conf[U9v] + h7n + K9v + Editor[R5S](conf[O5v]) + K0S + (i + offset) + Y7a + label + L5v + Q5v);$(O7S,jqInput)[o9d](s5v,val)[R1v][u0S]=val;if(attr){$(O7S,jqInput)[o9d](attr);}});}},create:function(conf){var X5v=p5S;X5v+=g4a;var z5v=K4v;z5v+=i4v;L5L.r5L();var a5v=X0S;a5v+=t6r;a5v+=a6a;a5v+=b3a;var b5v=a3a;b5v+=g2d;b5v+=G7S;b5v+=O6d;var H5v=a3a;H5v+=x4v;H5v+=Q4d;H5v+=a6a;conf[H5v]=$(a7S);fieldTypes[y7S][b5v](conf,conf[D4r] || conf[a5v]);this[z5v](k6r,function(){var v5v=L5L.Y4v;v5v+=D6r;var u5v=W5S;u5v+=a6a;conf[u5v][e8r](p0S)[v5v](function(){var F7S="_preChe";var I5v=F7S;L5L.g5L();I5v+=t7S;if(this[I5v]){this[V7S]=e5a;}});});return conf[X5v][R1v];},get:function(conf){var M7S="itor";var d7S="ut:checke";var l5v=a3a;l5v+=P2a;l5v+=M7S;l5v+=e5S;var r5v=f0a;r5v+=d7S;r5v+=L5L.j4v;var c5v=K3a;c5v+=x4v;c5v+=i4v;c5v+=L5L.j4v;var el=conf[Q5S][c5v](r5v);return el[j5a]?el[R1v][l5v]:undefined;},set:function(conf,val){var R7S=":che";var B7S="ked";var Z5v=w1d;Z5v+=R7S;Z5v+=L5L.F4v;Z5v+=B7S;var C5v=K3a;C5v+=x4v;C5v+=y8a;var that=this;conf[Q5S][C5v](p0S)[y1a](function(){L5L.r5L();var p7S="preChecked";var f7S="che";var i7S="reChecked";var o7S="_preChecked";var W7S="editor_";var S5v=a3a;S5v+=W7S;S5v+=N3a;S5v+=N2S;var A5v=a3a;A5v+=p7S;this[A5v]=Y5a;if(this[S5v] == val){var n5v=f7S;n5v+=t7S;this[n5v]=e5a;this[o7S]=e5a;}else {var V5v=I4d;V5v+=i7S;var g5v=f7S;g5v+=L5L.F4v;g5v+=o6n;g5v+=P2a;this[g5v]=Y5a;this[V5v]=Y5a;}});_triggerChange(conf[Q5S][e8r](Z5v));},enable:function(conf){var w7S="sable";var y5v=L5L.j4v;y5v+=x4v;y5v+=w7S;y5v+=L5L.j4v;var E5v=x4v;E5v+=Q4d;E5v+=a6a;var G5v=K3a;G5v+=x4v;L5L.r5L();G5v+=y8a;conf[Q5S][G5v](E5v)[j5S](y5v,Y5a);},disable:function(conf){var T5v=X1a;T5v+=g0n;T5v+=i3S;var k5v=L0a;k5v+=z3a;k5v+=T8a;k5v+=a6a;var N5v=K3a;N5v+=x4v;N5v+=i4v;N5v+=L5L.j4v;var m5v=a3a;m5v+=x4v;m5v+=Q4d;m5v+=a6a;conf[m5v][N5v](k5v)[j5S](T5v,e5a);},update:function(conf,options,append){var x7S='[value="';var P5v=v5a;P5v+=I5a;var J5v=k2a;J5v+=a6a;J5v+=L5L.Y4v;J5v+=D4v;var q5v=u7d;q5v+=Q0a;var radio=fieldTypes[y7S];var currVal=radio[N9a](conf);radio[g0S](conf,options,append);var inputs=conf[q5v][e8r](p0S);radio[l8n](conf,inputs[J5v](x7S + currVal + P5v)[j5a]?currVal:inputs[O1n](R1v)[o9d](W2r));}});fieldTypes[j5v]=$[I7a](e5a,{},baseFieldType,{create:function(conf){var L1S="dateFormat";var H1S="dateF";var s1S="_2822";var Q1S="R";var U7S="fe";var K7S="ut ";var u1S='date';var O1S='jqueryui';var D5v=p5S;D5v+=i4v;D5v+=z3a;D5v+=a1d;var d5v=h7S;d5v+=D4v;var M5v=a6a;M5v+=b0a;var t5v=x4v;t5v+=L5L.j4v;var F5v=D7S;F5v+=U7S;F5v+=x3a;var e5v=u0a;e5v+=f0a;e5v+=K7S;e5v+=P7n;var Y5v=p5S;Y5v+=i4v;Y5v+=X1r;Y5v+=a6a;conf[Y5v]=$(e5v)[o9d]($[I7a]({id:Editor[F5v](conf[t5v]),type:M5v},conf[o9d]));if($[d5v]){conf[Q5S][p1a](O1S);if(!conf[L1S]){var B5v=Q1S;B5v+=l9a;B5v+=t6d;B5v+=s1S;var R5v=H1S;R5v+=z9S;conf[R5v]=$[b1S][B5v];}setTimeout(function(){var z1S='#ui-datepicker-div';var a1S="dateImage";var w5v=i4v;w5v+=K4v;w5v+=i4v;w5v+=L5L.Y4v;var i5v=X1a;i5v+=z3a;i5v+=u8a;i5v+=q9n;var o5v=L5L.F4v;o5v+=b3a;o5v+=b3a;var f5v=U4r;f5v+=b3a;var W5v=a3a;W5v+=x4v;W5v+=Q4d;W5v+=a6a;$(conf[W5v])[b1S]($[I7a]({dateFormat:conf[L1S],buttonImage:conf[a1S],buttonImageOnly:e5a,onSelect:function(){var p5v=L5L.F4v;p5v+=g4n;p5v+=L5L.F4v;p5v+=o6n;conf[Q5S][y3r]()[p5v]();}},conf[f5v]));$(z1S)[o5v](i5v,w5v);},x1v);}else {var h5v=a6a;h5v+=f3a;var x5v=u7d;x5v+=Q0a;conf[x5v][o9d](h5v,u1S);}return conf[D5v][R1v];},set:function(conf,val){var v1S="asClas";var c1S="ick";L5L.g5L();var I1S='hasDatepicker';var X1S="datep";var r1S="setDate";var U5v=q8a;U5v+=v1S;U5v+=b3a;if($[b1S] && conf[Q5S][U5v](I1S)){var L0v=f4a;L0v+=Z3n;L0v+=N2a;L0v+=L5L.Y4v;var O0v=X1S;O0v+=c1S;O0v+=L5L.Y4v;O0v+=D4v;var K5v=a3a;K5v+=w1d;conf[K5v][O0v](r1S,val)[L0v]();}else {var s0v=N5d;s0v+=u8a;var Q0v=a3a;Q0v+=f0a;Q0v+=T8a;Q0v+=a6a;$(conf[Q0v])[s0v](val);}},enable:function(conf){L5L.g5L();if($[b1S]){var H0v=V7n;H0v+=g0n;H0v+=S6a;conf[Q5S][b1S](H0v);}else {var a0v=z3a;a0v+=w2a;a0v+=z3a;var b0v=p5S;b0v+=i4v;b0v+=Q0a;$(conf[b0v])[a0v](a6S,Y5a);}},disable:function(conf){L5L.g5L();var l1S="icker";var z0v=h7S;z0v+=D4v;if($[z0v]){var v0v=Z9a;v0v+=l6a;v0v+=z3a;v0v+=l1S;var u0v=u7d;u0v+=z3a;u0v+=a1d;conf[u0v][v0v](y6r);}else {var X0v=L5L.j4v;X0v+=o3S;X0v+=C1S;var I0v=z3a;I0v+=D4v;I0v+=K4v;I0v+=z3a;$(conf[Q5S])[I0v](X0v,e5a);}},owns:function(conf,node){var S1S="atepicker-hea";var n1S="pare";var A1S="div.ui-d";var V1S='div.ui-datepicker';var g1S="nts";var A0v=p2r;L5L.r5L();A0v+=q8a;var C0v=A1S;C0v+=S1S;C0v+=V8a;C0v+=D4v;var l0v=z3a;l0v+=W2a;l0v+=V7n;l0v+=O3a;var r0v=O8n;r0v+=a6a;r0v+=q8a;var c0v=n1S;c0v+=g1S;return $(node)[c0v](V1S)[r0v] || $(node)[l0v](C0v)[A0v]?e5a:Y5a;}});fieldTypes[r9S]=$[I7a](e5a,{},baseFieldType,{create:function(conf){var N1S="<input /";var E1S="yForm";var G1S="atetime";var m1S="feId";var P1S="keyInput";var y1S="Tim";var Z1S="seF";var j0v=a3a;j0v+=V3n;j0v+=L5L.Y4v;j0v+=a0a;var P0v=L5L.F4v;P0v+=u8a;P0v+=t3a;P0v+=L5L.Y4v;var J0v=F3a;J0v+=K4v;J0v+=Z1S;J0v+=i4v;var N0v=L5L.j4v;N0v+=G1S;var m0v=x4v;m0v+=v7a;m0v+=W1n;var y0v=X7n;y0v+=T4n;y0v+=L7a;var E0v=M8n;E0v+=E1S;E0v+=L5L.J4v;E0v+=a6a;var G0v=r6a;G0v+=P6n;G0v+=y1S;G0v+=L5L.Y4v;var Z0v=L5L.J4v;Z0v+=A1n;Z0v+=D4v;var V0v=D7S;V0v+=m1S;var g0v=F2r;g0v+=y8a;var n0v=L7a;n0v+=V6n;var S0v=N1S;S0v+=C0a;conf[Q5S]=$(S0v)[n0v]($[g0v](e5a,{id:Editor[V0v](conf[A7a]),type:B5S},conf[Z0v]));conf[k1S]=new Editor[G0v](conf[Q5S],$[I7a]({format:conf[E0v] || conf[y0v],i18n:this[m0v][N0v],onChange:function(){L5L.g5L();setTimeout(function(){var q1S="rigg";var T1S="hange";var q0v=L5L.F4v;q0v+=T1S;var T0v=a6a;T0v+=q1S;T0v+=j3a;var k0v=a3a;k0v+=L0a;k0v+=Q0a;conf[k0v][T0v](q0v);},R1v);}},conf[j1a]));conf[J0v]=function(){var J1S="hide";L5L.r5L();conf[k1S][J1S]();};if(conf[P1S] === Y5a){conf[Q5S][n3a](j1S,function(e){L5L.r5L();e[l4n]();});}this[n3a](P0v,conf[j0v]);return conf[Q5S][R1v];},get:function(conf){var Y1S="men";var e1S="tS";var d1S="Format";var B1S="wireFormat";var t1S="Local";var F1S="trict";var R1S="_pic";var M1S="ir";var d0v=X8a;d0v+=Y1S;d0v+=e1S;d0v+=F1S;var M0v=G1d;M0v+=t1S;M0v+=L5L.Y4v;var t0v=r2a;t0v+=M1S;t0v+=L5L.Y4v;t0v+=d1S;var F0v=R1S;F0v+=n5d;L5L.g5L();F0v+=D4v;var e0v=N3a;e0v+=L5L.J4v;e0v+=u8a;var Y0v=p5S;Y0v+=i4v;Y0v+=Q0a;var val=conf[Y0v][e0v]();var inst=conf[F0v][L5L.F4v];return conf[t0v] && moment?moment(val,inst[P7d],inst[M0v],inst[d0v])[P7d](conf[B1S]):val;},set:function(conf,val){var f1S="ntLoca";var i1S="eF";var o1S="wireF";var W1S="forma";var w1S="cker";var p1S="mome";var x1S="momentStrict";var i0v=W1S;i0v+=a6a;var o0v=Q5r;o0v+=L5L.P4v;o0v+=L5L.J4v;o0v+=a6a;var f0v=p1S;f0v+=f1S;f0v+=u8a;f0v+=L5L.Y4v;var p0v=o1S;p0v+=z9S;var W0v=Z8r;W0v+=D4v;W0v+=i1S;W0v+=z9S;var B0v=N3a;B0v+=L5L.J4v;B0v+=u8a;var R0v=a3a;R0v+=A8d;R0v+=w1S;var inst=conf[k1S][L5L.F4v];conf[R0v][B0v](conf[W0v] && moment?moment(val,conf[p0v],inst[f0v],inst[x1S])[o0v](inst[i0v]):val);_triggerChange(conf[Q5S]);},owns:function(conf,node){var h1S="_pick";L5L.g5L();var D1S="owns";var w0v=h1S;w0v+=j3a;return conf[w0v][D1S](node);},errorMessage:function(conf,msg){var U1S="Msg";var x0v=L5L.Y4v;x0v+=n7n;x0v+=U1S;conf[k1S][x0v](msg);},destroy:function(conf){var K1S="los";var K0v=V8a;K0v+=b3a;K0v+=V6n;K0v+=Z6n;var U0v=u7d;U0v+=z3a;U0v+=T8a;U0v+=a6a;var D0v=A3d;D0v+=K1S;D0v+=M1a;var h0v=L5L.F4v;h0v+=Z6a;this[E5n](h0v,conf[D0v]);conf[U0v][E5n](j1S);conf[k1S][K0v]();},minDate:function(conf,min){var O4S="mi";var L4S="pic";var L7v=O4S;L7v+=i4v;var O7v=a3a;O7v+=L4S;O7v+=n5d;O7v+=D4v;conf[O7v][L7v](min);},maxDate:function(conf,max){var Q4S="_pi";var s7v=h9n;s7v+=D2a;var Q7v=Q4S;Q7v+=B5a;Q7v+=j3a;conf[Q7v][s7v](max);}});fieldTypes[H7v]=$[I7a](e5a,{},baseFieldType,{create:function(conf){var editor=this;L5L.g5L();var container=_commonUpload(editor,conf,function(val){var s4S="Upl";var I7v=i4v;I7v+=L5L.J4v;I7v+=L5L.P4v;I7v+=L5L.Y4v;var v7v=L9r;v7v+=L6n;v7v+=s4S;v7v+=C9S;var u7v=a3a;u7v+=m6d;var z7v=g9d;z7v+=u8a;var a7v=b3a;a7v+=L5L.Y4v;a7v+=a6a;var b7v=E9r;b7v+=K4v;b7v+=g2d;Editor[C7a][b7v][a7v][z7v](editor,conf,val[R1v]);editor[u7v](v7v,[conf[I7v],val[R1v]]);});return container;},get:function(conf){var X7v=H4S;X7v+=L5L.J4v;L5L.r5L();X7v+=u8a;return conf[X7v];},set:function(conf,val){var l4S='noClear';var r4S="removeCl";var X4S="clearText";var u4S="<span";var v4S='No file';var I4S='div.clearValue button';var c4S="Cle";var z4S="Tex";var G7v=a3a;G7v+=N3a;G7v+=L5L.J4v;G7v+=u8a;var Z7v=E9r;Z7v+=K4v;Z7v+=b4S;Z7v+=i0d;var V7v=p5S;V7v+=i4v;V7v+=Q0a;var c7v=p5S;c7v+=i4v;c7v+=Q0a;conf[e5S]=val;var container=conf[c7v];if(conf[j2a]){var r7v=H4S;r7v+=L5L.J4v;r7v+=u8a;var rendered=container[e8r](a4S);if(conf[r7v]){var l7v=a2r;l7v+=u8a;rendered[l7v](conf[j2a](conf[e5S]));}else {var S7v=A2a;S7v+=T9S;S7v+=z4S;S7v+=a6a;var A7v=u4S;A7v+=C0a;var C7v=O1r;C7v+=L5L.j4v;rendered[A3S]()[C7v](A7v + (conf[S7v] || v4S) + y8S);}}var button=container[e8r](I4S);if(val && conf[X4S]){var g7v=A2a;g7v+=c4S;g7v+=L5L.J4v;g7v+=D4v;var n7v=r4S;n7v+=L5L.J4v;n7v+=b3a;n7v+=b3a;button[j4a](conf[X4S]);container[n7v](g7v);}else {container[p1a](l4S);}conf[V7v][e8r](p0S)[m1r](Z7v,[conf[G7v]]);},enable:function(conf){var N7v=l5S;N7v+=i2a;N7v+=P2a;var m7v=z3a;m7v+=D4v;m7v+=A1a;var y7v=K3a;y7v+=L0a;y7v+=L5L.j4v;var E7v=a3a;E7v+=w1d;conf[E7v][y7v](p0S)[m7v](a6S,Y5a);conf[N7v]=e5a;},disable:function(conf){var C4S="_enab";var P7v=C4S;P7v+=S6a;L5L.r5L();P7v+=L5L.j4v;var J7v=L5L.j4v;J7v+=o3S;J7v+=C1S;var q7v=x4v;q7v+=g4a;var T7v=K3a;T7v+=x4v;T7v+=i4v;T7v+=L5L.j4v;var k7v=a3a;k7v+=o1d;k7v+=a6a;conf[k7v][T7v](q7v)[j5S](J7v,e5a);conf[P7v]=Y5a;},canReturnSubmit:function(conf,node){return Y5a;}});fieldTypes[j7v]=$[I7a](e5a,{},baseFieldType,{_showHide:function(conf){var S4S="Lef";var g4S="limit";var n4S="div.limitHid";var A4S="_limit";var R7v=N5a;R7v+=v8n;R7v+=q8a;var d7v=H4S;d7v+=L5L.J4v;d7v+=u8a;var M7v=A4S;M7v+=S4S;M7v+=a6a;var t7v=A2a;t7v+=i4v;t7v+=L5L.Y4v;var F7v=u8a;F7v+=x4v;F7v+=L5L.P4v;F7v+=H9a;var e7v=a3a;e7v+=N3a;L5L.r5L();e7v+=N2S;var Y7v=n4S;Y7v+=L5L.Y4v;if(!conf[g4S]){return;}conf[V4S][e8r](Y7v)[s1a](H1a,conf[e7v][j5a] >= conf[F7v]?t7v:X8n);conf[M7v]=conf[g4S] - conf[d7v][R7v];},create:function(conf){var G4S="addCla";var Z4S=".remove";var h7v=w6a;h7v+=R0d;h7v+=i4v;h7v+=Z4S;var x7v=t5a;x7v+=i5a;var w7v=G4S;w7v+=x0a;var editor=this;var container=_commonUpload(editor,conf,function(val){var N4S='postUpload';var y4S="eldTypes";var E4S="_va";var i7v=E4S;i7v+=u8a;var o7v=i4v;o7v+=L5L.J4v;o7v+=L5L.P4v;o7v+=L5L.Y4v;var f7v=a3a;f7v+=N5d;f7v+=u8a;var p7v=b3a;p7v+=V2a;var W7v=K3a;W7v+=x4v;W7v+=y4S;var B7v=H4S;B7v+=N2S;conf[B7v]=conf[e5S][w7n](val);Editor[W7v][m4S][p7v][z4n](editor,conf,conf[f7v]);editor[X1n](N4S,[conf[o7v],conf[i7v]]);},e5a);L5L.g5L();container[w7v](x7v)[n3a](Z1a,h7v,function(e){var k4S="stopPropagation";var q4S="dx";var T4S="dM";var D7v=j6r;D7v+=i4v;D7v+=L5L.J4v;L5L.g5L();D7v+=C1S;e[k4S]();if(conf[D7v]){var Q1v=b3a;Q1v+=L5L.Y4v;Q1v+=a6a;var L1v=E9r;L1v+=u9r;L1v+=T4S;L1v+=v9d;var O1v=a3a;O1v+=N3a;O1v+=N2S;var K7v=x4v;K7v+=q4S;var U7v=L5L.j4v;U7v+=L5L.J4v;U7v+=a6a;U7v+=L5L.J4v;var idx=$(this)[U7v](K7v);conf[O1v][E4n](idx,B1v);Editor[C7a][L1v][Q1v][z4n](editor,conf,conf[e5S]);}});conf[V4S]=container;return container;},get:function(conf){L5L.r5L();return conf[e5S];},set:function(conf,val){var e4S="Hi";var J4S="uplo";var P4S="ig";var o4S="pan>";var M4S='<ul/>';var i4S="<spa";var j4S="gerHandler";var f4S="</s";var w4S="noFileText";var Y4S="_show";var F4S='Upload collections must have an array as a value';var t4S="ndT";var x4S='No files';var Z1v=J4S;Z1v+=b4S;Z1v+=h4v;Z1v+=D4v;var V1v=a6a;V1v+=D4v;V1v+=P4S;V1v+=j4S;var g1v=x4v;g1v+=b1d;g1v+=a1d;var n1v=K3a;n1v+=b7r;var S1v=a3a;S1v+=w1d;var A1v=Y4S;A1v+=e4S;A1v+=V8a;var H1v=L5L.j4v;H1v+=P9n;H1v+=z3a;H1v+=O9a;var s1v=a3a;s1v+=N5d;s1v+=u8a;if(!val){val=[];}if(!$[X6n](val)){throw F4S;}conf[s1v]=val;var that=this;var container=conf[Q5S];if(conf[H1v]){var a1v=F1n;a1v+=t1n;var b1v=K3a;b1v+=b7r;var rendered=container[b1v](a4S)[a1v]();if(val[j5a]){var u1v=L5L.Y4v;u1v+=L5L.J4v;u1v+=L5L.F4v;u1v+=q8a;var z1v=i8n;z1v+=L5L.Y4v;z1v+=t4S;z1v+=K4v;var list=$(M4S)[z1v](rendered);$[u1v](val,function(i,file){var d4S=" remove\" data";var W4S='">&times;</button>';var p4S='</li>';var R4S="-idx=\"";var B4S=' <button class="';var c1v=d4S;c1v+=R4S;var X1v=w6a;X1v+=a1d;X1v+=a6a;X1v+=n3a;var I1v=Q5r;I1v+=L5L.P4v;var v1v=u0a;v1v+=u8a;v1v+=x4v;v1v+=C0a;list[O3n](v1v + conf[j2a](file,i) + B4S + that[O4a][I1v][X1v] + c1v + i + W4S + p4S);});}else {var C1v=f4S;C1v+=o4S;var l1v=i4S;l1v+=n3S;var r1v=n3n;r1v+=z3a;r1v+=L5L.Y4v;r1v+=y8a;rendered[r1v](l1v + (conf[w4S] || x4S) + C1v);}}Editor[C7a][m4S][A1v](conf);conf[S1v][n1v](g1v)[V1v](Z1v,[conf[e5S]]);},enable:function(conf){var m1v=L0S;m1v+=i3S;var y1v=z3a;y1v+=D4v;y1v+=A1a;var E1v=x4v;E1v+=b1d;E1v+=a1d;L5L.r5L();var G1v=r7d;G1v+=L5L.j4v;conf[Q5S][G1v](E1v)[y1v](m1v,Y5a);conf[s5S]=e5a;},disable:function(conf){var T1v=j6r;T1v+=H7a;T1v+=w6a;T1v+=i3S;var k1v=x4v;k1v+=Q4d;k1v+=a6a;var N1v=q6n;N1v+=i4v;N1v+=L5L.j4v;conf[Q5S][N1v](k1v)[j5S](a6S,e5a);conf[T1v]=Y5a;},canReturnSubmit:function(conf,node){L5L.r5L();return Y5a;}});})();if(DataTable[q1v][h4S]){var j1v=L5L.Y4v;j1v+=D2a;j1v+=a6a;var P1v=T2a;P1v+=D4S;P1v+=s6a;var J1v=b6a;J1v+=z7r;$[J1v](Editor[P1v],DataTable[j1v][h4S]);}DataTable[Y1v][h4S]=Editor[e1v];Editor[A5a]={};Editor[F1v][U4S]=t1v;Editor[M1v]=d1v;return Editor;});

/*! Bootstrap integration for DataTables' Editor
 * 2015 SpryMedia Ltd - datatables.net/license
 */

(function( factory ){
	if ( typeof define === 'function' && define.amd ) {
		// AMD
		define( ['jquery', 'datatables.net-bs4', 'datatables.net-editor'], function ( $ ) {
			return factory( $, window, document );
		} );
	}
	else if ( typeof exports === 'object' ) {
		// CommonJS
		module.exports = function (root, $) {
			if ( ! root ) {
				root = window;
			}

			if ( ! $ || ! $.fn.dataTable ) {
				$ = require('datatables.net-bs4')(root, $).$;
			}

			if ( ! $.fn.dataTable.Editor ) {
				require('datatables.net-editor')(root, $);
			}

			return factory( $, root, root.document );
		};
	}
	else {
		// Browser
		factory( jQuery, window, document );
	}
}(function( $, window, document, undefined ) {
'use strict';
var DataTable = $.fn.dataTable;


/*
 * Set the default display controller to be our bootstrap control 
 */
DataTable.Editor.defaults.display = "bootstrap";


/*
 * Alter the buttons that Editor adds to TableTools so they are suitable for bootstrap
 */
var i18nDefaults = DataTable.Editor.defaults.i18n;
i18nDefaults.create.title = '<h5 class="modal-title">'+i18nDefaults.create.title+'</h5>';
i18nDefaults.edit.title = '<h5 class="modal-title">'+i18nDefaults.edit.title+'</h5>';
i18nDefaults.remove.title = '<h5 class="modal-title">'+i18nDefaults.remove.title+'</h5>';

var tt = DataTable.TableTools;
if ( tt ) {
	tt.BUTTONS.editor_create.formButtons[0].className = "btn btn-primary";
	tt.BUTTONS.editor_edit.formButtons[0].className = "btn btn-primary";
	tt.BUTTONS.editor_remove.formButtons[0].className = "btn btn-danger";
}


/*
 * Change the default classes from Editor to be classes for Bootstrap
 */
$.extend( true, $.fn.dataTable.Editor.classes, {
	"header": {
		"wrapper": "DTE_Header modal-header"
	},
	"body": {
		"wrapper": "DTE_Body modal-body"
	},
	"footer": {
		"wrapper": "DTE_Footer modal-footer"
	},
	"form": {
		"tag": "form-horizontal",
		"button": "btn",
		"buttonInternal": "btn btn-outline-secondary"
	},
	"field": {
		"wrapper": "DTE_Field form-group row",
		"label":   "col-lg-4 col-form-label",
		"input":   "col-lg-8",
		"error":   "error is-invalid",
		"msg-labelInfo": "form-text text-secondary small",
		"msg-info":      "form-text text-secondary small",
		"msg-message":   "form-text text-secondary small",
		"msg-error":     "form-text text-danger small",
		"multiValue":    "card multi-value",
		"multiInfo":     "small",
		"multiRestore":  "card multi-restore"
	}
} );

$.extend( true, DataTable.ext.buttons, {
	create: {
		formButtons: {
			className: 'btn-primary'
		}
	},
	edit: {
		formButtons: {
			className: 'btn-primary'
		}
	},
	remove: {
		formButtons: {
			className: 'btn-danger'
		}
	}
} );


/*
 * Bootstrap display controller - this is effectively a proxy to the Bootstrap
 * modal control.
 */

DataTable.Editor.display.bootstrap = $.extend( true, {}, DataTable.Editor.models.displayController, {
	/*
	 * API methods
	 */
	"init": function ( dte ) {
		var conf = {
			// Note that `modal-dialog-scrollable` is BS4.3+ only. It has no effect on 4.0-4.2
			content: $(
				'<div class="modal fade DTED">'+
					'<div class="modal-dialog modal-dialog-scrollable" />'+
				'</div>'
			),
			close: $('<button class="close">&times;</div>')
				.on('click', function () {
					dte.close('icon');
				}),
			shown: false,
			fullyShow: false
		}

		// This is a bit horrible, but if you mousedown and then drag out of the modal container, we don't
		// want to trigger a background action.
		var allowBackgroundClick = false;
		$(document).on('mousedown', 'div.modal', function (e) {
			allowBackgroundClick = $(e.target).hasClass('modal') && conf.shown
				? true
				: false;
		} );

		$(document).on('click', 'div.modal', function (e) {
			if ( $(e.target).hasClass('modal') && allowBackgroundClick ) {
				dte.background();
			}
		} );

		// Add `form-control` to required elements
		dte.on( 'displayOrder.dtebs', function ( e, display, action, form ) {
			$.each( dte.s.fields, function ( key, field ) {
				$('input:not([type=checkbox]):not([type=radio]), select, textarea', field.node() )
					.addClass( 'form-control' );
			} );
		} );

		dte._bootstrapDisplay = conf;

		return DataTable.Editor.display.bootstrap;
	},

	"open": function ( dte, append, callback ) {
		var conf = dte._bootstrapDisplay;

		$(append).addClass('modal-content');

		if ( conf._shown ) {
			// Modal already up, so just draw in the new content
			var content = conf.content.find('div.modal-dialog');
			content.children().detach();
			content.append( append );

			if ( callback ) {
				callback();
			}
			return;
		}

		conf.shown = true;
		conf.fullyDisplayed = false;

		var content = conf.content.find('div.modal-dialog');
		content.children().detach();
		content.append( append );

		$('div.modal-header', append).append( conf.close );

		$(conf.content)
			.one('shown.bs.modal', function () {
				// Can only give elements focus when shown
				if ( dte.s.setFocus ) {
					dte.s.setFocus.focus();
				}

				conf.fullyDisplayed = true;

				if ( callback ) {
					callback();
				}
			})
			.one('hidden', function () {
				conf.shown = false;
			})
			.appendTo( 'body' )
			.modal( {
				backdrop: "static",
				keyboard: false
			} );
	},

	"close": function ( dte, callback ) {
		var conf = dte._bootstrapDisplay;

		if ( !conf.shown ) {
			if ( callback ) {
				callback();
			}
			return;
		}

		// Check if actually displayed or not before hiding. BS4 doesn't like `hide`
		// before it has been fully displayed
		if ( ! conf.fullyDisplayed ) {
			$(conf.content)
				.one('shown.bs.modal', function () {
					conf.close( dte, callback );
				} );

			return;
		}

		$(conf.content)
			.one( 'hidden.bs.modal', function () {
				$(this).detach();
			} )
			.modal('hide');

		conf.shown = false;
		conf.fullyDisplayed = false;

		if ( callback ) {
			callback();
		}
	},

	node: function ( dte ) {
		return dte._bootstrapDisplay.content[0];
	}
} );


return DataTable.Editor;
}));


/*! AutoFill 2.3.4
 * 2008-2019 SpryMedia Ltd - datatables.net/license
 */

/**
 * @summary     AutoFill
 * @description Add Excel like click and drag auto-fill options to DataTables
 * @version     2.3.4
 * @file        dataTables.autoFill.js
 * @author      SpryMedia Ltd (www.sprymedia.co.uk)
 * @contact     www.sprymedia.co.uk/contact
 * @copyright   Copyright 2010-2019 SpryMedia Ltd.
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license/mit
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */
(function( factory ){
	if ( typeof define === 'function' && define.amd ) {
		// AMD
		define( ['jquery', 'datatables.net'], function ( $ ) {
			return factory( $, window, document );
		} );
	}
	else if ( typeof exports === 'object' ) {
		// CommonJS
		module.exports = function (root, $) {
			if ( ! root ) {
				root = window;
			}

			if ( ! $ || ! $.fn.dataTable ) {
				$ = require('datatables.net')(root, $).$;
			}

			return factory( $, root, root.document );
		};
	}
	else {
		// Browser
		factory( jQuery, window, document );
	}
}(function( $, window, document, undefined ) {
'use strict';
var DataTable = $.fn.dataTable;


var _instance = 0;

/** 
 * AutoFill provides Excel like auto-fill features for a DataTable
 *
 * @class AutoFill
 * @constructor
 * @param {object} oTD DataTables settings object
 * @param {object} oConfig Configuration object for AutoFill
 */
var AutoFill = function( dt, opts )
{
	if ( ! DataTable.versionCheck || ! DataTable.versionCheck( '1.10.8' ) ) {
		throw( "Warning: AutoFill requires DataTables 1.10.8 or greater");
	}

	// User and defaults configuration object
	this.c = $.extend( true, {},
		DataTable.defaults.autoFill,
		AutoFill.defaults,
		opts
	);

	/**
	 * @namespace Settings object which contains customisable information for AutoFill instance
	 */
	this.s = {
		/** @type {DataTable.Api} DataTables' API instance */
		dt: new DataTable.Api( dt ),

		/** @type {String} Unique namespace for events attached to the document */
		namespace: '.autoFill'+(_instance++),

		/** @type {Object} Cached dimension information for use in the mouse move event handler */
		scroll: {},

		/** @type {integer} Interval object used for smooth scrolling */
		scrollInterval: null,

		handle: {
			height: 0,
			width: 0
		},

		/**
		 * Enabled setting
		 * @type {Boolean}
		 */
		enabled: false
	};


	/**
	 * @namespace Common and useful DOM elements for the class instance
	 */
	this.dom = {
		/** @type {jQuery} AutoFill handle */
		handle: $('<div class="dt-autofill-handle"/>'),

		/**
		 * @type {Object} Selected cells outline - Need to use 4 elements,
		 *   otherwise the mouse over if you back into the selected rectangle
		 *   will be over that element, rather than the cells!
		 */
		select: {
			top:    $('<div class="dt-autofill-select top"/>'),
			right:  $('<div class="dt-autofill-select right"/>'),
			bottom: $('<div class="dt-autofill-select bottom"/>'),
			left:   $('<div class="dt-autofill-select left"/>')
		},

		/** @type {jQuery} Fill type chooser background */
		background: $('<div class="dt-autofill-background"/>'),

		/** @type {jQuery} Fill type chooser */
		list: $('<div class="dt-autofill-list">'+this.s.dt.i18n('autoFill.info', '')+'<ul/></div>'),

		/** @type {jQuery} DataTables scrolling container */
		dtScroll: null,

		/** @type {jQuery} Offset parent element */
		offsetParent: null
	};


	/* Constructor logic */
	this._constructor();
};



$.extend( AutoFill.prototype, {
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Public methods (exposed via the DataTables API below)
	 */
	enabled: function ()
	{
		return this.s.enabled;
	},


	enable: function ( flag )
	{
		var that = this;

		if ( flag === false ) {
			return this.disable();
		}

		this.s.enabled = true;

		this._focusListener();

		this.dom.handle.on( 'mousedown', function (e) {
			that._mousedown( e );
			return false;
		} );

		return this;
	},

	disable: function ()
	{
		this.s.enabled = false;

		this._focusListenerRemove();

		return this;
	},


	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Constructor
	 */

	/**
	 * Initialise the RowReorder instance
	 *
	 * @private
	 */
	_constructor: function ()
	{
		var that = this;
		var dt = this.s.dt;
		var dtScroll = $('div.dataTables_scrollBody', this.s.dt.table().container());

		// Make the instance accessible to the API
		dt.settings()[0].autoFill = this;

		if ( dtScroll.length ) {
			this.dom.dtScroll = dtScroll;

			// Need to scroll container to be the offset parent
			if ( dtScroll.css('position') === 'static' ) {
				dtScroll.css( 'position', 'relative' );
			}
		}

		if ( this.c.enable !== false ) {
			this.enable();
		}

		dt.on( 'destroy.autoFill', function () {
			that._focusListenerRemove();
		} );
	},


	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Private methods
	 */

	/**
	 * Display the AutoFill drag handle by appending it to a table cell. This
	 * is the opposite of the _detach method.
	 *
	 * @param  {node} node TD/TH cell to insert the handle into
	 * @private
	 */
	_attach: function ( node )
	{
		var dt = this.s.dt;
		var idx = dt.cell( node ).index();
		var handle = this.dom.handle;
		var handleDim = this.s.handle;

		if ( ! idx || dt.columns( this.c.columns ).indexes().indexOf( idx.column ) === -1 ) {
			this._detach();
			return;
		}

		if ( ! this.dom.offsetParent ) {
			// We attach to the table's offset parent
			this.dom.offsetParent = $( dt.table().node() ).offsetParent();
		}

		if ( ! handleDim.height || ! handleDim.width ) {
			// Append to document so we can get its size. Not expecting it to
			// change during the life time of the page
			handle.appendTo( 'body' );
			handleDim.height = handle.outerHeight();
			handleDim.width = handle.outerWidth();
		}

		// Might need to go through multiple offset parents
		var offset = this._getPosition( node, this.dom.offsetParent );

		this.dom.attachedTo = node;
		handle
			.css( {
				top: offset.top + node.offsetHeight - handleDim.height,
				left: offset.left + node.offsetWidth - handleDim.width
			} )
			.appendTo( this.dom.offsetParent );
	},


	/**
	 * Determine can the fill type should be. This can be automatic, or ask the
	 * end user.
	 *
	 * @param {array} cells Information about the selected cells from the key
	 *     up function
	 * @private
	 */
	_actionSelector: function ( cells )
	{
		var that = this;
		var dt = this.s.dt;
		var actions = AutoFill.actions;
		var available = [];

		// "Ask" each plug-in if it wants to handle this data
		$.each( actions, function ( key, action ) {
			if ( action.available( dt, cells ) ) {
				available.push( key );
			}
		} );

		if ( available.length === 1 && this.c.alwaysAsk === false ) {
			// Only one action available - enact it immediately
			var result = actions[ available[0] ].execute( dt, cells );
			this._update( result, cells );
		}
		else {
			// Multiple actions available - ask the end user what they want to do
			var list = this.dom.list.children('ul').empty();

			// Add a cancel option
			available.push( 'cancel' );

			$.each( available, function ( i, name ) {
				list.append( $('<li/>')
					.append(
						'<div class="dt-autofill-question">'+
							actions[ name ].option( dt, cells )+
						'<div>'
					)
					.append( $('<div class="dt-autofill-button">' )
						.append( $('<button class="'+AutoFill.classes.btn+'">'+dt.i18n('autoFill.button', '&gt;')+'</button>')
							.on( 'click', function () {
								var result = actions[ name ].execute(
									dt, cells, $(this).closest('li')
								);
								that._update( result, cells );

								that.dom.background.remove();
								that.dom.list.remove();
							} )
						)
					)
				);
			} );

			this.dom.background.appendTo( 'body' );
			this.dom.list.appendTo( 'body' );

			this.dom.list.css( 'margin-top', this.dom.list.outerHeight()/2 * -1 );
		}
	},


	/**
	 * Remove the AutoFill handle from the document
	 *
	 * @private
	 */
	_detach: function ()
	{
		this.dom.attachedTo = null;
		this.dom.handle.detach();
	},


	/**
	 * Draw the selection outline by calculating the range between the start
	 * and end cells, then placing the highlighting elements to draw a rectangle
	 *
	 * @param  {node}   target End cell
	 * @param  {object} e      Originating event
	 * @private
	 */
	_drawSelection: function ( target, e )
	{
		// Calculate boundary for start cell to this one
		var dt = this.s.dt;
		var start = this.s.start;
		var startCell = $(this.dom.start);
		var end = {
			row: this.c.vertical ?
				dt.rows( { page: 'current' } ).nodes().indexOf( target.parentNode ) :
				start.row,
			column: this.c.horizontal ?
				$(target).index() :
				start.column
		};
		var colIndx = dt.column.index( 'toData', end.column );
		var endRow =  dt.row( ':eq('+end.row+')', { page: 'current' } ); // Workaround for M581
		var endCell = $( dt.cell( endRow.index(), colIndx ).node() );

		// Be sure that is a DataTables controlled cell
		if ( ! dt.cell( endCell ).any() ) {
			return;
		}

		// if target is not in the columns available - do nothing
		if ( dt.columns( this.c.columns ).indexes().indexOf( colIndx ) === -1 ) {
			return;
		}

		this.s.end = end;

		var top, bottom, left, right, height, width;

		top    = start.row    < end.row    ? startCell : endCell;
		bottom = start.row    < end.row    ? endCell   : startCell;
		left   = start.column < end.column ? startCell : endCell;
		right  = start.column < end.column ? endCell   : startCell;

		top    = this._getPosition( top.get(0) ).top;
		left   = this._getPosition( left.get(0) ).left;
		height = this._getPosition( bottom.get(0) ).top + bottom.outerHeight() - top;
		width  = this._getPosition( right.get(0) ).left + right.outerWidth() - left;

		var select = this.dom.select;
		select.top.css( {
			top: top,
			left: left,
			width: width
		} );

		select.left.css( {
			top: top,
			left: left,
			height: height
		} );

		select.bottom.css( {
			top: top + height,
			left: left,
			width: width
		} );

		select.right.css( {
			top: top,
			left: left + width,
			height: height
		} );
	},


	/**
	 * Use the Editor API to perform an update based on the new data for the
	 * cells
	 *
	 * @param {array} cells Information about the selected cells from the key
	 *     up function
	 * @private
	 */
	_editor: function ( cells )
	{
		var dt = this.s.dt;
		var editor = this.c.editor;

		if ( ! editor ) {
			return;
		}

		// Build the object structure for Editor's multi-row editing
		var idValues = {};
		var nodes = [];
		var fields = editor.fields();

		for ( var i=0, ien=cells.length ; i<ien ; i++ ) {
			for ( var j=0, jen=cells[i].length ; j<jen ; j++ ) {
				var cell = cells[i][j];

				// Determine the field name for the cell being edited
				var col = dt.settings()[0].aoColumns[ cell.index.column ];
				var fieldName = col.editField;

				if ( fieldName === undefined ) {
					var dataSrc = col.mData;

					// dataSrc is the `field.data` property, but we need to set
					// using the field name, so we need to translate from the
					// data to the name
					for ( var k=0, ken=fields.length ; k<ken ; k++ ) {
						var field = editor.field( fields[k] );

						if ( field.dataSrc() === dataSrc ) {
							fieldName = field.name();
							break;
						}
					}
				}

				if ( ! fieldName ) {
					throw 'Could not automatically determine field data. '+
						'Please see https://datatables.net/tn/11';
				}

				if ( ! idValues[ fieldName ] ) {
					idValues[ fieldName ] = {};
				}

				var id = dt.row( cell.index.row ).id();
				idValues[ fieldName ][ id ] = cell.set;

				// Keep a list of cells so we can activate the bubble editing
				// with them
				nodes.push( cell.index );
			}
		}

		// Perform the edit using bubble editing as it allows us to specify
		// the cells to be edited, rather than using full rows
		editor
			.bubble( nodes, false )
			.multiSet( idValues )
			.submit();
	},


	/**
	 * Emit an event on the DataTable for listeners
	 *
	 * @param  {string} name Event name
	 * @param  {array} args Event arguments
	 * @private
	 */
	_emitEvent: function ( name, args )
	{
		this.s.dt.iterator( 'table', function ( ctx, i ) {
			$(ctx.nTable).triggerHandler( name+'.dt', args );
		} );
	},


	/**
	 * Attach suitable listeners (based on the configuration) that will attach
	 * and detach the AutoFill handle in the document.
	 *
	 * @private
	 */
	_focusListener: function ()
	{
		var that = this;
		var dt = this.s.dt;
		var namespace = this.s.namespace;
		var focus = this.c.focus !== null ?
			this.c.focus :
			dt.init().keys || dt.settings()[0].keytable ?
				'focus' :
				'hover';

		// All event listeners attached here are removed in the `destroy`
		// callback in the constructor
		if ( focus === 'focus' ) {
			dt
				.on( 'key-focus.autoFill', function ( e, dt, cell ) {
					that._attach( cell.node() );
				} )
				.on( 'key-blur.autoFill', function ( e, dt, cell ) {
					that._detach();
				} );
		}
		else if ( focus === 'click' ) {
			$(dt.table().body()).on( 'click'+namespace, 'td, th', function (e) {
				that._attach( this );
			} );

			$(document.body).on( 'click'+namespace, function (e) {
				if ( ! $(e.target).parents().filter( dt.table().body() ).length ) {
					that._detach();
				}
			} );
		}
		else {
			$(dt.table().body())
				.on( 'mouseenter'+namespace, 'td, th', function (e) {
					that._attach( this );
				} )
				.on( 'mouseleave'+namespace, function (e) {
					if ( $(e.relatedTarget).hasClass('dt-autofill-handle') ) {
						return;
					}

					that._detach();
				} );
		}
	},


	_focusListenerRemove: function ()
	{
		var dt = this.s.dt;

		dt.off( '.autoFill' );
		$(dt.table().body()).off( this.s.namespace );
		$(document.body).off( this.s.namespace );
	},


	/**
	 * Get the position of a node, relative to another, including any scrolling
	 * offsets.
	 * @param  {Node}   node         Node to get the position of
	 * @param  {jQuery} targetParent Node to use as the parent
	 * @return {object}              Offset calculation
	 * @private
	 */
	_getPosition: function ( node, targetParent )
	{
		var
			currNode = node,
			currOffsetParent,
			top = 0,
			left = 0;

		if ( ! targetParent ) {
			targetParent = $( $( this.s.dt.table().node() )[0].offsetParent );
		}

		do {
			// Don't use jQuery().position() the behaviour changes between 1.x and 3.x for
			// tables
			var positionTop = currNode.offsetTop;
			var positionLeft = currNode.offsetLeft;

			// jQuery doesn't give a `table` as the offset parent oddly, so use DOM directly
			currOffsetParent = $( currNode.offsetParent );

			top += positionTop + parseInt( currOffsetParent.css('border-top-width') ) * 1;
			left += positionLeft + parseInt( currOffsetParent.css('border-left-width') ) * 1;

			// Emergency fall back. Shouldn't happen, but just in case!
			if ( currNode.nodeName.toLowerCase() === 'body' ) {
				break;
			}

			currNode = currOffsetParent.get(0); // for next loop
		}
		while ( currOffsetParent.get(0) !== targetParent.get(0) )

		return {
			top: top,
			left: left
		};
	},


	/**
	 * Start mouse drag - selects the start cell
	 *
	 * @param  {object} e Mouse down event
	 * @private
	 */
	_mousedown: function ( e )
	{
		var that = this;
		var dt = this.s.dt;

		this.dom.start = this.dom.attachedTo;
		this.s.start = {
			row: dt.rows( { page: 'current' } ).nodes().indexOf( $(this.dom.start).parent()[0] ),
			column: $(this.dom.start).index()
		};

		$(document.body)
			.on( 'mousemove.autoFill', function (e) {
				that._mousemove( e );
			} )
			.on( 'mouseup.autoFill', function (e) {
				that._mouseup( e );
			} );

		var select = this.dom.select;
		var offsetParent = $( dt.table().node() ).offsetParent();
		select.top.appendTo( offsetParent );
		select.left.appendTo( offsetParent );
		select.right.appendTo( offsetParent );
		select.bottom.appendTo( offsetParent );

		this._drawSelection( this.dom.start, e );

		this.dom.handle.css( 'display', 'none' );

		// Cache scrolling information so mouse move doesn't need to read.
		// This assumes that the window and DT scroller will not change size
		// during an AutoFill drag, which I think is a fair assumption
		var scrollWrapper = this.dom.dtScroll;
		this.s.scroll = {
			windowHeight: $(window).height(),
			windowWidth:  $(window).width(),
			dtTop:        scrollWrapper ? scrollWrapper.offset().top : null,
			dtLeft:       scrollWrapper ? scrollWrapper.offset().left : null,
			dtHeight:     scrollWrapper ? scrollWrapper.outerHeight() : null,
			dtWidth:      scrollWrapper ? scrollWrapper.outerWidth() : null
		};
	},


	/**
	 * Mouse drag - selects the end cell and update the selection display for
	 * the end user
	 *
	 * @param  {object} e Mouse move event
	 * @private
	 */
	_mousemove: function ( e )
	{	
		var that = this;
		var dt = this.s.dt;
		var name = e.target.nodeName.toLowerCase();
		if ( name !== 'td' && name !== 'th' ) {
			return;
		}

		this._drawSelection( e.target, e );
		this._shiftScroll( e );
	},


	/**
	 * End mouse drag - perform the update actions
	 *
	 * @param  {object} e Mouse up event
	 * @private
	 */
	_mouseup: function ( e )
	{
		$(document.body).off( '.autoFill' );

		var that = this;
		var dt = this.s.dt;
		var select = this.dom.select;
		select.top.remove();
		select.left.remove();
		select.right.remove();
		select.bottom.remove();

		this.dom.handle.css( 'display', 'block' );

		// Display complete - now do something useful with the selection!
		var start = this.s.start;
		var end = this.s.end;

		// Haven't selected multiple cells, so nothing to do
		if ( start.row === end.row && start.column === end.column ) {
			return;
		}

		var startDt = dt.cell( ':eq('+start.row+')', start.column+':visible', {page:'current'} );

		// If Editor is active inside this cell (inline editing) we need to wait for Editor to
		// submit and then we can loop back and trigger the fill.
		if ( $('div.DTE', startDt.node()).length ) {
			var editor = dt.editor();

			editor
				.on( 'submitSuccess.dtaf close.dtaf', function () {
					editor.off( '.dtaf');

					setTimeout( function () {
						that._mouseup( e );
					}, 100 );
				} )
				.on( 'submitComplete.dtaf preSubmitCancelled.dtaf close.dtaf', function () {
					editor.off( '.dtaf');
				} );

			// Make the current input submit
			editor.submit();

			return;
		}

		// Build a matrix representation of the selected rows
		var rows       = this._range( start.row, end.row );
		var columns    = this._range( start.column, end.column );
		var selected   = [];
		var dtSettings = dt.settings()[0];
		var dtColumns  = dtSettings.aoColumns;
		var enabledColumns = dt.columns( this.c.columns ).indexes();

		// Can't use Array.prototype.map as IE8 doesn't support it
		// Can't use $.map as jQuery flattens 2D arrays
		// Need to use a good old fashioned for loop
		for ( var rowIdx=0 ; rowIdx<rows.length ; rowIdx++ ) {
			selected.push(
				$.map( columns, function (column) {
					var row = dt.row( ':eq('+rows[rowIdx]+')', {page:'current'} ); // Workaround for M581
					var cell = dt.cell( row.index(), column+':visible' );
					var data = cell.data();
					var cellIndex = cell.index();
					var editField = dtColumns[ cellIndex.column ].editField;

					if ( editField !== undefined ) {
						data = dtSettings.oApi._fnGetObjectDataFn( editField )( dt.row( cellIndex.row ).data() );
					}

					if ( enabledColumns.indexOf(cellIndex.column) === -1 ) {
						return;
					}

					return {
						cell:  cell,
						data:  data,
						label: cell.data(),
						index: cellIndex
					};
				} )
			);
		}

		this._actionSelector( selected );
		
		// Stop shiftScroll
		clearInterval( this.s.scrollInterval );
		this.s.scrollInterval = null;
	},


	/**
	 * Create an array with a range of numbers defined by the start and end
	 * parameters passed in (inclusive!).
	 * 
	 * @param  {integer} start Start
	 * @param  {integer} end   End
	 * @private
	 */
	_range: function ( start, end )
	{
		var out = [];
		var i;

		if ( start <= end ) {
			for ( i=start ; i<=end ; i++ ) {
				out.push( i );
			}
		}
		else {
			for ( i=start ; i>=end ; i-- ) {
				out.push( i );
			}
		}

		return out;
	},


	/**
	 * Move the window and DataTables scrolling during a drag to scroll new
	 * content into view. This is done by proximity to the edge of the scrolling
	 * container of the mouse - for example near the top edge of the window
	 * should scroll up. This is a little complicated as there are two elements
	 * that can be scrolled - the window and the DataTables scrolling view port
	 * (if scrollX and / or scrollY is enabled).
	 *
	 * @param  {object} e Mouse move event object
	 * @private
	 */
	_shiftScroll: function ( e )
	{
		var that = this;
		var dt = this.s.dt;
		var scroll = this.s.scroll;
		var runInterval = false;
		var scrollSpeed = 5;
		var buffer = 65;
		var
			windowY = e.pageY - document.body.scrollTop,
			windowX = e.pageX - document.body.scrollLeft,
			windowVert, windowHoriz,
			dtVert, dtHoriz;

		// Window calculations - based on the mouse position in the window,
		// regardless of scrolling
		if ( windowY < buffer ) {
			windowVert = scrollSpeed * -1;
		}
		else if ( windowY > scroll.windowHeight - buffer ) {
			windowVert = scrollSpeed;
		}

		if ( windowX < buffer ) {
			windowHoriz = scrollSpeed * -1;
		}
		else if ( windowX > scroll.windowWidth - buffer ) {
			windowHoriz = scrollSpeed;
		}

		// DataTables scrolling calculations - based on the table's position in
		// the document and the mouse position on the page
		if ( scroll.dtTop !== null && e.pageY < scroll.dtTop + buffer ) {
			dtVert = scrollSpeed * -1;
		}
		else if ( scroll.dtTop !== null && e.pageY > scroll.dtTop + scroll.dtHeight - buffer ) {
			dtVert = scrollSpeed;
		}

		if ( scroll.dtLeft !== null && e.pageX < scroll.dtLeft + buffer ) {
			dtHoriz = scrollSpeed * -1;
		}
		else if ( scroll.dtLeft !== null && e.pageX > scroll.dtLeft + scroll.dtWidth - buffer ) {
			dtHoriz = scrollSpeed;
		}

		// This is where it gets interesting. We want to continue scrolling
		// without requiring a mouse move, so we need an interval to be
		// triggered. The interval should continue until it is no longer needed,
		// but it must also use the latest scroll commands (for example consider
		// that the mouse might move from scrolling up to scrolling left, all
		// with the same interval running. We use the `scroll` object to "pass"
		// this information to the interval. Can't use local variables as they
		// wouldn't be the ones that are used by an already existing interval!
		if ( windowVert || windowHoriz || dtVert || dtHoriz ) {
			scroll.windowVert = windowVert;
			scroll.windowHoriz = windowHoriz;
			scroll.dtVert = dtVert;
			scroll.dtHoriz = dtHoriz;
			runInterval = true;
		}
		else if ( this.s.scrollInterval ) {
			// Don't need to scroll - remove any existing timer
			clearInterval( this.s.scrollInterval );
			this.s.scrollInterval = null;
		}

		// If we need to run the interval to scroll and there is no existing
		// interval (if there is an existing one, it will continue to run)
		if ( ! this.s.scrollInterval && runInterval ) {
			this.s.scrollInterval = setInterval( function () {
				// Don't need to worry about setting scroll <0 or beyond the
				// scroll bound as the browser will just reject that.
				if ( scroll.windowVert ) {
					document.body.scrollTop += scroll.windowVert;
				}
				if ( scroll.windowHoriz ) {
					document.body.scrollLeft += scroll.windowHoriz;
				}

				// DataTables scrolling
				if ( scroll.dtVert || scroll.dtHoriz ) {
					var scroller = that.dom.dtScroll[0];

					if ( scroll.dtVert ) {
						scroller.scrollTop += scroll.dtVert;
					}
					if ( scroll.dtHoriz ) {
						scroller.scrollLeft += scroll.dtHoriz;
					}
				}
			}, 20 );
		}
	},


	/**
	 * Update the DataTable after the user has selected what they want to do
	 *
	 * @param  {false|undefined} result Return from the `execute` method - can
	 *   be false internally to do nothing. This is not documented for plug-ins
	 *   and is used only by the cancel option.
	 * @param {array} cells Information about the selected cells from the key
	 *     up function, argumented with the set values
	 * @private
	 */
	_update: function ( result, cells )
	{
		// Do nothing on `false` return from an execute function
		if ( result === false ) {
			return;
		}

		var dt = this.s.dt;
		var cell;
		var columns = dt.columns( this.c.columns ).indexes();

		// Potentially allow modifications to the cells matrix
		this._emitEvent( 'preAutoFill', [ dt, cells ] );

		this._editor( cells );

		// Automatic updates are not performed if `update` is null and the
		// `editor` parameter is passed in - the reason being that Editor will
		// update the data once submitted
		var update = this.c.update !== null ?
			this.c.update :
			this.c.editor ?
				false :
				true;

		if ( update ) {
			for ( var i=0, ien=cells.length ; i<ien ; i++ ) {
				for ( var j=0, jen=cells[i].length ; j<jen ; j++ ) {
					cell = cells[i][j];

					if ( columns.indexOf(cell.index.column) !== -1 ) {
						cell.cell.data( cell.set );
					}
				}
			}

			dt.draw(false);
		}

		this._emitEvent( 'autoFill', [ dt, cells ] );
	}
} );


/**
 * AutoFill actions. The options here determine how AutoFill will fill the data
 * in the table when the user has selected a range of cells. Please see the
 * documentation on the DataTables site for full details on how to create plug-
 * ins.
 *
 * @type {Object}
 */
AutoFill.actions = {
	increment: {
		available: function ( dt, cells ) {
			var d = cells[0][0].label;

			// is numeric test based on jQuery's old `isNumeric` function
			return !isNaN( d - parseFloat( d ) );
		},

		option: function ( dt, cells ) {
			return dt.i18n(
				'autoFill.increment',
				'Increment / decrement each cell by: <input type="number" value="1">'
			);
		},

		execute: function ( dt, cells, node ) {
			var value = cells[0][0].data * 1;
			var increment = $('input', node).val() * 1;

			for ( var i=0, ien=cells.length ; i<ien ; i++ ) {
				for ( var j=0, jen=cells[i].length ; j<jen ; j++ ) {
					cells[i][j].set = value;

					value += increment;
				}
			}
		}
	},

	fill: {
		available: function ( dt, cells ) {
			return true;
		},

		option: function ( dt, cells ) {
			return dt.i18n('autoFill.fill', 'Fill all cells with <i>'+cells[0][0].label+'</i>' );
		},

		execute: function ( dt, cells, node ) {
			var value = cells[0][0].data;

			for ( var i=0, ien=cells.length ; i<ien ; i++ ) {
				for ( var j=0, jen=cells[i].length ; j<jen ; j++ ) {
					cells[i][j].set = value;
				}
			}
		}
	},

	fillHorizontal: {
		available: function ( dt, cells ) {
			return cells.length > 1 && cells[0].length > 1;
		},

		option: function ( dt, cells ) {
			return dt.i18n('autoFill.fillHorizontal', 'Fill cells horizontally' );
		},

		execute: function ( dt, cells, node ) {
			for ( var i=0, ien=cells.length ; i<ien ; i++ ) {
				for ( var j=0, jen=cells[i].length ; j<jen ; j++ ) {
					cells[i][j].set = cells[i][0].data;
				}
			}
		}
	},

	fillVertical: {
		available: function ( dt, cells ) {
			return cells.length > 1 && cells[0].length > 1;
		},

		option: function ( dt, cells ) {
			return dt.i18n('autoFill.fillVertical', 'Fill cells vertically' );
		},

		execute: function ( dt, cells, node ) {
			for ( var i=0, ien=cells.length ; i<ien ; i++ ) {
				for ( var j=0, jen=cells[i].length ; j<jen ; j++ ) {
					cells[i][j].set = cells[0][j].data;
				}
			}
		}
	},

	// Special type that does not make itself available, but is added
	// automatically by AutoFill if a multi-choice list is shown. This allows
	// sensible code reuse
	cancel: {
		available: function () {
			return false;
		},

		option: function ( dt ) {
			return dt.i18n('autoFill.cancel', 'Cancel' );
		},

		execute: function () {
			return false;
		}
	}
};


/**
 * AutoFill version
 * 
 * @static
 * @type      String
 */
AutoFill.version = '2.3.4';


/**
 * AutoFill defaults
 * 
 * @namespace
 */
AutoFill.defaults = {
	/** @type {Boolean} Ask user what they want to do, even for a single option */
	alwaysAsk: false,

	/** @type {string|null} What will trigger a focus */
	focus: null, // focus, click, hover

	/** @type {column-selector} Columns to provide auto fill for */
	columns: '', // all

	/** @type {Boolean} Enable AutoFill on load */
	enable: true,

	/** @type {boolean|null} Update the cells after a drag */
	update: null, // false is editor given, true otherwise

	/** @type {DataTable.Editor} Editor instance for automatic submission */
	editor: null,

	/** @type {boolean} Enable vertical fill */
	vertical: true,

	/** @type {boolean} Enable horizontal fill */
	horizontal: true
};


/**
 * Classes used by AutoFill that are configurable
 * 
 * @namespace
 */
AutoFill.classes = {
	/** @type {String} Class used by the selection button */
	btn: 'btn'
};


/*
 * API
 */
var Api = $.fn.dataTable.Api;

// Doesn't do anything - Not documented
Api.register( 'autoFill()', function () {
	return this;
} );

Api.register( 'autoFill().enabled()', function () {
	var ctx = this.context[0];

	return ctx.autoFill ?
		ctx.autoFill.enabled() :
		false;
} );

Api.register( 'autoFill().enable()', function ( flag ) {
	return this.iterator( 'table', function ( ctx ) {
		if ( ctx.autoFill ) {
			ctx.autoFill.enable( flag );
		}
	} );
} );

Api.register( 'autoFill().disable()', function () {
	return this.iterator( 'table', function ( ctx ) {
		if ( ctx.autoFill ) {
			ctx.autoFill.disable();
		}
	} );
} );


// Attach a listener to the document which listens for DataTables initialisation
// events so we can automatically initialise
$(document).on( 'preInit.dt.autofill', function (e, settings, json) {
	if ( e.namespace !== 'dt' ) {
		return;
	}

	var init = settings.oInit.autoFill;
	var defaults = DataTable.defaults.autoFill;

	if ( init || defaults ) {
		var opts = $.extend( {}, init, defaults );

		if ( init !== false ) {
			new AutoFill( settings, opts  );
		}
	}
} );


// Alias for access
DataTable.AutoFill = AutoFill;
DataTable.AutoFill = AutoFill;


return AutoFill;
}));


/*! Bootstrap integration for DataTables' AutoFill
 * 2015 SpryMedia Ltd - datatables.net/license
 */

(function( factory ){
	if ( typeof define === 'function' && define.amd ) {
		// AMD
		define( ['jquery', 'datatables.net-bs4', 'datatables.net-autofill'], function ( $ ) {
			return factory( $, window, document );
		} );
	}
	else if ( typeof exports === 'object' ) {
		// CommonJS
		module.exports = function (root, $) {
			if ( ! root ) {
				root = window;
			}

			if ( ! $ || ! $.fn.dataTable ) {
				$ = require('datatables.net-bs4')(root, $).$;
			}

			if ( ! $.fn.dataTable.AutoFill ) {
				require('datatables.net-autofill')(root, $);
			}

			return factory( $, root, root.document );
		};
	}
	else {
		// Browser
		factory( jQuery, window, document );
	}
}(function( $, window, document, undefined ) {
'use strict';
var DataTable = $.fn.dataTable;


DataTable.AutoFill.classes.btn = 'btn btn-primary';


return DataTable;
}));

/*! Buttons for DataTables 1.6.1
 * 2016-2019 SpryMedia Ltd - datatables.net/license
 */

(function( factory ){
	if ( typeof define === 'function' && define.amd ) {
		// AMD
		define( ['jquery', 'datatables.net'], function ( $ ) {
			return factory( $, window, document );
		} );
	}
	else if ( typeof exports === 'object' ) {
		// CommonJS
		module.exports = function (root, $) {
			if ( ! root ) {
				root = window;
			}

			if ( ! $ || ! $.fn.dataTable ) {
				$ = require('datatables.net')(root, $).$;
			}

			return factory( $, root, root.document );
		};
	}
	else {
		// Browser
		factory( jQuery, window, document );
	}
}(function( $, window, document, undefined ) {
'use strict';
var DataTable = $.fn.dataTable;


// Used for namespacing events added to the document by each instance, so they
// can be removed on destroy
var _instCounter = 0;

// Button namespacing counter for namespacing events on individual buttons
var _buttonCounter = 0;

var _dtButtons = DataTable.ext.buttons;

/**
 * [Buttons description]
 * @param {[type]}
 * @param {[type]}
 */
var Buttons = function( dt, config )
{
	// If not created with a `new` keyword then we return a wrapper function that
	// will take the settings object for a DT. This allows easy use of new instances
	// with the `layout` option - e.g. `topLeft: $.fn.dataTable.Buttons( ... )`.
	if ( !(this instanceof Buttons) ) {
		return function (settings) {
			return new Buttons( settings, dt ).container();
		};
	}

	// If there is no config set it to an empty object
	if ( typeof( config ) === 'undefined' ) {
		config = {};	
	}
	
	// Allow a boolean true for defaults
	if ( config === true ) {
		config = {};
	}

	// For easy configuration of buttons an array can be given
	if ( $.isArray( config ) ) {
		config = { buttons: config };
	}

	this.c = $.extend( true, {}, Buttons.defaults, config );

	// Don't want a deep copy for the buttons
	if ( config.buttons ) {
		this.c.buttons = config.buttons;
	}

	this.s = {
		dt: new DataTable.Api( dt ),
		buttons: [],
		listenKeys: '',
		namespace: 'dtb'+(_instCounter++)
	};

	this.dom = {
		container: $('<'+this.c.dom.container.tag+'/>')
			.addClass( this.c.dom.container.className )
	};

	this._constructor();
};


$.extend( Buttons.prototype, {
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Public methods
	 */

	/**
	 * Get the action of a button
	 * @param  {int|string} Button index
	 * @return {function}
	 *//**
	 * Set the action of a button
	 * @param  {node} node Button element
	 * @param  {function} action Function to set
	 * @return {Buttons} Self for chaining
	 */
	action: function ( node, action )
	{
		var button = this._nodeToButton( node );

		if ( action === undefined ) {
			return button.conf.action;
		}

		button.conf.action = action;

		return this;
	},

	/**
	 * Add an active class to the button to make to look active or get current
	 * active state.
	 * @param  {node} node Button element
	 * @param  {boolean} [flag] Enable / disable flag
	 * @return {Buttons} Self for chaining or boolean for getter
	 */
	active: function ( node, flag ) {
		var button = this._nodeToButton( node );
		var klass = this.c.dom.button.active;
		var jqNode = $(button.node);

		if ( flag === undefined ) {
			return jqNode.hasClass( klass );
		}

		jqNode.toggleClass( klass, flag === undefined ? true : flag );

		return this;
	},

	/**
	 * Add a new button
	 * @param {object} config Button configuration object, base string name or function
	 * @param {int|string} [idx] Button index for where to insert the button
	 * @return {Buttons} Self for chaining
	 */
	add: function ( config, idx )
	{
		var buttons = this.s.buttons;

		if ( typeof idx === 'string' ) {
			var split = idx.split('-');
			var base = this.s;

			for ( var i=0, ien=split.length-1 ; i<ien ; i++ ) {
				base = base.buttons[ split[i]*1 ];
			}

			buttons = base.buttons;
			idx = split[ split.length-1 ]*1;
		}

		this._expandButton( buttons, config, base !== undefined, idx );
		this._draw();

		return this;
	},

	/**
	 * Get the container node for the buttons
	 * @return {jQuery} Buttons node
	 */
	container: function ()
	{
		return this.dom.container;
	},

	/**
	 * Disable a button
	 * @param  {node} node Button node
	 * @return {Buttons} Self for chaining
	 */
	disable: function ( node ) {
		var button = this._nodeToButton( node );

		$(button.node).addClass( this.c.dom.button.disabled );

		return this;
	},

	/**
	 * Destroy the instance, cleaning up event handlers and removing DOM
	 * elements
	 * @return {Buttons} Self for chaining
	 */
	destroy: function ()
	{
		// Key event listener
		$('body').off( 'keyup.'+this.s.namespace );

		// Individual button destroy (so they can remove their own events if
		// needed). Take a copy as the array is modified by `remove`
		var buttons = this.s.buttons.slice();
		var i, ien;
		
		for ( i=0, ien=buttons.length ; i<ien ; i++ ) {
			this.remove( buttons[i].node );
		}

		// Container
		this.dom.container.remove();

		// Remove from the settings object collection
		var buttonInsts = this.s.dt.settings()[0];

		for ( i=0, ien=buttonInsts.length ; i<ien ; i++ ) {
			if ( buttonInsts.inst === this ) {
				buttonInsts.splice( i, 1 );
				break;
			}
		}

		return this;
	},

	/**
	 * Enable / disable a button
	 * @param  {node} node Button node
	 * @param  {boolean} [flag=true] Enable / disable flag
	 * @return {Buttons} Self for chaining
	 */
	enable: function ( node, flag )
	{
		if ( flag === false ) {
			return this.disable( node );
		}

		var button = this._nodeToButton( node );
		$(button.node).removeClass( this.c.dom.button.disabled );

		return this;
	},

	/**
	 * Get the instance name for the button set selector
	 * @return {string} Instance name
	 */
	name: function ()
	{
		return this.c.name;
	},

	/**
	 * Get a button's node of the buttons container if no button is given
	 * @param  {node} [node] Button node
	 * @return {jQuery} Button element, or container
	 */
	node: function ( node )
	{
		if ( ! node ) {
			return this.dom.container;
		}

		var button = this._nodeToButton( node );
		return $(button.node);
	},

	/**
	 * Set / get a processing class on the selected button
	 * @param {element} node Triggering button node
	 * @param  {boolean} flag true to add, false to remove, undefined to get
	 * @return {boolean|Buttons} Getter value or this if a setter.
	 */
	processing: function ( node, flag )
	{
		var dt = this.s.dt;
		var button = this._nodeToButton( node );

		if ( flag === undefined ) {
			return $(button.node).hasClass( 'processing' );
		}

		$(button.node).toggleClass( 'processing', flag );

		$(dt.table().node()).triggerHandler( 'buttons-processing.dt', [
			flag, dt.button( node ), dt, $(node), button.conf
		] );

		return this;
	},

	/**
	 * Remove a button.
	 * @param  {node} node Button node
	 * @return {Buttons} Self for chaining
	 */
	remove: function ( node )
	{
		var button = this._nodeToButton( node );
		var host = this._nodeToHost( node );
		var dt = this.s.dt;

		// Remove any child buttons first
		if ( button.buttons.length ) {
			for ( var i=button.buttons.length-1 ; i>=0 ; i-- ) {
				this.remove( button.buttons[i].node );
			}
		}

		// Allow the button to remove event handlers, etc
		if ( button.conf.destroy ) {
			button.conf.destroy.call( dt.button(node), dt, $(node), button.conf );
		}

		this._removeKey( button.conf );

		$(button.node).remove();

		var idx = $.inArray( button, host );
		host.splice( idx, 1 );

		return this;
	},

	/**
	 * Get the text for a button
	 * @param  {int|string} node Button index
	 * @return {string} Button text
	 *//**
	 * Set the text for a button
	 * @param  {int|string|function} node Button index
	 * @param  {string} label Text
	 * @return {Buttons} Self for chaining
	 */
	text: function ( node, label )
	{
		var button = this._nodeToButton( node );
		var buttonLiner = this.c.dom.collection.buttonLiner;
		var linerTag = button.inCollection && buttonLiner && buttonLiner.tag ?
			buttonLiner.tag :
			this.c.dom.buttonLiner.tag;
		var dt = this.s.dt;
		var jqNode = $(button.node);
		var text = function ( opt ) {
			return typeof opt === 'function' ?
				opt( dt, jqNode, button.conf ) :
				opt;
		};

		if ( label === undefined ) {
			return text( button.conf.text );
		}

		button.conf.text = label;

		if ( linerTag ) {
			jqNode.children( linerTag ).html( text(label) );
		}
		else {
			jqNode.html( text(label) );
		}

		return this;
	},


	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Constructor
	 */

	/**
	 * Buttons constructor
	 * @private
	 */
	_constructor: function ()
	{
		var that = this;
		var dt = this.s.dt;
		var dtSettings = dt.settings()[0];
		var buttons =  this.c.buttons;

		if ( ! dtSettings._buttons ) {
			dtSettings._buttons = [];
		}

		dtSettings._buttons.push( {
			inst: this,
			name: this.c.name
		} );

		for ( var i=0, ien=buttons.length ; i<ien ; i++ ) {
			this.add( buttons[i] );
		}

		dt.on( 'destroy', function ( e, settings ) {
			if ( settings === dtSettings ) {
				that.destroy();
			}
		} );

		// Global key event binding to listen for button keys
		$('body').on( 'keyup.'+this.s.namespace, function ( e ) {
			if ( ! document.activeElement || document.activeElement === document.body ) {
				// SUse a string of characters for fast lookup of if we need to
				// handle this
				var character = String.fromCharCode(e.keyCode).toLowerCase();

				if ( that.s.listenKeys.toLowerCase().indexOf( character ) !== -1 ) {
					that._keypress( character, e );
				}
			}
		} );
	},


	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Private methods
	 */

	/**
	 * Add a new button to the key press listener
	 * @param {object} conf Resolved button configuration object
	 * @private
	 */
	_addKey: function ( conf )
	{
		if ( conf.key ) {
			this.s.listenKeys += $.isPlainObject( conf.key ) ?
				conf.key.key :
				conf.key;
		}
	},

	/**
	 * Insert the buttons into the container. Call without parameters!
	 * @param  {node} [container] Recursive only - Insert point
	 * @param  {array} [buttons] Recursive only - Buttons array
	 * @private
	 */
	_draw: function ( container, buttons )
	{
		if ( ! container ) {
			container = this.dom.container;
			buttons = this.s.buttons;
		}

		container.children().detach();

		for ( var i=0, ien=buttons.length ; i<ien ; i++ ) {
			container.append( buttons[i].inserter );
			container.append( ' ' );

			if ( buttons[i].buttons && buttons[i].buttons.length ) {
				this._draw( buttons[i].collection, buttons[i].buttons );
			}
		}
	},

	/**
	 * Create buttons from an array of buttons
	 * @param  {array} attachTo Buttons array to attach to
	 * @param  {object} button Button definition
	 * @param  {boolean} inCollection true if the button is in a collection
	 * @private
	 */
	_expandButton: function ( attachTo, button, inCollection, attachPoint )
	{
		var dt = this.s.dt;
		var buttonCounter = 0;
		var buttons = ! $.isArray( button ) ?
			[ button ] :
			button;

		for ( var i=0, ien=buttons.length ; i<ien ; i++ ) {
			var conf = this._resolveExtends( buttons[i] );

			if ( ! conf ) {
				continue;
			}

			// If the configuration is an array, then expand the buttons at this
			// point
			if ( $.isArray( conf ) ) {
				this._expandButton( attachTo, conf, inCollection, attachPoint );
				continue;
			}

			var built = this._buildButton( conf, inCollection );
			if ( ! built ) {
				continue;
			}

			if ( attachPoint !== undefined ) {
				attachTo.splice( attachPoint, 0, built );
				attachPoint++;
			}
			else {
				attachTo.push( built );
			}

			if ( built.conf.buttons ) {
				built.collection = $('<'+this.c.dom.collection.tag+'/>');

				built.conf._collection = built.collection;

				this._expandButton( built.buttons, built.conf.buttons, true, attachPoint );
			}

			// init call is made here, rather than buildButton as it needs to
			// be selectable, and for that it needs to be in the buttons array
			if ( conf.init ) {
				conf.init.call( dt.button( built.node ), dt, $(built.node), conf );
			}

			buttonCounter++;
		}
	},

	/**
	 * Create an individual button
	 * @param  {object} config            Resolved button configuration
	 * @param  {boolean} inCollection `true` if a collection button
	 * @return {jQuery} Created button node (jQuery)
	 * @private
	 */
	_buildButton: function ( config, inCollection )
	{
		var buttonDom = this.c.dom.button;
		var linerDom = this.c.dom.buttonLiner;
		var collectionDom = this.c.dom.collection;
		var dt = this.s.dt;
		var text = function ( opt ) {
			return typeof opt === 'function' ?
				opt( dt, button, config ) :
				opt;
		};

		if ( inCollection && collectionDom.button ) {
			buttonDom = collectionDom.button;
		}

		if ( inCollection && collectionDom.buttonLiner ) {
			linerDom = collectionDom.buttonLiner;
		}

		// Make sure that the button is available based on whatever requirements
		// it has. For example, Flash buttons require Flash
		if ( config.available && ! config.available( dt, config ) ) {
			return false;
		}

		var action = function ( e, dt, button, config ) {
			config.action.call( dt.button( button ), e, dt, button, config );

			$(dt.table().node()).triggerHandler( 'buttons-action.dt', [
				dt.button( button ), dt, button, config 
			] );
		};

		var tag = config.tag || buttonDom.tag;
		var clickBlurs = config.clickBlurs === undefined ? true : config.clickBlurs
		var button = $('<'+tag+'/>')
			.addClass( buttonDom.className )
			.attr( 'tabindex', this.s.dt.settings()[0].iTabIndex )
			.attr( 'aria-controls', this.s.dt.table().node().id )
			.on( 'click.dtb', function (e) {
				e.preventDefault();

				if ( ! button.hasClass( buttonDom.disabled ) && config.action ) {
					action( e, dt, button, config );
				}
				if( clickBlurs ) {
					button.blur();
				}
			} )
			.on( 'keyup.dtb', function (e) {
				if ( e.keyCode === 13 ) {
					if ( ! button.hasClass( buttonDom.disabled ) && config.action ) {
						action( e, dt, button, config );
					}
				}
			} );

		// Make `a` tags act like a link
		if ( tag.toLowerCase() === 'a' ) {
			button.attr( 'href', '#' );
		}

		// Button tags should have `type=button` so they don't have any default behaviour
		if ( tag.toLowerCase() === 'button' ) {
			button.attr( 'type', 'button' );
		}

		if ( linerDom.tag ) {
			var liner = $('<'+linerDom.tag+'/>')
				.html( text( config.text ) )
				.addClass( linerDom.className );

			if ( linerDom.tag.toLowerCase() === 'a' ) {
				liner.attr( 'href', '#' );
			}

			button.append( liner );
		}
		else {
			button.html( text( config.text ) );
		}

		if ( config.enabled === false ) {
			button.addClass( buttonDom.disabled );
		}

		if ( config.className ) {
			button.addClass( config.className );
		}

		if ( config.titleAttr ) {
			button.attr( 'title', text( config.titleAttr ) );
		}

		if ( config.attr ) {
			button.attr( config.attr );
		}

		if ( ! config.namespace ) {
			config.namespace = '.dt-button-'+(_buttonCounter++);
		}

		var buttonContainer = this.c.dom.buttonContainer;
		var inserter;
		if ( buttonContainer && buttonContainer.tag ) {
			inserter = $('<'+buttonContainer.tag+'/>')
				.addClass( buttonContainer.className )
				.append( button );
		}
		else {
			inserter = button;
		}

		this._addKey( config );

		// Style integration callback for DOM manipulation
		// Note that this is _not_ documented. It is currently
		// for style integration only
		if( this.c.buttonCreated ) {
			inserter = this.c.buttonCreated( config, inserter );
		}

		return {
			conf:         config,
			node:         button.get(0),
			inserter:     inserter,
			buttons:      [],
			inCollection: inCollection,
			collection:   null
		};
	},

	/**
	 * Get the button object from a node (recursive)
	 * @param  {node} node Button node
	 * @param  {array} [buttons] Button array, uses base if not defined
	 * @return {object} Button object
	 * @private
	 */
	_nodeToButton: function ( node, buttons )
	{
		if ( ! buttons ) {
			buttons = this.s.buttons;
		}

		for ( var i=0, ien=buttons.length ; i<ien ; i++ ) {
			if ( buttons[i].node === node ) {
				return buttons[i];
			}

			if ( buttons[i].buttons.length ) {
				var ret = this._nodeToButton( node, buttons[i].buttons );

				if ( ret ) {
					return ret;
				}
			}
		}
	},

	/**
	 * Get container array for a button from a button node (recursive)
	 * @param  {node} node Button node
	 * @param  {array} [buttons] Button array, uses base if not defined
	 * @return {array} Button's host array
	 * @private
	 */
	_nodeToHost: function ( node, buttons )
	{
		if ( ! buttons ) {
			buttons = this.s.buttons;
		}

		for ( var i=0, ien=buttons.length ; i<ien ; i++ ) {
			if ( buttons[i].node === node ) {
				return buttons;
			}

			if ( buttons[i].buttons.length ) {
				var ret = this._nodeToHost( node, buttons[i].buttons );

				if ( ret ) {
					return ret;
				}
			}
		}
	},

	/**
	 * Handle a key press - determine if any button's key configured matches
	 * what was typed and trigger the action if so.
	 * @param  {string} character The character pressed
	 * @param  {object} e Key event that triggered this call
	 * @private
	 */
	_keypress: function ( character, e )
	{
		// Check if this button press already activated on another instance of Buttons
		if ( e._buttonsHandled ) {
			return;
		}

		var run = function ( conf, node ) {
			if ( ! conf.key ) {
				return;
			}

			if ( conf.key === character ) {
				e._buttonsHandled = true;
				$(node).click();
			}
			else if ( $.isPlainObject( conf.key ) ) {
				if ( conf.key.key !== character ) {
					return;
				}

				if ( conf.key.shiftKey && ! e.shiftKey ) {
					return;
				}

				if ( conf.key.altKey && ! e.altKey ) {
					return;
				}

				if ( conf.key.ctrlKey && ! e.ctrlKey ) {
					return;
				}

				if ( conf.key.metaKey && ! e.metaKey ) {
					return;
				}

				// Made it this far - it is good
				e._buttonsHandled = true;
				$(node).click();
			}
		};

		var recurse = function ( a ) {
			for ( var i=0, ien=a.length ; i<ien ; i++ ) {
				run( a[i].conf, a[i].node );

				if ( a[i].buttons.length ) {
					recurse( a[i].buttons );
				}
			}
		};

		recurse( this.s.buttons );
	},

	/**
	 * Remove a key from the key listener for this instance (to be used when a
	 * button is removed)
	 * @param  {object} conf Button configuration
	 * @private
	 */
	_removeKey: function ( conf )
	{
		if ( conf.key ) {
			var character = $.isPlainObject( conf.key ) ?
				conf.key.key :
				conf.key;

			// Remove only one character, as multiple buttons could have the
			// same listening key
			var a = this.s.listenKeys.split('');
			var idx = $.inArray( character, a );
			a.splice( idx, 1 );
			this.s.listenKeys = a.join('');
		}
	},

	/**
	 * Resolve a button configuration
	 * @param  {string|function|object} conf Button config to resolve
	 * @return {object} Button configuration
	 * @private
	 */
	_resolveExtends: function ( conf )
	{
		var dt = this.s.dt;
		var i, ien;
		var toConfObject = function ( base ) {
			var loop = 0;

			// Loop until we have resolved to a button configuration, or an
			// array of button configurations (which will be iterated
			// separately)
			while ( ! $.isPlainObject(base) && ! $.isArray(base) ) {
				if ( base === undefined ) {
					return;
				}

				if ( typeof base === 'function' ) {
					base = base( dt, conf );

					if ( ! base ) {
						return false;
					}
				}
				else if ( typeof base === 'string' ) {
					if ( ! _dtButtons[ base ] ) {
						throw 'Unknown button type: '+base;
					}

					base = _dtButtons[ base ];
				}

				loop++;
				if ( loop > 30 ) {
					// Protect against misconfiguration killing the browser
					throw 'Buttons: Too many iterations';
				}
			}

			return $.isArray( base ) ?
				base :
				$.extend( {}, base );
		};

		conf = toConfObject( conf );

		while ( conf && conf.extend ) {
			// Use `toConfObject` in case the button definition being extended
			// is itself a string or a function
			if ( ! _dtButtons[ conf.extend ] ) {
				throw 'Cannot extend unknown button type: '+conf.extend;
			}

			var objArray = toConfObject( _dtButtons[ conf.extend ] );
			if ( $.isArray( objArray ) ) {
				return objArray;
			}
			else if ( ! objArray ) {
				// This is a little brutal as it might be possible to have a
				// valid button without the extend, but if there is no extend
				// then the host button would be acting in an undefined state
				return false;
			}

			// Stash the current class name
			var originalClassName = objArray.className;

			conf = $.extend( {}, objArray, conf );

			// The extend will have overwritten the original class name if the
			// `conf` object also assigned a class, but we want to concatenate
			// them so they are list that is combined from all extended buttons
			if ( originalClassName && conf.className !== originalClassName ) {
				conf.className = originalClassName+' '+conf.className;
			}

			// Buttons to be added to a collection  -gives the ability to define
			// if buttons should be added to the start or end of a collection
			var postfixButtons = conf.postfixButtons;
			if ( postfixButtons ) {
				if ( ! conf.buttons ) {
					conf.buttons = [];
				}

				for ( i=0, ien=postfixButtons.length ; i<ien ; i++ ) {
					conf.buttons.push( postfixButtons[i] );
				}

				conf.postfixButtons = null;
			}

			var prefixButtons = conf.prefixButtons;
			if ( prefixButtons ) {
				if ( ! conf.buttons ) {
					conf.buttons = [];
				}

				for ( i=0, ien=prefixButtons.length ; i<ien ; i++ ) {
					conf.buttons.splice( i, 0, prefixButtons[i] );
				}

				conf.prefixButtons = null;
			}

			// Although we want the `conf` object to overwrite almost all of
			// the properties of the object being extended, the `extend`
			// property should come from the object being extended
			conf.extend = objArray.extend;
		}

		return conf;
	},

	/**
	 * Display (and replace if there is an existing one) a popover attached to a button
	 * @param {string|node} content Content to show
	 * @param {DataTable.Api} hostButton DT API instance of the button
	 * @param {object} inOpts Options (see object below for all options)
	 */
	_popover: function ( content, hostButton, inOpts ) {
		var dt = hostButton;
		var buttonsSettings = this.c;
		var options = $.extend( {
			align: 'button-left', // button-right, dt-container
			autoClose: false,
			background: true,
			backgroundClassName: 'dt-button-background',
			contentClassName: buttonsSettings.dom.collection.className,
			collectionLayout: '',
			collectionTitle: '',
			dropup: false,
			fade: 400,
			rightAlignClassName: 'dt-button-right',
			tag: buttonsSettings.dom.collection.tag
		}, inOpts );
		var hostNode = hostButton.node();

		var close = function () {
			$('.dt-button-collection').stop().fadeOut( options.fade, function () {
				$(this).detach();
			} );

			$(dt.buttons( '[aria-haspopup="true"][aria-expanded="true"]' ).nodes())
				.attr('aria-expanded', 'false');

			$('div.dt-button-background').off( 'click.dtb-collection' );
			Buttons.background( false, options.backgroundClassName, options.fade, hostNode );

			$('body').off( '.dtb-collection' );
			dt.off( 'buttons-action.b-internal' );
		};

		if (content === false) {
			close();
		}

		var existingExpanded = $(dt.buttons( '[aria-haspopup="true"][aria-expanded="true"]' ).nodes());
		if ( existingExpanded.length ) {
			hostNode = existingExpanded.eq(0);

			close();
		}

		var display = $('<div/>')
			.addClass('dt-button-collection')
			.addClass(options.collectionLayout)
			.css('display', 'none');

		content = $(content)
			.addClass(options.contentClassName)
			.attr('role', 'menu')
			.appendTo(display);

		hostNode.attr( 'aria-expanded', 'true' );

		if ( hostNode.parents('body')[0] !== document.body ) {
			hostNode = document.body.lastChild;
		}

		if ( options.collectionTitle ) {
			display.prepend('<div class="dt-button-collection-title">'+options.collectionTitle+'</div>');
		}

		display
			.insertAfter( hostNode )
			.fadeIn( options.fade );

		var tableContainer = $( hostButton.table().container() );
		var position = display.css( 'position' );

		if ( options.align === 'dt-container' ) {
			hostNode = hostNode.parent();
			display.css('width', tableContainer.width());
		}

		if ( position === 'absolute' ) {
			var hostPosition = hostNode.position();

			display.css( {
				top: hostPosition.top + hostNode.outerHeight(),
				left: hostPosition.left
			} );

			// calculate overflow when positioned beneath
			var collectionHeight = display.outerHeight();
			var collectionWidth = display.outerWidth();
			var tableBottom = tableContainer.offset().top + tableContainer.height();
			var listBottom = hostPosition.top + hostNode.outerHeight() + collectionHeight;
			var bottomOverflow = listBottom - tableBottom;

			// calculate overflow when positioned above
			var listTop = hostPosition.top - collectionHeight;
			var tableTop = tableContainer.offset().top;
			var topOverflow = tableTop - listTop;

			// if bottom overflow is larger, move to the top because it fits better, or if dropup is requested
			var moveTop = hostPosition.top - collectionHeight - 5;
			if ( (bottomOverflow > topOverflow || options.dropup) && -moveTop < tableTop ) {
				display.css( 'top', moveTop);
			}

			// Right alignment is enabled on a class, e.g. bootstrap:
			// $.fn.dataTable.Buttons.defaults.dom.collection.className += " dropdown-menu-right"; 
			if ( display.hasClass( options.rightAlignClassName ) || options.align === 'button-right' ) {
				display.css( 'left', hostPosition.left + hostNode.outerWidth() - collectionWidth );
			}

			// Right alignment in table container
			var listRight = hostPosition.left + collectionWidth;
			var tableRight = tableContainer.offset().left + tableContainer.width();
			if ( listRight > tableRight ) {
				display.css( 'left', hostPosition.left - ( listRight - tableRight ) );
			}

			// Right alignment to window
			var listOffsetRight = hostNode.offset().left + collectionWidth;
			if ( listOffsetRight > $(window).width() ) {
				display.css( 'left', hostPosition.left - (listOffsetRight-$(window).width()) );
			}
		}
		else {
			// Fix position - centre on screen
			var top = display.height() / 2;
			if ( top > $(window).height() / 2 ) {
				top = $(window).height() / 2;
			}

			display.css( 'marginTop', top*-1 );
		}

		if ( options.background ) {
			Buttons.background( true, options.backgroundClassName, options.fade, hostNode );
		}

		// This is bonkers, but if we don't have a click listener on the
		// background element, iOS Safari will ignore the body click
		// listener below. An empty function here is all that is
		// required to make it work...
		$('div.dt-button-background').on( 'click.dtb-collection', function () {} );

		$('body')
			.on( 'click.dtb-collection', function (e) {
				// andSelf is deprecated in jQ1.8, but we want 1.7 compat
				var back = $.fn.addBack ? 'addBack' : 'andSelf';

				if ( ! $(e.target).parents()[back]().filter( content ).length ) {
					close();
				}
			} )
			.on( 'keyup.dtb-collection', function (e) {
				if ( e.keyCode === 27 ) {
					close();
				}
			} );

		if ( options.autoClose ) {
			setTimeout( function () {
				dt.on( 'buttons-action.b-internal', function (e, btn, dt, node) {
					if ( node[0] === hostNode[0] ) {
						return;
					}
					close();
				} );
			}, 0);
		}
	}
} );



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Statics
 */

/**
 * Show / hide a background layer behind a collection
 * @param  {boolean} Flag to indicate if the background should be shown or
 *   hidden 
 * @param  {string} Class to assign to the background
 * @static
 */
Buttons.background = function ( show, className, fade, insertPoint ) {
	if ( fade === undefined ) {
		fade = 400;
	}
	if ( ! insertPoint ) {
		insertPoint = document.body;
	}

	if ( show ) {
		$('<div/>')
			.addClass( className )
			.css( 'display', 'none' )
			.insertAfter( insertPoint )
			.stop()
			.fadeIn( fade );
	}
	else {
		$('div.'+className)
			.stop()
			.fadeOut( fade, function () {
				$(this)
					.removeClass( className )
					.remove();
			} );
	}
};

/**
 * Instance selector - select Buttons instances based on an instance selector
 * value from the buttons assigned to a DataTable. This is only useful if
 * multiple instances are attached to a DataTable.
 * @param  {string|int|array} Instance selector - see `instance-selector`
 *   documentation on the DataTables site
 * @param  {array} Button instance array that was attached to the DataTables
 *   settings object
 * @return {array} Buttons instances
 * @static
 */
Buttons.instanceSelector = function ( group, buttons )
{
	if ( group === undefined || group === null ) {
		return $.map( buttons, function ( v ) {
			return v.inst;
		} );
	}

	var ret = [];
	var names = $.map( buttons, function ( v ) {
		return v.name;
	} );

	// Flatten the group selector into an array of single options
	var process = function ( input ) {
		if ( $.isArray( input ) ) {
			for ( var i=0, ien=input.length ; i<ien ; i++ ) {
				process( input[i] );
			}
			return;
		}

		if ( typeof input === 'string' ) {
			if ( input.indexOf( ',' ) !== -1 ) {
				// String selector, list of names
				process( input.split(',') );
			}
			else {
				// String selector individual name
				var idx = $.inArray( $.trim(input), names );

				if ( idx !== -1 ) {
					ret.push( buttons[ idx ].inst );
				}
			}
		}
		else if ( typeof input === 'number' ) {
			// Index selector
			ret.push( buttons[ input ].inst );
		}
	};
	
	process( group );

	return ret;
};

/**
 * Button selector - select one or more buttons from a selector input so some
 * operation can be performed on them.
 * @param  {array} Button instances array that the selector should operate on
 * @param  {string|int|node|jQuery|array} Button selector - see
 *   `button-selector` documentation on the DataTables site
 * @return {array} Array of objects containing `inst` and `idx` properties of
 *   the selected buttons so you know which instance each button belongs to.
 * @static
 */
Buttons.buttonSelector = function ( insts, selector )
{
	var ret = [];
	var nodeBuilder = function ( a, buttons, baseIdx ) {
		var button;
		var idx;

		for ( var i=0, ien=buttons.length ; i<ien ; i++ ) {
			button = buttons[i];

			if ( button ) {
				idx = baseIdx !== undefined ?
					baseIdx+i :
					i+'';

				a.push( {
					node: button.node,
					name: button.conf.name,
					idx:  idx
				} );

				if ( button.buttons ) {
					nodeBuilder( a, button.buttons, idx+'-' );
				}
			}
		}
	};

	var run = function ( selector, inst ) {
		var i, ien;
		var buttons = [];
		nodeBuilder( buttons, inst.s.buttons );

		var nodes = $.map( buttons, function (v) {
			return v.node;
		} );

		if ( $.isArray( selector ) || selector instanceof $ ) {
			for ( i=0, ien=selector.length ; i<ien ; i++ ) {
				run( selector[i], inst );
			}
			return;
		}

		if ( selector === null || selector === undefined || selector === '*' ) {
			// Select all
			for ( i=0, ien=buttons.length ; i<ien ; i++ ) {
				ret.push( {
					inst: inst,
					node: buttons[i].node
				} );
			}
		}
		else if ( typeof selector === 'number' ) {
			// Main button index selector
			ret.push( {
				inst: inst,
				node: inst.s.buttons[ selector ].node
			} );
		}
		else if ( typeof selector === 'string' ) {
			if ( selector.indexOf( ',' ) !== -1 ) {
				// Split
				var a = selector.split(',');

				for ( i=0, ien=a.length ; i<ien ; i++ ) {
					run( $.trim(a[i]), inst );
				}
			}
			else if ( selector.match( /^\d+(\-\d+)*$/ ) ) {
				// Sub-button index selector
				var indexes = $.map( buttons, function (v) {
					return v.idx;
				} );

				ret.push( {
					inst: inst,
					node: buttons[ $.inArray( selector, indexes ) ].node
				} );
			}
			else if ( selector.indexOf( ':name' ) !== -1 ) {
				// Button name selector
				var name = selector.replace( ':name', '' );

				for ( i=0, ien=buttons.length ; i<ien ; i++ ) {
					if ( buttons[i].name === name ) {
						ret.push( {
							inst: inst,
							node: buttons[i].node
						} );
					}
				}
			}
			else {
				// jQuery selector on the nodes
				$( nodes ).filter( selector ).each( function () {
					ret.push( {
						inst: inst,
						node: this
					} );
				} );
			}
		}
		else if ( typeof selector === 'object' && selector.nodeName ) {
			// Node selector
			var idx = $.inArray( selector, nodes );

			if ( idx !== -1 ) {
				ret.push( {
					inst: inst,
					node: nodes[ idx ]
				} );
			}
		}
	};


	for ( var i=0, ien=insts.length ; i<ien ; i++ ) {
		var inst = insts[i];

		run( selector, inst );
	}

	return ret;
};


/**
 * Buttons defaults. For full documentation, please refer to the docs/option
 * directory or the DataTables site.
 * @type {Object}
 * @static
 */
Buttons.defaults = {
	buttons: [ 'copy', 'excel', 'csv', 'pdf', 'print' ],
	name: 'main',
	tabIndex: 0,
	dom: {
		container: {
			tag: 'div',
			className: 'dt-buttons'
		},
		collection: {
			tag: 'div',
			className: ''
		},
		button: {
			// Flash buttons will not work with `<button>` in IE - it has to be `<a>`
			tag: 'ActiveXObject' in window ?
				'a' :
				'button',
			className: 'dt-button',
			active: 'active',
			disabled: 'disabled'
		},
		buttonLiner: {
			tag: 'span',
			className: ''
		}
	}
};

/**
 * Version information
 * @type {string}
 * @static
 */
Buttons.version = '1.6.1';


$.extend( _dtButtons, {
	collection: {
		text: function ( dt ) {
			return dt.i18n( 'buttons.collection', 'Collection' );
		},
		className: 'buttons-collection',
		init: function ( dt, button, config ) {
			button.attr( 'aria-expanded', false );
		},
		action: function ( e, dt, button, config ) {
			e.stopPropagation();

			if ( config._collection.parents('body').length ) {
				this.popover(false, config);
			}
			else {
				this.popover(config._collection, config);
			}
		},
		attr: {
			'aria-haspopup': true
		}
		// Also the popover options, defined in Buttons.popover
	},
	copy: function ( dt, conf ) {
		if ( _dtButtons.copyHtml5 ) {
			return 'copyHtml5';
		}
		if ( _dtButtons.copyFlash && _dtButtons.copyFlash.available( dt, conf ) ) {
			return 'copyFlash';
		}
	},
	csv: function ( dt, conf ) {
		// Common option that will use the HTML5 or Flash export buttons
		if ( _dtButtons.csvHtml5 && _dtButtons.csvHtml5.available( dt, conf ) ) {
			return 'csvHtml5';
		}
		if ( _dtButtons.csvFlash && _dtButtons.csvFlash.available( dt, conf ) ) {
			return 'csvFlash';
		}
	},
	excel: function ( dt, conf ) {
		// Common option that will use the HTML5 or Flash export buttons
		if ( _dtButtons.excelHtml5 && _dtButtons.excelHtml5.available( dt, conf ) ) {
			return 'excelHtml5';
		}
		if ( _dtButtons.excelFlash && _dtButtons.excelFlash.available( dt, conf ) ) {
			return 'excelFlash';
		}
	},
	pdf: function ( dt, conf ) {
		// Common option that will use the HTML5 or Flash export buttons
		if ( _dtButtons.pdfHtml5 && _dtButtons.pdfHtml5.available( dt, conf ) ) {
			return 'pdfHtml5';
		}
		if ( _dtButtons.pdfFlash && _dtButtons.pdfFlash.available( dt, conf ) ) {
			return 'pdfFlash';
		}
	},
	pageLength: function ( dt ) {
		var lengthMenu = dt.settings()[0].aLengthMenu;
		var vals = $.isArray( lengthMenu[0] ) ? lengthMenu[0] : lengthMenu;
		var lang = $.isArray( lengthMenu[0] ) ? lengthMenu[1] : lengthMenu;
		var text = function ( dt ) {
			return dt.i18n( 'buttons.pageLength', {
				"-1": 'Show all rows',
				_:    'Show %d rows'
			}, dt.page.len() );
		};

		return {
			extend: 'collection',
			text: text,
			className: 'buttons-page-length',
			autoClose: true,
			buttons: $.map( vals, function ( val, i ) {
				return {
					text: lang[i],
					className: 'button-page-length',
					action: function ( e, dt ) {
						dt.page.len( val ).draw();
					},
					init: function ( dt, node, conf ) {
						var that = this;
						var fn = function () {
							that.active( dt.page.len() === val );
						};

						dt.on( 'length.dt'+conf.namespace, fn );
						fn();
					},
					destroy: function ( dt, node, conf ) {
						dt.off( 'length.dt'+conf.namespace );
					}
				};
			} ),
			init: function ( dt, node, conf ) {
				var that = this;
				dt.on( 'length.dt'+conf.namespace, function () {
					that.text( conf.text );
				} );
			},
			destroy: function ( dt, node, conf ) {
				dt.off( 'length.dt'+conf.namespace );
			}
		};
	}
} );


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * DataTables API
 *
 * For complete documentation, please refer to the docs/api directory or the
 * DataTables site
 */

// Buttons group and individual button selector
DataTable.Api.register( 'buttons()', function ( group, selector ) {
	// Argument shifting
	if ( selector === undefined ) {
		selector = group;
		group = undefined;
	}

	this.selector.buttonGroup = group;

	var res = this.iterator( true, 'table', function ( ctx ) {
		if ( ctx._buttons ) {
			return Buttons.buttonSelector(
				Buttons.instanceSelector( group, ctx._buttons ),
				selector
			);
		}
	}, true );

	res._groupSelector = group;
	return res;
} );

// Individual button selector
DataTable.Api.register( 'button()', function ( group, selector ) {
	// just run buttons() and truncate
	var buttons = this.buttons( group, selector );

	if ( buttons.length > 1 ) {
		buttons.splice( 1, buttons.length );
	}

	return buttons;
} );

// Active buttons
DataTable.Api.registerPlural( 'buttons().active()', 'button().active()', function ( flag ) {
	if ( flag === undefined ) {
		return this.map( function ( set ) {
			return set.inst.active( set.node );
		} );
	}

	return this.each( function ( set ) {
		set.inst.active( set.node, flag );
	} );
} );

// Get / set button action
DataTable.Api.registerPlural( 'buttons().action()', 'button().action()', function ( action ) {
	if ( action === undefined ) {
		return this.map( function ( set ) {
			return set.inst.action( set.node );
		} );
	}

	return this.each( function ( set ) {
		set.inst.action( set.node, action );
	} );
} );

// Enable / disable buttons
DataTable.Api.register( ['buttons().enable()', 'button().enable()'], function ( flag ) {
	return this.each( function ( set ) {
		set.inst.enable( set.node, flag );
	} );
} );

// Disable buttons
DataTable.Api.register( ['buttons().disable()', 'button().disable()'], function () {
	return this.each( function ( set ) {
		set.inst.disable( set.node );
	} );
} );

// Get button nodes
DataTable.Api.registerPlural( 'buttons().nodes()', 'button().node()', function () {
	var jq = $();

	// jQuery will automatically reduce duplicates to a single entry
	$( this.each( function ( set ) {
		jq = jq.add( set.inst.node( set.node ) );
	} ) );

	return jq;
} );

// Get / set button processing state
DataTable.Api.registerPlural( 'buttons().processing()', 'button().processing()', function ( flag ) {
	if ( flag === undefined ) {
		return this.map( function ( set ) {
			return set.inst.processing( set.node );
		} );
	}

	return this.each( function ( set ) {
		set.inst.processing( set.node, flag );
	} );
} );

// Get / set button text (i.e. the button labels)
DataTable.Api.registerPlural( 'buttons().text()', 'button().text()', function ( label ) {
	if ( label === undefined ) {
		return this.map( function ( set ) {
			return set.inst.text( set.node );
		} );
	}

	return this.each( function ( set ) {
		set.inst.text( set.node, label );
	} );
} );

// Trigger a button's action
DataTable.Api.registerPlural( 'buttons().trigger()', 'button().trigger()', function () {
	return this.each( function ( set ) {
		set.inst.node( set.node ).trigger( 'click' );
	} );
} );

// Button resolver to the popover
DataTable.Api.register( 'button().popover()', function (content, options) {
	return this.map( function ( set ) {
		return set.inst._popover( content, this.button(this[0].node), options );
	} );
} );

// Get the container elements
DataTable.Api.register( 'buttons().containers()', function () {
	var jq = $();
	var groupSelector = this._groupSelector;

	// We need to use the group selector directly, since if there are no buttons
	// the result set will be empty
	this.iterator( true, 'table', function ( ctx ) {
		if ( ctx._buttons ) {
			var insts = Buttons.instanceSelector( groupSelector, ctx._buttons );

			for ( var i=0, ien=insts.length ; i<ien ; i++ ) {
				jq = jq.add( insts[i].container() );
			}
		}
	} );

	return jq;
} );

DataTable.Api.register( 'buttons().container()', function () {
	// API level of nesting is `buttons()` so we can zip into the containers method
	return this.containers().eq(0);
} );

// Add a new button
DataTable.Api.register( 'button().add()', function ( idx, conf ) {
	var ctx = this.context;

	// Don't use `this` as it could be empty - select the instances directly
	if ( ctx.length ) {
		var inst = Buttons.instanceSelector( this._groupSelector, ctx[0]._buttons );

		if ( inst.length ) {
			inst[0].add( conf, idx );
		}
	}

	return this.button( this._groupSelector, idx );
} );

// Destroy the button sets selected
DataTable.Api.register( 'buttons().destroy()', function () {
	this.pluck( 'inst' ).unique().each( function ( inst ) {
		inst.destroy();
	} );

	return this;
} );

// Remove a button
DataTable.Api.registerPlural( 'buttons().remove()', 'buttons().remove()', function () {
	this.each( function ( set ) {
		set.inst.remove( set.node );
	} );

	return this;
} );

// Information box that can be used by buttons
var _infoTimer;
DataTable.Api.register( 'buttons.info()', function ( title, message, time ) {
	var that = this;

	if ( title === false ) {
		this.off('destroy.btn-info');
		$('#datatables_buttons_info').fadeOut( function () {
			$(this).remove();
		} );
		clearTimeout( _infoTimer );
		_infoTimer = null;

		return this;
	}

	if ( _infoTimer ) {
		clearTimeout( _infoTimer );
	}

	if ( $('#datatables_buttons_info').length ) {
		$('#datatables_buttons_info').remove();
	}

	title = title ? '<h2>'+title+'</h2>' : '';

	$('<div id="datatables_buttons_info" class="dt-button-info"/>')
		.html( title )
		.append( $('<div/>')[ typeof message === 'string' ? 'html' : 'append' ]( message ) )
		.css( 'display', 'none' )
		.appendTo( 'body' )
		.fadeIn();

	if ( time !== undefined && time !== 0 ) {
		_infoTimer = setTimeout( function () {
			that.buttons.info( false );
		}, time );
	}

	this.on('destroy.btn-info', function () {
		that.buttons.info(false);
	});

	return this;
} );

// Get data from the table for export - this is common to a number of plug-in
// buttons so it is included in the Buttons core library
DataTable.Api.register( 'buttons.exportData()', function ( options ) {
	if ( this.context.length ) {
		return _exportData( new DataTable.Api( this.context[0] ), options );
	}
} );

// Get information about the export that is common to many of the export data
// types (DRY)
DataTable.Api.register( 'buttons.exportInfo()', function ( conf ) {
	if ( ! conf ) {
		conf = {};
	}

	return {
		filename: _filename( conf ),
		title: _title( conf ),
		messageTop: _message(this, conf.message || conf.messageTop, 'top'),
		messageBottom: _message(this, conf.messageBottom, 'bottom')
	};
} );



/**
 * Get the file name for an exported file.
 *
 * @param {object}	config Button configuration
 * @param {boolean} incExtension Include the file name extension
 */
var _filename = function ( config )
{
	// Backwards compatibility
	var filename = config.filename === '*' && config.title !== '*' && config.title !== undefined && config.title !== null && config.title !== '' ?
		config.title :
		config.filename;

	if ( typeof filename === 'function' ) {
		filename = filename();
	}

	if ( filename === undefined || filename === null ) {
		return null;
	}

	if ( filename.indexOf( '*' ) !== -1 ) {
		filename = $.trim( filename.replace( '*', $('head > title').text() ) );
	}

	// Strip characters which the OS will object to
	filename = filename.replace(/[^a-zA-Z0-9_\u00A1-\uFFFF\.,\-_ !\(\)]/g, "");

	var extension = _stringOrFunction( config.extension );
	if ( ! extension ) {
		extension = '';
	}

	return filename + extension;
};

/**
 * Simply utility method to allow parameters to be given as a function
 *
 * @param {undefined|string|function} option Option
 * @return {null|string} Resolved value
 */
var _stringOrFunction = function ( option )
{
	if ( option === null || option === undefined ) {
		return null;
	}
	else if ( typeof option === 'function' ) {
		return option();
	}
	return option;
};

/**
 * Get the title for an exported file.
 *
 * @param {object} config	Button configuration
 */
var _title = function ( config )
{
	var title = _stringOrFunction( config.title );

	return title === null ?
		null : title.indexOf( '*' ) !== -1 ?
			title.replace( '*', $('head > title').text() || 'Exported data' ) :
			title;
};

var _message = function ( dt, option, position )
{
	var message = _stringOrFunction( option );
	if ( message === null ) {
		return null;
	}

	var caption = $('caption', dt.table().container()).eq(0);
	if ( message === '*' ) {
		var side = caption.css( 'caption-side' );
		if ( side !== position ) {
			return null;
		}

		return caption.length ?
			caption.text() :
			'';
	}

	return message;
};







var _exportTextarea = $('<textarea/>')[0];
var _exportData = function ( dt, inOpts )
{
	var config = $.extend( true, {}, {
		rows:           null,
		columns:        '',
		modifier:       {
			search: 'applied',
			order:  'applied'
		},
		orthogonal:     'display',
		stripHtml:      true,
		stripNewlines:  true,
		decodeEntities: true,
		trim:           true,
		format:         {
			header: function ( d ) {
				return strip( d );
			},
			footer: function ( d ) {
				return strip( d );
			},
			body: function ( d ) {
				return strip( d );
			}
		},
		customizeData: null
	}, inOpts );

	var strip = function ( str ) {
		if ( typeof str !== 'string' ) {
			return str;
		}

		// Always remove script tags
		str = str.replace( /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '' );

		// Always remove comments
		str = str.replace( /<!\-\-.*?\-\->/g, '' );

		if ( config.stripHtml ) {
			str = str.replace( /<[^>]*>/g, '' );
		}

		if ( config.trim ) {
			str = str.replace( /^\s+|\s+$/g, '' );
		}

		if ( config.stripNewlines ) {
			str = str.replace( /\n/g, ' ' );
		}

		if ( config.decodeEntities ) {
			_exportTextarea.innerHTML = str;
			str = _exportTextarea.value;
		}

		return str;
	};


	var header = dt.columns( config.columns ).indexes().map( function (idx) {
		var el = dt.column( idx ).header();
		return config.format.header( el.innerHTML, idx, el );
	} ).toArray();

	var footer = dt.table().footer() ?
		dt.columns( config.columns ).indexes().map( function (idx) {
			var el = dt.column( idx ).footer();
			return config.format.footer( el ? el.innerHTML : '', idx, el );
		} ).toArray() :
		null;
	
	// If Select is available on this table, and any rows are selected, limit the export
	// to the selected rows. If no rows are selected, all rows will be exported. Specify
	// a `selected` modifier to control directly.
	var modifier = $.extend( {}, config.modifier );
	if ( dt.select && typeof dt.select.info === 'function' && modifier.selected === undefined ) {
		if ( dt.rows( config.rows, $.extend( { selected: true }, modifier ) ).any() ) {
			$.extend( modifier, { selected: true } )
		}
	}

	var rowIndexes = dt.rows( config.rows, modifier ).indexes().toArray();
	var selectedCells = dt.cells( rowIndexes, config.columns );
	var cells = selectedCells
		.render( config.orthogonal )
		.toArray();
	var cellNodes = selectedCells
		.nodes()
		.toArray();

	var columns = header.length;
	var rows = columns > 0 ? cells.length / columns : 0;
	var body = [];
	var cellCounter = 0;

	for ( var i=0, ien=rows ; i<ien ; i++ ) {
		var row = [ columns ];

		for ( var j=0 ; j<columns ; j++ ) {
			row[j] = config.format.body( cells[ cellCounter ], i, j, cellNodes[ cellCounter ] );
			cellCounter++;
		}

		body[i] = row;
	}

	var data = {
		header: header,
		footer: footer,
		body:   body
	};

	if ( config.customizeData ) {
		config.customizeData( data );
	}

	return data;
};


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * DataTables interface
 */

// Attach to DataTables objects for global access
$.fn.dataTable.Buttons = Buttons;
$.fn.DataTable.Buttons = Buttons;



// DataTables creation - check if the buttons have been defined for this table,
// they will have been if the `B` option was used in `dom`, otherwise we should
// create the buttons instance here so they can be inserted into the document
// using the API. Listen for `init` for compatibility with pre 1.10.10, but to
// be removed in future.
$(document).on( 'init.dt plugin-init.dt', function (e, settings) {
	if ( e.namespace !== 'dt' ) {
		return;
	}

	var opts = settings.oInit.buttons || DataTable.defaults.buttons;

	if ( opts && ! settings._buttons ) {
		new Buttons( settings, opts ).container();
	}
} );

function _init ( settings ) {
	var api = new DataTable.Api( settings );
	var opts = api.init().buttons || DataTable.defaults.buttons;

	return new Buttons( api, opts ).container();
}

// DataTables `dom` feature option
DataTable.ext.feature.push( {
	fnInit: _init,
	cFeature: "B"
} );

// DataTables 2 layout feature
if ( DataTable.ext.features ) {
	DataTable.ext.features.register( 'buttons', _init );
}


return Buttons;
}));


/*! Bootstrap integration for DataTables' Buttons
 * 2016 SpryMedia Ltd - datatables.net/license
 */

(function( factory ){
	if ( typeof define === 'function' && define.amd ) {
		// AMD
		define( ['jquery', 'datatables.net-bs4', 'datatables.net-buttons'], function ( $ ) {
			return factory( $, window, document );
		} );
	}
	else if ( typeof exports === 'object' ) {
		// CommonJS
		module.exports = function (root, $) {
			if ( ! root ) {
				root = window;
			}

			if ( ! $ || ! $.fn.dataTable ) {
				$ = require('datatables.net-bs4')(root, $).$;
			}

			if ( ! $.fn.dataTable.Buttons ) {
				require('datatables.net-buttons')(root, $);
			}

			return factory( $, root, root.document );
		};
	}
	else {
		// Browser
		factory( jQuery, window, document );
	}
}(function( $, window, document, undefined ) {
'use strict';
var DataTable = $.fn.dataTable;

$.extend( true, DataTable.Buttons.defaults, {
	dom: {
		container: {
			className: 'dt-buttons btn-group flex-wrap'
		},
		button: {
			className: 'btn btn-secondary'
		},
		collection: {
			tag: 'div',
			className: 'dropdown-menu',
			button: {
				tag: 'a',
				className: 'dt-button dropdown-item',
				active: 'active',
				disabled: 'disabled'
			}
		}
	},
	buttonCreated: function ( config, button ) {
		return config.buttons ?
			$('<div class="btn-group"/>').append(button) :
			button;
	}
} );

DataTable.ext.buttons.collection.className += ' dropdown-toggle';
DataTable.ext.buttons.collection.rightAlignClassName = 'dropdown-menu-right';

return DataTable.Buttons;
}));


/*! ColReorder 1.5.2
 * 2010-2019 SpryMedia Ltd - datatables.net/license
 */

/**
 * @summary     ColReorder
 * @description Provide the ability to reorder columns in a DataTable
 * @version     1.5.2
 * @file        dataTables.colReorder.js
 * @author      SpryMedia Ltd (www.sprymedia.co.uk)
 * @contact     www.sprymedia.co.uk/contact
 * @copyright   Copyright 2010-2019 SpryMedia Ltd.
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license/mit
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */
(function( factory ){
	if ( typeof define === 'function' && define.amd ) {
		// AMD
		define( ['jquery', 'datatables.net'], function ( $ ) {
			return factory( $, window, document );
		} );
	}
	else if ( typeof exports === 'object' ) {
		// CommonJS
		module.exports = function (root, $) {
			if ( ! root ) {
				root = window;
			}

			if ( ! $ || ! $.fn.dataTable ) {
				$ = require('datatables.net')(root, $).$;
			}

			return factory( $, root, root.document );
		};
	}
	else {
		// Browser
		factory( jQuery, window, document );
	}
}(function( $, window, document, undefined ) {
'use strict';
var DataTable = $.fn.dataTable;


/**
 * Switch the key value pairing of an index array to be value key (i.e. the old value is now the
 * key). For example consider [ 2, 0, 1 ] this would be returned as [ 1, 2, 0 ].
 *  @method  fnInvertKeyValues
 *  @param   array aIn Array to switch around
 *  @returns array
 */
function fnInvertKeyValues( aIn )
{
	var aRet=[];
	for ( var i=0, iLen=aIn.length ; i<iLen ; i++ )
	{
		aRet[ aIn[i] ] = i;
	}
	return aRet;
}


/**
 * Modify an array by switching the position of two elements
 *  @method  fnArraySwitch
 *  @param   array aArray Array to consider, will be modified by reference (i.e. no return)
 *  @param   int iFrom From point
 *  @param   int iTo Insert point
 *  @returns void
 */
function fnArraySwitch( aArray, iFrom, iTo )
{
	var mStore = aArray.splice( iFrom, 1 )[0];
	aArray.splice( iTo, 0, mStore );
}


/**
 * Switch the positions of nodes in a parent node (note this is specifically designed for
 * table rows). Note this function considers all element nodes under the parent!
 *  @method  fnDomSwitch
 *  @param   string sTag Tag to consider
 *  @param   int iFrom Element to move
 *  @param   int Point to element the element to (before this point), can be null for append
 *  @returns void
 */
function fnDomSwitch( nParent, iFrom, iTo )
{
	var anTags = [];
	for ( var i=0, iLen=nParent.childNodes.length ; i<iLen ; i++ )
	{
		if ( nParent.childNodes[i].nodeType == 1 )
		{
			anTags.push( nParent.childNodes[i] );
		}
	}
	var nStore = anTags[ iFrom ];

	if ( iTo !== null )
	{
		nParent.insertBefore( nStore, anTags[iTo] );
	}
	else
	{
		nParent.appendChild( nStore );
	}
}


/**
 * Plug-in for DataTables which will reorder the internal column structure by taking the column
 * from one position (iFrom) and insert it into a given point (iTo).
 *  @method  $.fn.dataTableExt.oApi.fnColReorder
 *  @param   object oSettings DataTables settings object - automatically added by DataTables!
 *  @param   int iFrom Take the column to be repositioned from this point
 *  @param   int iTo and insert it into this point
 *  @param   bool drop Indicate if the reorder is the final one (i.e. a drop)
 *    not a live reorder
 *  @param   bool invalidateRows speeds up processing if false passed
 *  @returns void
 */
$.fn.dataTableExt.oApi.fnColReorder = function ( oSettings, iFrom, iTo, drop, invalidateRows )
{
	var i, iLen, j, jLen, jen, iCols=oSettings.aoColumns.length, nTrs, oCol;
	var attrMap = function ( obj, prop, mapping ) {
		if ( ! obj[ prop ] || typeof obj[ prop ] === 'function' ) {
			return;
		}

		var a = obj[ prop ].split('.');
		var num = a.shift();

		if ( isNaN( num*1 ) ) {
			return;
		}

		obj[ prop ] = mapping[ num*1 ]+'.'+a.join('.');
	};

	/* Sanity check in the input */
	if ( iFrom == iTo )
	{
		/* Pointless reorder */
		return;
	}

	if ( iFrom < 0 || iFrom >= iCols )
	{
		this.oApi._fnLog( oSettings, 1, "ColReorder 'from' index is out of bounds: "+iFrom );
		return;
	}

	if ( iTo < 0 || iTo >= iCols )
	{
		this.oApi._fnLog( oSettings, 1, "ColReorder 'to' index is out of bounds: "+iTo );
		return;
	}

	/*
	 * Calculate the new column array index, so we have a mapping between the old and new
	 */
	var aiMapping = [];
	for ( i=0, iLen=iCols ; i<iLen ; i++ )
	{
		aiMapping[i] = i;
	}
	fnArraySwitch( aiMapping, iFrom, iTo );
	var aiInvertMapping = fnInvertKeyValues( aiMapping );


	/*
	 * Convert all internal indexing to the new column order indexes
	 */
	/* Sorting */
	for ( i=0, iLen=oSettings.aaSorting.length ; i<iLen ; i++ )
	{
		oSettings.aaSorting[i][0] = aiInvertMapping[ oSettings.aaSorting[i][0] ];
	}

	/* Fixed sorting */
	if ( oSettings.aaSortingFixed !== null )
	{
		for ( i=0, iLen=oSettings.aaSortingFixed.length ; i<iLen ; i++ )
		{
			oSettings.aaSortingFixed[i][0] = aiInvertMapping[ oSettings.aaSortingFixed[i][0] ];
		}
	}

	/* Data column sorting (the column which the sort for a given column should take place on) */
	for ( i=0, iLen=iCols ; i<iLen ; i++ )
	{
		oCol = oSettings.aoColumns[i];
		for ( j=0, jLen=oCol.aDataSort.length ; j<jLen ; j++ )
		{
			oCol.aDataSort[j] = aiInvertMapping[ oCol.aDataSort[j] ];
		}

		// Update the column indexes
		oCol.idx = aiInvertMapping[ oCol.idx ];
	}

	// Update 1.10 optimised sort class removal variable
	$.each( oSettings.aLastSort, function (i, val) {
		oSettings.aLastSort[i].src = aiInvertMapping[ val.src ];
	} );

	/* Update the Get and Set functions for each column */
	for ( i=0, iLen=iCols ; i<iLen ; i++ )
	{
		oCol = oSettings.aoColumns[i];

		if ( typeof oCol.mData == 'number' ) {
			oCol.mData = aiInvertMapping[ oCol.mData ];
		}
		else if ( $.isPlainObject( oCol.mData ) ) {
			// HTML5 data sourced
			attrMap( oCol.mData, '_',      aiInvertMapping );
			attrMap( oCol.mData, 'filter', aiInvertMapping );
			attrMap( oCol.mData, 'sort',   aiInvertMapping );
			attrMap( oCol.mData, 'type',   aiInvertMapping );
		}
	}

	/*
	 * Move the DOM elements
	 */
	if ( oSettings.aoColumns[iFrom].bVisible )
	{
		/* Calculate the current visible index and the point to insert the node before. The insert
		 * before needs to take into account that there might not be an element to insert before,
		 * in which case it will be null, and an appendChild should be used
		 */
		var iVisibleIndex = this.oApi._fnColumnIndexToVisible( oSettings, iFrom );
		var iInsertBeforeIndex = null;

		i = iTo < iFrom ? iTo : iTo + 1;
		while ( iInsertBeforeIndex === null && i < iCols )
		{
			iInsertBeforeIndex = this.oApi._fnColumnIndexToVisible( oSettings, i );
			i++;
		}

		/* Header */
		nTrs = oSettings.nTHead.getElementsByTagName('tr');
		for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
		{
			fnDomSwitch( nTrs[i], iVisibleIndex, iInsertBeforeIndex );
		}

		/* Footer */
		if ( oSettings.nTFoot !== null )
		{
			nTrs = oSettings.nTFoot.getElementsByTagName('tr');
			for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
			{
				fnDomSwitch( nTrs[i], iVisibleIndex, iInsertBeforeIndex );
			}
		}

		/* Body */
		for ( i=0, iLen=oSettings.aoData.length ; i<iLen ; i++ )
		{
			if ( oSettings.aoData[i].nTr !== null )
			{
				fnDomSwitch( oSettings.aoData[i].nTr, iVisibleIndex, iInsertBeforeIndex );
			}
		}
	}

	/*
	 * Move the internal array elements
	 */
	/* Columns */
	fnArraySwitch( oSettings.aoColumns, iFrom, iTo );

	// regenerate the get / set functions
	for ( i=0, iLen=iCols ; i<iLen ; i++ ) {
		oSettings.oApi._fnColumnOptions( oSettings, i, {} );
	}

	/* Search columns */
	fnArraySwitch( oSettings.aoPreSearchCols, iFrom, iTo );

	/* Array array - internal data anodes cache */
	for ( i=0, iLen=oSettings.aoData.length ; i<iLen ; i++ )
	{
		var data = oSettings.aoData[i];
		var cells = data.anCells;

		if ( cells ) {
			fnArraySwitch( cells, iFrom, iTo );

			// Longer term, should this be moved into the DataTables' invalidate
			// methods?
			for ( j=0, jen=cells.length ; j<jen ; j++ ) {
				if ( cells[j] && cells[j]._DT_CellIndex ) {
					cells[j]._DT_CellIndex.column = j;
				}
			}
		}

		// For DOM sourced data, the invalidate will reread the cell into
		// the data array, but for data sources as an array, they need to
		// be flipped
		if ( data.src !== 'dom' && $.isArray( data._aData ) ) {
			fnArraySwitch( data._aData, iFrom, iTo );
		}
	}

	/* Reposition the header elements in the header layout array */
	for ( i=0, iLen=oSettings.aoHeader.length ; i<iLen ; i++ )
	{
		fnArraySwitch( oSettings.aoHeader[i], iFrom, iTo );
	}

	if ( oSettings.aoFooter !== null )
	{
		for ( i=0, iLen=oSettings.aoFooter.length ; i<iLen ; i++ )
		{
			fnArraySwitch( oSettings.aoFooter[i], iFrom, iTo );
		}
	}

	if ( invalidateRows || invalidateRows === undefined )
	{
		$.fn.dataTable.Api( oSettings ).rows().invalidate();
	}

	/*
	 * Update DataTables' event handlers
	 */

	/* Sort listener */
	for ( i=0, iLen=iCols ; i<iLen ; i++ )
	{
		$(oSettings.aoColumns[i].nTh).off('.DT');
		this.oApi._fnSortAttachListener( oSettings, oSettings.aoColumns[i].nTh, i );
	}


	/* Fire an event so other plug-ins can update */
	$(oSettings.oInstance).trigger( 'column-reorder.dt', [ oSettings, {
		from: iFrom,
		to: iTo,
		mapping: aiInvertMapping,
		drop: drop,

		// Old style parameters for compatibility
		iFrom: iFrom,
		iTo: iTo,
		aiInvertMapping: aiInvertMapping
	} ] );
};

/**
 * ColReorder provides column visibility control for DataTables
 * @class ColReorder
 * @constructor
 * @param {object} dt DataTables settings object
 * @param {object} opts ColReorder options
 */
var ColReorder = function( dt, opts )
{
	var settings = new $.fn.dataTable.Api( dt ).settings()[0];

	// Ensure that we can't initialise on the same table twice
	if ( settings._colReorder ) {
		return settings._colReorder;
	}

	// Allow the options to be a boolean for defaults
	if ( opts === true ) {
		opts = {};
	}

	// Convert from camelCase to Hungarian, just as DataTables does
	var camelToHungarian = $.fn.dataTable.camelToHungarian;
	if ( camelToHungarian ) {
		camelToHungarian( ColReorder.defaults, ColReorder.defaults, true );
		camelToHungarian( ColReorder.defaults, opts || {} );
	}


	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Public class variables
	 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

	/**
	 * @namespace Settings object which contains customisable information for ColReorder instance
	 */
	this.s = {
		/**
		 * DataTables settings object
		 *  @property dt
		 *  @type     Object
		 *  @default  null
		 */
		"dt": null,

		/**
		 * Enable flag
		 *  @property dt
		 *  @type     Object
		 *  @default  null
		 */
		"enable": null,

		/**
		 * Initialisation object used for this instance
		 *  @property init
		 *  @type     object
		 *  @default  {}
		 */
		"init": $.extend( true, {}, ColReorder.defaults, opts ),

		/**
		 * Number of columns to fix (not allow to be reordered)
		 *  @property fixed
		 *  @type     int
		 *  @default  0
		 */
		"fixed": 0,

		/**
		 * Number of columns to fix counting from right (not allow to be reordered)
		 *  @property fixedRight
		 *  @type     int
		 *  @default  0
		 */
		"fixedRight": 0,

		/**
		 * Callback function for once the reorder has been done
		 *  @property reorderCallback
		 *  @type     function
		 *  @default  null
		 */
		"reorderCallback": null,

		/**
		 * @namespace Information used for the mouse drag
		 */
		"mouse": {
			"startX": -1,
			"startY": -1,
			"offsetX": -1,
			"offsetY": -1,
			"target": -1,
			"targetIndex": -1,
			"fromIndex": -1
		},

		/**
		 * Information which is used for positioning the insert cusor and knowing where to do the
		 * insert. Array of objects with the properties:
		 *   x: x-axis position
		 *   to: insert point
		 *  @property aoTargets
		 *  @type     array
		 *  @default  []
		 */
		"aoTargets": []
	};


	/**
	 * @namespace Common and useful DOM elements for the class instance
	 */
	this.dom = {
		/**
		 * Dragging element (the one the mouse is moving)
		 *  @property drag
		 *  @type     element
		 *  @default  null
		 */
		"drag": null,

		/**
		 * The insert cursor
		 *  @property pointer
		 *  @type     element
		 *  @default  null
		 */
		"pointer": null
	};

	/* Constructor logic */
	this.s.enable = this.s.init.bEnable;
	this.s.dt = settings;
	this.s.dt._colReorder = this;
	this._fnConstruct();

	return this;
};



$.extend( ColReorder.prototype, {
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Public methods
	 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

	/**
	 * Enable / disable end user interaction
	 */
	fnEnable: function ( flag )
	{
		if ( flag === false ) {
			return fnDisable();
		}

		this.s.enable = true;
	},

	/**
	 * Disable end user interaction
	 */
	fnDisable: function ()
	{
		this.s.enable = false;
	},

	/**
	 * Reset the column ordering to the original ordering that was detected on
	 * start up.
	 *  @return {this} Returns `this` for chaining.
	 *
	 *  @example
	 *    // DataTables initialisation with ColReorder
	 *    var table = $('#example').dataTable( {
	 *        "sDom": 'Rlfrtip'
	 *    } );
	 *
	 *    // Add click event to a button to reset the ordering
	 *    $('#resetOrdering').click( function (e) {
	 *        e.preventDefault();
	 *        $.fn.dataTable.ColReorder( table ).fnReset();
	 *    } );
	 */
	"fnReset": function ()
	{
		this._fnOrderColumns( this.fnOrder() );

		return this;
	},

	/**
	 * `Deprecated` - Get the current order of the columns, as an array.
	 *  @return {array} Array of column identifiers
	 *  @deprecated `fnOrder` should be used in preference to this method.
	 *      `fnOrder` acts as a getter/setter.
	 */
	"fnGetCurrentOrder": function ()
	{
		return this.fnOrder();
	},

	/**
	 * Get the current order of the columns, as an array. Note that the values
	 * given in the array are unique identifiers for each column. Currently
	 * these are the original ordering of the columns that was detected on
	 * start up, but this could potentially change in future.
	 *  @return {array} Array of column identifiers
	 *
	 *  @example
	 *    // Get column ordering for the table
	 *    var order = $.fn.dataTable.ColReorder( dataTable ).fnOrder();
	 *//**
	 * Set the order of the columns, from the positions identified in the
	 * ordering array given. Note that ColReorder takes a brute force approach
	 * to reordering, so it is possible multiple reordering events will occur
	 * before the final order is settled upon.
	 *  @param {array} [set] Array of column identifiers in the new order. Note
	 *    that every column must be included, uniquely, in this array.
	 *  @return {this} Returns `this` for chaining.
	 *
	 *  @example
	 *    // Swap the first and second columns
	 *    $.fn.dataTable.ColReorder( dataTable ).fnOrder( [1, 0, 2, 3, 4] );
	 *
	 *  @example
	 *    // Move the first column to the end for the table `#example`
	 *    var curr = $.fn.dataTable.ColReorder( '#example' ).fnOrder();
	 *    var first = curr.shift();
	 *    curr.push( first );
	 *    $.fn.dataTable.ColReorder( '#example' ).fnOrder( curr );
	 *
	 *  @example
	 *    // Reverse the table's order
	 *    $.fn.dataTable.ColReorder( '#example' ).fnOrder(
	 *      $.fn.dataTable.ColReorder( '#example' ).fnOrder().reverse()
	 *    );
	 */
	"fnOrder": function ( set, original )
	{
		var a = [], i, ien, j, jen;
		var columns = this.s.dt.aoColumns;

		if ( set === undefined ){
			for ( i=0, ien=columns.length ; i<ien ; i++ ) {
				a.push( columns[i]._ColReorder_iOrigCol );
			}

			return a;
		}

		// The order given is based on the original indexes, rather than the
		// existing ones, so we need to translate from the original to current
		// before then doing the order
		if ( original ) {
			var order = this.fnOrder();

			for ( i=0, ien=set.length ; i<ien ; i++ ) {
				a.push( $.inArray( set[i], order ) );
			}

			set = a;
		}

		this._fnOrderColumns( fnInvertKeyValues( set ) );

		return this;
	},


	/**
	 * Convert from the original column index, to the original
	 *
	 * @param  {int|array} idx Index(es) to convert
	 * @param  {string} dir Transpose direction - `fromOriginal` / `toCurrent`
	 *   or `'toOriginal` / `fromCurrent`
	 * @return {int|array}     Converted values
	 */
	fnTranspose: function ( idx, dir )
	{
		if ( ! dir ) {
			dir = 'toCurrent';
		}

		var order = this.fnOrder();
		var columns = this.s.dt.aoColumns;

		if ( dir === 'toCurrent' ) {
			// Given an original index, want the current
			return ! $.isArray( idx ) ?
				$.inArray( idx, order ) :
				$.map( idx, function ( index ) {
					return $.inArray( index, order );
				} );
		}
		else {
			// Given a current index, want the original
			return ! $.isArray( idx ) ?
				columns[idx]._ColReorder_iOrigCol :
				$.map( idx, function ( index ) {
					return columns[index]._ColReorder_iOrigCol;
				} );
		}
	},


	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Private methods (they are of course public in JS, but recommended as private)
	 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

	/**
	 * Constructor logic
	 *  @method  _fnConstruct
	 *  @returns void
	 *  @private
	 */
	"_fnConstruct": function ()
	{
		var that = this;
		var iLen = this.s.dt.aoColumns.length;
		var table = this.s.dt.nTable;
		var i;

		/* Columns discounted from reordering - counting left to right */
		if ( this.s.init.iFixedColumns )
		{
			this.s.fixed = this.s.init.iFixedColumns;
		}

		if ( this.s.init.iFixedColumnsLeft )
		{
			this.s.fixed = this.s.init.iFixedColumnsLeft;
		}

		/* Columns discounted from reordering - counting right to left */
		this.s.fixedRight = this.s.init.iFixedColumnsRight ?
			this.s.init.iFixedColumnsRight :
			0;

		/* Drop callback initialisation option */
		if ( this.s.init.fnReorderCallback )
		{
			this.s.reorderCallback = this.s.init.fnReorderCallback;
		}

		/* Add event handlers for the drag and drop, and also mark the original column order */
		for ( i = 0; i < iLen; i++ )
		{
			if ( i > this.s.fixed-1 && i < iLen - this.s.fixedRight )
			{
				this._fnMouseListener( i, this.s.dt.aoColumns[i].nTh );
			}

			/* Mark the original column order for later reference */
			this.s.dt.aoColumns[i]._ColReorder_iOrigCol = i;
		}

		/* State saving */
		this.s.dt.oApi._fnCallbackReg( this.s.dt, 'aoStateSaveParams', function (oS, oData) {
			that._fnStateSave.call( that, oData );
		}, "ColReorder_State" );

		/* An initial column order has been specified */
		var aiOrder = null;
		if ( this.s.init.aiOrder )
		{
			aiOrder = this.s.init.aiOrder.slice();
		}

		/* State loading, overrides the column order given */
		if ( this.s.dt.oLoadedState && typeof this.s.dt.oLoadedState.ColReorder != 'undefined' &&
		  this.s.dt.oLoadedState.ColReorder.length == this.s.dt.aoColumns.length )
		{
			aiOrder = this.s.dt.oLoadedState.ColReorder;
		}

		/* If we have an order to apply - do so */
		if ( aiOrder )
		{
			/* We might be called during or after the DataTables initialisation. If before, then we need
			 * to wait until the draw is done, if after, then do what we need to do right away
			 */
			if ( !that.s.dt._bInitComplete )
			{
				var bDone = false;
				$(table).on( 'draw.dt.colReorder', function () {
					if ( !that.s.dt._bInitComplete && !bDone )
					{
						bDone = true;
						var resort = fnInvertKeyValues( aiOrder );
						that._fnOrderColumns.call( that, resort );
					}
				} );
			}
			else
			{
				var resort = fnInvertKeyValues( aiOrder );
				that._fnOrderColumns.call( that, resort );
			}
		}
		else {
			this._fnSetColumnIndexes();
		}

		// Destroy clean up
		$(table).on( 'destroy.dt.colReorder', function () {
			$(table).off( 'destroy.dt.colReorder draw.dt.colReorder' );

			$.each( that.s.dt.aoColumns, function (i, column) {
				$(column.nTh).off('.ColReorder');
				$(column.nTh).removeAttr('data-column-index');
			} );

			that.s.dt._colReorder = null;
			that.s = null;
		} );
	},


	/**
	 * Set the column order from an array
	 *  @method  _fnOrderColumns
	 *  @param   array a An array of integers which dictate the column order that should be applied
	 *  @returns void
	 *  @private
	 */
	"_fnOrderColumns": function ( a )
	{
		var changed = false;

		if ( a.length != this.s.dt.aoColumns.length )
		{
			this.s.dt.oInstance.oApi._fnLog( this.s.dt, 1, "ColReorder - array reorder does not "+
				"match known number of columns. Skipping." );
			return;
		}

		for ( var i=0, iLen=a.length ; i<iLen ; i++ )
		{
			var currIndex = $.inArray( i, a );
			if ( i != currIndex )
			{
				/* Reorder our switching array */
				fnArraySwitch( a, currIndex, i );

				/* Do the column reorder in the table */
				this.s.dt.oInstance.fnColReorder( currIndex, i, true, false );

				changed = true;
			}
		}

		this._fnSetColumnIndexes();

		// Has anything actually changed? If not, then nothing else to do
		if ( ! changed ) {
			return;
		}

		$.fn.dataTable.Api( this.s.dt ).rows().invalidate();

		/* When scrolling we need to recalculate the column sizes to allow for the shift */
		if ( this.s.dt.oScroll.sX !== "" || this.s.dt.oScroll.sY !== "" )
		{
			this.s.dt.oInstance.fnAdjustColumnSizing( false );
		}

		/* Save the state */
		this.s.dt.oInstance.oApi._fnSaveState( this.s.dt );

		if ( this.s.reorderCallback !== null )
		{
			this.s.reorderCallback.call( this );
		}
	},


	/**
	 * Because we change the indexes of columns in the table, relative to their starting point
	 * we need to reorder the state columns to what they are at the starting point so we can
	 * then rearrange them again on state load!
	 *  @method  _fnStateSave
	 *  @param   object oState DataTables state
	 *  @returns string JSON encoded cookie string for DataTables
	 *  @private
	 */
	"_fnStateSave": function ( oState )
	{
		var i, iLen, aCopy, iOrigColumn;
		var oSettings = this.s.dt;
		var columns = oSettings.aoColumns;

		oState.ColReorder = [];

		/* Sorting */
		if ( oState.aaSorting ) {
			// 1.10.0-
			for ( i=0 ; i<oState.aaSorting.length ; i++ ) {
				oState.aaSorting[i][0] = columns[ oState.aaSorting[i][0] ]._ColReorder_iOrigCol;
			}

			var aSearchCopy = $.extend( true, [], oState.aoSearchCols );

			for ( i=0, iLen=columns.length ; i<iLen ; i++ )
			{
				iOrigColumn = columns[i]._ColReorder_iOrigCol;

				/* Column filter */
				oState.aoSearchCols[ iOrigColumn ] = aSearchCopy[i];

				/* Visibility */
				oState.abVisCols[ iOrigColumn ] = columns[i].bVisible;

				/* Column reordering */
				oState.ColReorder.push( iOrigColumn );
			}
		}
		else if ( oState.order ) {
			// 1.10.1+
			for ( i=0 ; i<oState.order.length ; i++ ) {
				oState.order[i][0] = columns[ oState.order[i][0] ]._ColReorder_iOrigCol;
			}

			var stateColumnsCopy = $.extend( true, [], oState.columns );

			for ( i=0, iLen=columns.length ; i<iLen ; i++ )
			{
				iOrigColumn = columns[i]._ColReorder_iOrigCol;

				/* Columns */
				oState.columns[ iOrigColumn ] = stateColumnsCopy[i];

				/* Column reordering */
				oState.ColReorder.push( iOrigColumn );
			}
		}
	},


	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Mouse drop and drag
	 */

	/**
	 * Add a mouse down listener to a particluar TH element
	 *  @method  _fnMouseListener
	 *  @param   int i Column index
	 *  @param   element nTh TH element clicked on
	 *  @returns void
	 *  @private
	 */
	"_fnMouseListener": function ( i, nTh )
	{
		var that = this;
		$(nTh)
			.on( 'mousedown.ColReorder', function (e) {
				if ( that.s.enable && e.which === 1 ) {
					that._fnMouseDown.call( that, e, nTh );
				}
			} )
			.on( 'touchstart.ColReorder', function (e) {
				if ( that.s.enable ) {
					that._fnMouseDown.call( that, e, nTh );
				}
			} );
	},


	/**
	 * Mouse down on a TH element in the table header
	 *  @method  _fnMouseDown
	 *  @param   event e Mouse event
	 *  @param   element nTh TH element to be dragged
	 *  @returns void
	 *  @private
	 */
	"_fnMouseDown": function ( e, nTh )
	{
		var that = this;

		/* Store information about the mouse position */
		var target = $(e.target).closest('th, td');
		var offset = target.offset();
		var idx = parseInt( $(nTh).attr('data-column-index'), 10 );

		if ( idx === undefined ) {
			return;
		}

		this.s.mouse.startX = this._fnCursorPosition( e, 'pageX' );
		this.s.mouse.startY = this._fnCursorPosition( e, 'pageY' );
		this.s.mouse.offsetX = this._fnCursorPosition( e, 'pageX' ) - offset.left;
		this.s.mouse.offsetY = this._fnCursorPosition( e, 'pageY' ) - offset.top;
		this.s.mouse.target = this.s.dt.aoColumns[ idx ].nTh;//target[0];
		this.s.mouse.targetIndex = idx;
		this.s.mouse.fromIndex = idx;

		this._fnRegions();

		/* Add event handlers to the document */
		$(document)
			.on( 'mousemove.ColReorder touchmove.ColReorder', function (e) {
				that._fnMouseMove.call( that, e );
			} )
			.on( 'mouseup.ColReorder touchend.ColReorder', function (e) {
				that._fnMouseUp.call( that, e );
			} );
	},


	/**
	 * Deal with a mouse move event while dragging a node
	 *  @method  _fnMouseMove
	 *  @param   event e Mouse event
	 *  @returns void
	 *  @private
	 */
	"_fnMouseMove": function ( e )
	{
		var that = this;

		if ( this.dom.drag === null )
		{
			/* Only create the drag element if the mouse has moved a specific distance from the start
			 * point - this allows the user to make small mouse movements when sorting and not have a
			 * possibly confusing drag element showing up
			 */
			if ( Math.pow(
				Math.pow(this._fnCursorPosition( e, 'pageX') - this.s.mouse.startX, 2) +
				Math.pow(this._fnCursorPosition( e, 'pageY') - this.s.mouse.startY, 2), 0.5 ) < 5 )
			{
				return;
			}
			this._fnCreateDragNode();
		}

		/* Position the element - we respect where in the element the click occured */
		this.dom.drag.css( {
			left: this._fnCursorPosition( e, 'pageX' ) - this.s.mouse.offsetX,
			top: this._fnCursorPosition( e, 'pageY' ) - this.s.mouse.offsetY
		} );

		/* Based on the current mouse position, calculate where the insert should go */
		var target;
		var lastToIndex = this.s.mouse.toIndex;
		var cursorXPosiotion = this._fnCursorPosition(e, 'pageX');
		var targetsPrev = function (i) {
			while (i >= 0) {
				i--;

				if (i <= 0) {
					return null;
				}

				if (that.s.aoTargets[i+1].x !== that.s.aoTargets[i].x) {
					return that.s.aoTargets[i];
				}
			}
		};
		var firstNotHidden = function () {
			for (var i=0 ; i<that.s.aoTargets.length-1 ; i++) {
				if (that.s.aoTargets[i].x !== that.s.aoTargets[i+1].x) {
					return that.s.aoTargets[i];
				}
			}
		};
		var lastNotHidden = function () {
			for (var i=that.s.aoTargets.length-1 ; i>0 ; i--) {
				if (that.s.aoTargets[i].x !== that.s.aoTargets[i-1].x) {
					return that.s.aoTargets[i];
				}
			}
		};

        for (var i = 1; i < this.s.aoTargets.length; i++) {
			var prevTarget = targetsPrev(i);
			if (! prevTarget) {
				prevTarget = firstNotHidden();
			}

			var prevTargetMiddle = prevTarget.x + (this.s.aoTargets[i].x - prevTarget.x) / 2;

            if (this._fnIsLtr()) {
                if (cursorXPosiotion < prevTargetMiddle ) {
                    target = prevTarget;
                    break;
                }
            }
            else {
                if (cursorXPosiotion > prevTargetMiddle) {
                    target = prevTarget;
                    break;
                }
            }
		}

        if (target) {
            this.dom.pointer.css('left', target.x);
            this.s.mouse.toIndex = target.to;
        }
        else {
			// The insert element wasn't positioned in the array (less than
			// operator), so we put it at the end
			this.dom.pointer.css( 'left', lastNotHidden().x );
			this.s.mouse.toIndex = lastNotHidden().to;
		}

		// Perform reordering if realtime updating is on and the column has moved
		if ( this.s.init.bRealtime && lastToIndex !== this.s.mouse.toIndex ) {
			this.s.dt.oInstance.fnColReorder( this.s.mouse.fromIndex, this.s.mouse.toIndex );
			this.s.mouse.fromIndex = this.s.mouse.toIndex;

			// Not great for performance, but required to keep everything in alignment
			if ( this.s.dt.oScroll.sX !== "" || this.s.dt.oScroll.sY !== "" )
			{
				this.s.dt.oInstance.fnAdjustColumnSizing( false );
			}

			this._fnRegions();
		}
	},


	/**
	 * Finish off the mouse drag and insert the column where needed
	 *  @method  _fnMouseUp
	 *  @param   event e Mouse event
	 *  @returns void
	 *  @private
	 */
	"_fnMouseUp": function ( e )
	{
		var that = this;

		$(document).off( '.ColReorder' );

		if ( this.dom.drag !== null )
		{
			/* Remove the guide elements */
			this.dom.drag.remove();
			this.dom.pointer.remove();
			this.dom.drag = null;
			this.dom.pointer = null;

			/* Actually do the reorder */
			this.s.dt.oInstance.fnColReorder( this.s.mouse.fromIndex, this.s.mouse.toIndex, true );
			this._fnSetColumnIndexes();

			/* When scrolling we need to recalculate the column sizes to allow for the shift */
			if ( this.s.dt.oScroll.sX !== "" || this.s.dt.oScroll.sY !== "" )
			{
				this.s.dt.oInstance.fnAdjustColumnSizing( false );
			}

			/* Save the state */
			this.s.dt.oInstance.oApi._fnSaveState( this.s.dt );

			if ( this.s.reorderCallback !== null )
			{
				this.s.reorderCallback.call( this );
			}
		}
	},


	/**
	 * Calculate a cached array with the points of the column inserts, and the
	 * 'to' points
	 *  @method  _fnRegions
	 *  @returns void
	 *  @private
	 */
	"_fnRegions": function ()
	{
		var aoColumns = this.s.dt.aoColumns;
        var isLTR = this._fnIsLtr();
		this.s.aoTargets.splice(0, this.s.aoTargets.length);
		var lastBound = $(this.s.dt.nTable).offset().left;

        var aoColumnBounds = [];
        $.each(aoColumns, function (i, column) {
            if (column.bVisible && column.nTh.style.display !== 'none') {
                var nth = $(column.nTh);
				var bound = nth.offset().left;

                if (isLTR) {
                    bound += nth.outerWidth();
                }

                aoColumnBounds.push({
                    index: i,
                    bound: bound
				});

				lastBound = bound;
			}
			else {
                aoColumnBounds.push({
					index: i,
					bound: lastBound
                });
			}
		});

        var firstColumn = aoColumnBounds[0];
		var firstColumnWidth = $(aoColumns[firstColumn.index].nTh).outerWidth();

        this.s.aoTargets.push({
            to: 0,
			x: firstColumn.bound - firstColumnWidth
        });

        for (var i = 0; i < aoColumnBounds.length; i++) {
            var columnBound = aoColumnBounds[i];
            var iToPoint = columnBound.index;

            /* For the column / header in question, we want it's position to remain the same if the
            * position is just to it's immediate left or right, so we only increment the counter for
            * other columns
            */
            if (columnBound.index < this.s.mouse.fromIndex) {
                iToPoint++;
            }

            this.s.aoTargets.push({
				to: iToPoint,
                x: columnBound.bound
            });
        }

		/* Disallow columns for being reordered by drag and drop, counting right to left */
		if ( this.s.fixedRight !== 0 )
		{
			this.s.aoTargets.splice( this.s.aoTargets.length - this.s.fixedRight );
		}

		/* Disallow columns for being reordered by drag and drop, counting left to right */
		if ( this.s.fixed !== 0 )
		{
			this.s.aoTargets.splice( 0, this.s.fixed );
		}
	},


	/**
	 * Copy the TH element that is being drags so the user has the idea that they are actually
	 * moving it around the page.
	 *  @method  _fnCreateDragNode
	 *  @returns void
	 *  @private
	 */
	"_fnCreateDragNode": function ()
	{
		var scrolling = this.s.dt.oScroll.sX !== "" || this.s.dt.oScroll.sY !== "";

		var origCell = this.s.dt.aoColumns[ this.s.mouse.targetIndex ].nTh;
		var origTr = origCell.parentNode;
		var origThead = origTr.parentNode;
		var origTable = origThead.parentNode;
		var cloneCell = $(origCell).clone();

		// This is a slightly odd combination of jQuery and DOM, but it is the
		// fastest and least resource intensive way I could think of cloning
		// the table with just a single header cell in it.
		this.dom.drag = $(origTable.cloneNode(false))
			.addClass( 'DTCR_clonedTable' )
			.append(
				$(origThead.cloneNode(false)).append(
					$(origTr.cloneNode(false)).append(
						cloneCell[0]
					)
				)
			)
			.css( {
				position: 'absolute',
				top: 0,
				left: 0,
				width: $(origCell).outerWidth(),
				height: $(origCell).outerHeight()
			} )
			.appendTo( 'body' );

		this.dom.pointer = $('<div></div>')
			.addClass( 'DTCR_pointer' )
			.css( {
				position: 'absolute',
				top: scrolling ?
					$('div.dataTables_scroll', this.s.dt.nTableWrapper).offset().top :
					$(this.s.dt.nTable).offset().top,
				height : scrolling ?
					$('div.dataTables_scroll', this.s.dt.nTableWrapper).height() :
					$(this.s.dt.nTable).height()
			} )
			.appendTo( 'body' );
	},


	/**
	 * Add a data attribute to the column headers, so we know the index of
	 * the row to be reordered. This allows fast detection of the index, and
	 * for this plug-in to work with FixedHeader which clones the nodes.
	 *  @private
	 */
	"_fnSetColumnIndexes": function ()
	{
		$.each( this.s.dt.aoColumns, function (i, column) {
			$(column.nTh).attr('data-column-index', i);
		} );
	},


	/**
	 * Get cursor position regardless of mouse or touch input
	 * @param  {Event}  e    jQuery Event
	 * @param  {string} prop Property to get
	 * @return {number}      Value
	 */
	_fnCursorPosition: function ( e, prop ) {
		if ( e.type.indexOf('touch') !== -1 ) {
			return e.originalEvent.touches[0][ prop ];
		}
		return e[ prop ];
    },

    _fnIsLtr: function () {
        return $(this.s.dt.nTable).css('direction') !== "rtl";
    }
} );





/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Static parameters
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


/**
 * ColReorder default settings for initialisation
 *  @namespace
 *  @static
 */
ColReorder.defaults = {
	/**
	 * Predefined ordering for the columns that will be applied automatically
	 * on initialisation. If not specified then the order that the columns are
	 * found to be in the HTML is the order used.
	 *  @type array
	 *  @default null
	 *  @static
	 */
	aiOrder: null,

	/**
	 * ColReorder enable on initialisation
	 *  @type boolean
	 *  @default true
	 *  @static
	 */
	bEnable: true,

	/**
	 * Redraw the table's column ordering as the end user draws the column
	 * (`true`) or wait until the mouse is released (`false` - default). Note
	 * that this will perform a redraw on each reordering, which involves an
	 * Ajax request each time if you are using server-side processing in
	 * DataTables.
	 *  @type boolean
	 *  @default false
	 *  @static
	 */
	bRealtime: true,

	/**
	 * Indicate how many columns should be fixed in position (counting from the
	 * left). This will typically be 1 if used, but can be as high as you like.
	 *  @type int
	 *  @default 0
	 *  @static
	 */
	iFixedColumnsLeft: 0,

	/**
	 * As `iFixedColumnsRight` but counting from the right.
	 *  @type int
	 *  @default 0
	 *  @static
	 */
	iFixedColumnsRight: 0,

	/**
	 * Callback function that is fired when columns are reordered. The `column-
	 * reorder` event is preferred over this callback
	 *  @type function():void
	 *  @default null
	 *  @static
	 */
	fnReorderCallback: null
};



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Constants
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/**
 * ColReorder version
 *  @constant  version
 *  @type      String
 *  @default   As code
 */
ColReorder.version = "1.5.2";



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * DataTables interfaces
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

// Expose
$.fn.dataTable.ColReorder = ColReorder;
$.fn.DataTable.ColReorder = ColReorder;


// Register a new feature with DataTables
if ( typeof $.fn.dataTable == "function" &&
     typeof $.fn.dataTableExt.fnVersionCheck == "function" &&
     $.fn.dataTableExt.fnVersionCheck('1.10.8') )
{
	$.fn.dataTableExt.aoFeatures.push( {
		"fnInit": function( settings ) {
			var table = settings.oInstance;

			if ( ! settings._colReorder ) {
				var dtInit = settings.oInit;
				var opts = dtInit.colReorder || dtInit.oColReorder || {};

				new ColReorder( settings, opts );
			}
			else {
				table.oApi._fnLog( settings, 1, "ColReorder attempted to initialise twice. Ignoring second" );
			}

			return null; /* No node for DataTables to insert */
		},
		"cFeature": "R",
		"sFeature": "ColReorder"
	} );
}
else {
	alert( "Warning: ColReorder requires DataTables 1.10.8 or greater - www.datatables.net/download");
}


// Attach a listener to the document which listens for DataTables initialisation
// events so we can automatically initialise
$(document).on( 'preInit.dt.colReorder', function (e, settings) {
	if ( e.namespace !== 'dt' ) {
		return;
	}

	var init = settings.oInit.colReorder;
	var defaults = DataTable.defaults.colReorder;

	if ( init || defaults ) {
		var opts = $.extend( {}, init, defaults );

		if ( init !== false ) {
			new ColReorder( settings, opts  );
		}
	}
} );


// API augmentation
$.fn.dataTable.Api.register( 'colReorder.reset()', function () {
	return this.iterator( 'table', function ( ctx ) {
		ctx._colReorder.fnReset();
	} );
} );

$.fn.dataTable.Api.register( 'colReorder.order()', function ( set, original ) {
	if ( set ) {
		return this.iterator( 'table', function ( ctx ) {
			ctx._colReorder.fnOrder( set, original );
		} );
	}

	return this.context.length ?
		this.context[0]._colReorder.fnOrder() :
		null;
} );

$.fn.dataTable.Api.register( 'colReorder.transpose()', function ( idx, dir ) {
	return this.context.length && this.context[0]._colReorder ?
		this.context[0]._colReorder.fnTranspose( idx, dir ) :
		idx;
} );

$.fn.dataTable.Api.register( 'colReorder.move()', function( from, to, drop, invalidateRows ) {
	if (this.context.length) {
		this.context[0]._colReorder.s.dt.oInstance.fnColReorder( from, to, drop, invalidateRows );
		this.context[0]._colReorder._fnSetColumnIndexes();
	}
	return this;
} );

$.fn.dataTable.Api.register( 'colReorder.enable()', function( flag ) {
	return this.iterator( 'table', function ( ctx ) {
		if ( ctx._colReorder ) {
			ctx._colReorder.fnEnable( flag );
		}
	} );
} );

$.fn.dataTable.Api.register( 'colReorder.disable()', function() {
	return this.iterator( 'table', function ( ctx ) {
		if ( ctx._colReorder ) {
			ctx._colReorder.fnDisable();
		}
	} );
} );


return ColReorder;
}));


/*! FixedColumns 3.3.0
 * 2010-2018 SpryMedia Ltd - datatables.net/license
 */

/**
 * @summary     FixedColumns
 * @description Freeze columns in place on a scrolling DataTable
 * @version     3.3.0
 * @file        dataTables.fixedColumns.js
 * @author      SpryMedia Ltd (www.sprymedia.co.uk)
 * @contact     www.sprymedia.co.uk/contact
 * @copyright   Copyright 2010-2018 SpryMedia Ltd.
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license/mit
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */
(function( factory ){
	if ( typeof define === 'function' && define.amd ) {
		// AMD
		define( ['jquery', 'datatables.net'], function ( $ ) {
			return factory( $, window, document );
		} );
	}
	else if ( typeof exports === 'object' ) {
		// CommonJS
		module.exports = function (root, $) {
			if ( ! root ) {
				root = window;
			}

			if ( ! $ || ! $.fn.dataTable ) {
				$ = require('datatables.net')(root, $).$;
			}

			return factory( $, root, root.document );
		};
	}
	else {
		// Browser
		factory( jQuery, window, document );
	}
}(function( $, window, document, undefined ) {
'use strict';
var DataTable = $.fn.dataTable;
var _firefoxScroll;

/**
 * When making use of DataTables' x-axis scrolling feature, you may wish to
 * fix the left most column in place. This plug-in for DataTables provides
 * exactly this option (note for non-scrolling tables, please use the
 * FixedHeader plug-in, which can fix headers and footers). Key
 * features include:
 *
 * * Freezes the left or right most columns to the side of the table
 * * Option to freeze two or more columns
 * * Full integration with DataTables' scrolling options
 * * Speed - FixedColumns is fast in its operation
 *
 *  @class
 *  @constructor
 *  @global
 *  @param {object} dt DataTables instance. With DataTables 1.10 this can also
 *    be a jQuery collection, a jQuery selector, DataTables API instance or
 *    settings object.
 *  @param {object} [init={}] Configuration object for FixedColumns. Options are
 *    defined by {@link FixedColumns.defaults}
 *
 *  @requires jQuery 1.7+
 *  @requires DataTables 1.8.0+
 *
 *  @example
 *      var table = $('#example').dataTable( {
 *        "scrollX": "100%"
 *      } );
 *      new $.fn.dataTable.fixedColumns( table );
 */
var FixedColumns = function ( dt, init ) {
	var that = this;

	/* Sanity check - you just know it will happen */
	if ( ! ( this instanceof FixedColumns ) ) {
		alert( "FixedColumns warning: FixedColumns must be initialised with the 'new' keyword." );
		return;
	}

	if ( init === undefined || init === true ) {
		init = {};
	}

	// Use the DataTables Hungarian notation mapping method, if it exists to
	// provide forwards compatibility for camel case variables
	var camelToHungarian = $.fn.dataTable.camelToHungarian;
	if ( camelToHungarian ) {
		camelToHungarian( FixedColumns.defaults, FixedColumns.defaults, true );
		camelToHungarian( FixedColumns.defaults, init );
	}

	// v1.10 allows the settings object to be got form a number of sources
	var dtSettings = new $.fn.dataTable.Api( dt ).settings()[0];

	/**
	 * Settings object which contains customisable information for FixedColumns instance
	 * @namespace
	 * @extends FixedColumns.defaults
	 * @private
	 */
	this.s = {
		/**
		 * DataTables settings objects
		 *  @type     object
		 *  @default  Obtained from DataTables instance
		 */
		"dt": dtSettings,

		/**
		 * Number of columns in the DataTable - stored for quick access
		 *  @type     int
		 *  @default  Obtained from DataTables instance
		 */
		"iTableColumns": dtSettings.aoColumns.length,

		/**
		 * Original outer widths of the columns as rendered by DataTables - used to calculate
		 * the FixedColumns grid bounding box
		 *  @type     array.<int>
		 *  @default  []
		 */
		"aiOuterWidths": [],

		/**
		 * Original inner widths of the columns as rendered by DataTables - used to apply widths
		 * to the columns
		 *  @type     array.<int>
		 *  @default  []
		 */
		"aiInnerWidths": [],


		/**
		 * Is the document layout right-to-left
		 * @type boolean
		 */
		rtl: $(dtSettings.nTable).css('direction') === 'rtl'
	};


	/**
	 * DOM elements used by the class instance
	 * @namespace
	 * @private
	 *
	 */
	this.dom = {
		/**
		 * DataTables scrolling element
		 *  @type     node
		 *  @default  null
		 */
		"scroller": null,

		/**
		 * DataTables header table
		 *  @type     node
		 *  @default  null
		 */
		"header": null,

		/**
		 * DataTables body table
		 *  @type     node
		 *  @default  null
		 */
		"body": null,

		/**
		 * DataTables footer table
		 *  @type     node
		 *  @default  null
		 */
		"footer": null,

		/**
		 * Display grid elements
		 * @namespace
		 */
		"grid": {
			/**
			 * Grid wrapper. This is the container element for the 3x3 grid
			 *  @type     node
			 *  @default  null
			 */
			"wrapper": null,

			/**
			 * DataTables scrolling element. This element is the DataTables
			 * component in the display grid (making up the main table - i.e.
			 * not the fixed columns).
			 *  @type     node
			 *  @default  null
			 */
			"dt": null,

			/**
			 * Left fixed column grid components
			 * @namespace
			 */
			"left": {
				"wrapper": null,
				"head": null,
				"body": null,
				"foot": null
			},

			/**
			 * Right fixed column grid components
			 * @namespace
			 */
			"right": {
				"wrapper": null,
				"head": null,
				"body": null,
				"foot": null
			}
		},

		/**
		 * Cloned table nodes
		 * @namespace
		 */
		"clone": {
			/**
			 * Left column cloned table nodes
			 * @namespace
			 */
			"left": {
				/**
				 * Cloned header table
				 *  @type     node
				 *  @default  null
				 */
				"header": null,

				/**
				 * Cloned body table
				 *  @type     node
				 *  @default  null
				 */
				"body": null,

				/**
				 * Cloned footer table
				 *  @type     node
				 *  @default  null
				 */
				"footer": null
			},

			/**
			 * Right column cloned table nodes
			 * @namespace
			 */
			"right": {
				/**
				 * Cloned header table
				 *  @type     node
				 *  @default  null
				 */
				"header": null,

				/**
				 * Cloned body table
				 *  @type     node
				 *  @default  null
				 */
				"body": null,

				/**
				 * Cloned footer table
				 *  @type     node
				 *  @default  null
				 */
				"footer": null
			}
		}
	};

	if ( dtSettings._oFixedColumns ) {
		throw 'FixedColumns already initialised on this table';
	}

	/* Attach the instance to the DataTables instance so it can be accessed easily */
	dtSettings._oFixedColumns = this;

	/* Let's do it */
	if ( ! dtSettings._bInitComplete )
	{
		dtSettings.oApi._fnCallbackReg( dtSettings, 'aoInitComplete', function () {
			that._fnConstruct( init );
		}, 'FixedColumns' );
	}
	else
	{
		this._fnConstruct( init );
	}
};



$.extend( FixedColumns.prototype , {
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Public methods
	 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

	/**
	 * Update the fixed columns - including headers and footers. Note that FixedColumns will
	 * automatically update the display whenever the host DataTable redraws.
	 *  @returns {void}
	 *  @example
	 *      var table = $('#example').dataTable( {
	 *          "scrollX": "100%"
	 *      } );
	 *      var fc = new $.fn.dataTable.fixedColumns( table );
	 *
	 *      // at some later point when the table has been manipulated....
	 *      fc.fnUpdate();
	 */
	"fnUpdate": function ()
	{
		this._fnDraw( true );
	},


	/**
	 * Recalculate the resizes of the 3x3 grid that FixedColumns uses for display of the table.
	 * This is useful if you update the width of the table container. Note that FixedColumns will
	 * perform this function automatically when the window.resize event is fired.
	 *  @returns {void}
	 *  @example
	 *      var table = $('#example').dataTable( {
	 *          "scrollX": "100%"
	 *      } );
	 *      var fc = new $.fn.dataTable.fixedColumns( table );
	 *
	 *      // Resize the table container and then have FixedColumns adjust its layout....
	 *      $('#content').width( 1200 );
	 *      fc.fnRedrawLayout();
	 */
	"fnRedrawLayout": function ()
	{
		this._fnColCalc();
		this._fnGridLayout();
		this.fnUpdate();
	},


	/**
	 * Mark a row such that it's height should be recalculated when using 'semiauto' row
	 * height matching. This function will have no effect when 'none' or 'auto' row height
	 * matching is used.
	 *  @param   {Node} nTr TR element that should have it's height recalculated
	 *  @returns {void}
	 *  @example
	 *      var table = $('#example').dataTable( {
	 *          "scrollX": "100%"
	 *      } );
	 *      var fc = new $.fn.dataTable.fixedColumns( table );
	 *
	 *      // manipulate the table - mark the row as needing an update then update the table
	 *      // this allows the redraw performed by DataTables fnUpdate to recalculate the row
	 *      // height
	 *      fc.fnRecalculateHeight();
	 *      table.fnUpdate( $('#example tbody tr:eq(0)')[0], ["insert date", 1, 2, 3 ... ]);
	 */
	"fnRecalculateHeight": function ( nTr )
	{
		delete nTr._DTTC_iHeight;
		nTr.style.height = 'auto';
	},


	/**
	 * Set the height of a given row - provides cross browser compatibility
	 *  @param   {Node} nTarget TR element that should have it's height recalculated
	 *  @param   {int} iHeight Height in pixels to set
	 *  @returns {void}
	 *  @example
	 *      var table = $('#example').dataTable( {
	 *          "scrollX": "100%"
	 *      } );
	 *      var fc = new $.fn.dataTable.fixedColumns( table );
	 *
	 *      // You may want to do this after manipulating a row in the fixed column
	 *      fc.fnSetRowHeight( $('#example tbody tr:eq(0)')[0], 50 );
	 */
	"fnSetRowHeight": function ( nTarget, iHeight )
	{
		nTarget.style.height = iHeight+"px";
	},


	/**
	 * Get data index information about a row or cell in the table body.
	 * This function is functionally identical to fnGetPosition in DataTables,
	 * taking the same parameter (TH, TD or TR node) and returning exactly the
	 * the same information (data index information). THe difference between
	 * the two is that this method takes into account the fixed columns in the
	 * table, so you can pass in nodes from the master table, or the cloned
	 * tables and get the index position for the data in the main table.
	 *  @param {node} node TR, TH or TD element to get the information about
	 *  @returns {int} If nNode is given as a TR, then a single index is 
	 *    returned, or if given as a cell, an array of [row index, column index
	 *    (visible), column index (all)] is given.
	 */
	"fnGetPosition": function ( node )
	{
		var idx;
		var inst = this.s.dt.oInstance;

		if ( ! $(node).parents('.DTFC_Cloned').length )
		{
			// Not in a cloned table
			return inst.fnGetPosition( node );
		}
		else
		{
			// Its in the cloned table, so need to look up position
			if ( node.nodeName.toLowerCase() === 'tr' ) {
				idx = $(node).index();
				return inst.fnGetPosition( $('tr', this.s.dt.nTBody)[ idx ] );
			}
			else
			{
				var colIdx = $(node).index();
				idx = $(node.parentNode).index();
				var row = inst.fnGetPosition( $('tr', this.s.dt.nTBody)[ idx ] );

				return [
					row,
					colIdx,
					inst.oApi._fnVisibleToColumnIndex( this.s.dt, colIdx )
				];
			}
		}
	},

	fnToFixedNode: function ( rowIdx, colIdx )
	{
		var found;

		if ( colIdx < this.s.iLeftColumns ) {
			found = $(this.dom.clone.left.body).find('[data-dt-row='+rowIdx+'][data-dt-column='+colIdx+']');
		}
		else if ( colIdx >= this.s.iRightColumns ) {
			found = $(this.dom.clone.right.body).find('[data-dt-row='+rowIdx+'][data-dt-column='+colIdx+']');
		}

		if ( found && found.length ) {
			return found[0];
		}

		// Fallback - non-fixed node
		var table = new $.fn.dataTable.Api(this.s.dt);
		return table.cell(rowIdx, colIdx).node();
	},


	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Private methods (they are of course public in JS, but recommended as private)
	 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

	/**
	 * Initialisation for FixedColumns
	 *  @param   {Object} oInit User settings for initialisation
	 *  @returns {void}
	 *  @private
	 */
	"_fnConstruct": function ( oInit )
	{
		var i, iLen, iWidth,
			that = this;

		/* Sanity checking */
		if ( typeof this.s.dt.oInstance.fnVersionCheck != 'function' ||
		     this.s.dt.oInstance.fnVersionCheck( '1.8.0' ) !== true )
		{
			alert( "FixedColumns "+FixedColumns.VERSION+" required DataTables 1.8.0 or later. "+
				"Please upgrade your DataTables installation" );
			return;
		}

		if ( this.s.dt.oScroll.sX === "" )
		{
			this.s.dt.oInstance.oApi._fnLog( this.s.dt, 1, "FixedColumns is not needed (no "+
				"x-scrolling in DataTables enabled), so no action will be taken. Use 'FixedHeader' for "+
				"column fixing when scrolling is not enabled" );
			return;
		}

		/* Apply the settings from the user / defaults */
		this.s = $.extend( true, this.s, FixedColumns.defaults, oInit );

		/* Set up the DOM as we need it and cache nodes */
		var classes = this.s.dt.oClasses;
		this.dom.grid.dt = $(this.s.dt.nTable).parents('div.'+classes.sScrollWrapper)[0];
		this.dom.scroller = $('div.'+classes.sScrollBody, this.dom.grid.dt )[0];

		/* Set up the DOM that we want for the fixed column layout grid */
		this._fnColCalc();
		this._fnGridSetup();

		/* Event handlers */
		var mouseController;
		var mouseDown = false;

		// When the mouse is down (drag scroll) the mouse controller cannot
		// change, as the browser keeps the original element as the scrolling one
		$(this.s.dt.nTableWrapper).on( 'mousedown.DTFC', function (e) {
			if ( e.button === 0 ) {
				mouseDown = true;

				$(document).one( 'mouseup', function () {
					mouseDown = false;
				} );
			}
		} );

		// When the body is scrolled - scroll the left and right columns
		$(this.dom.scroller)
			.on( 'mouseover.DTFC touchstart.DTFC', function () {
				if ( ! mouseDown ) {
					mouseController = 'main';
				}
			} )
			.on( 'scroll.DTFC', function (e) {
				if ( ! mouseController && e.originalEvent ) {
					mouseController = 'main';
				}

				if ( mouseController === 'main' ) {
					if ( that.s.iLeftColumns > 0 ) {
						that.dom.grid.left.liner.scrollTop = that.dom.scroller.scrollTop;
					}
					if ( that.s.iRightColumns > 0 ) {
						that.dom.grid.right.liner.scrollTop = that.dom.scroller.scrollTop;
					}
				}
			} );

		var wheelType = 'onwheel' in document.createElement('div') ?
			'wheel.DTFC' :
			'mousewheel.DTFC';

		if ( that.s.iLeftColumns > 0 ) {
			// When scrolling the left column, scroll the body and right column
			$(that.dom.grid.left.liner)
				.on( 'mouseover.DTFC touchstart.DTFC', function () {
					if ( ! mouseDown ) {
						mouseController = 'left';
					}
				} )
				.on( 'scroll.DTFC', function ( e ) {
					if ( ! mouseController && e.originalEvent ) {
						mouseController = 'left';
					}

					if ( mouseController === 'left' ) {
						that.dom.scroller.scrollTop = that.dom.grid.left.liner.scrollTop;
						if ( that.s.iRightColumns > 0 ) {
							that.dom.grid.right.liner.scrollTop = that.dom.grid.left.liner.scrollTop;
						}
					}
				} )
				.on( wheelType, function(e) {
					// Pass horizontal scrolling through
					var xDelta = e.type === 'wheel' ?
						-e.originalEvent.deltaX :
						e.originalEvent.wheelDeltaX;
					that.dom.scroller.scrollLeft -= xDelta;
				} );
		}

		if ( that.s.iRightColumns > 0 ) {
			// When scrolling the right column, scroll the body and the left column
			$(that.dom.grid.right.liner)
				.on( 'mouseover.DTFC touchstart.DTFC', function () {
					if ( ! mouseDown ) {
						mouseController = 'right';
					}
				} )
				.on( 'scroll.DTFC', function ( e ) {
					if ( ! mouseController && e.originalEvent ) {
						mouseController = 'right';
					}

					if ( mouseController === 'right' ) {
						that.dom.scroller.scrollTop = that.dom.grid.right.liner.scrollTop;
						if ( that.s.iLeftColumns > 0 ) {
							that.dom.grid.left.liner.scrollTop = that.dom.grid.right.liner.scrollTop;
						}
					}
				} )
				.on( wheelType, function(e) {
					// Pass horizontal scrolling through
					var xDelta = e.type === 'wheel' ?
						-e.originalEvent.deltaX :
						e.originalEvent.wheelDeltaX;
					that.dom.scroller.scrollLeft -= xDelta;
				} );
		}

		$(window).on( 'resize.DTFC', function () {
			that._fnGridLayout.call( that );
		} );

		var bFirstDraw = true;
		var jqTable = $(this.s.dt.nTable);

		jqTable
			.on( 'draw.dt.DTFC', function () {
				that._fnColCalc();
				that._fnDraw.call( that, bFirstDraw );
				bFirstDraw = false;
			} )
			.on( 'column-sizing.dt.DTFC', function () {
				that._fnColCalc();
				that._fnGridLayout( that );
			} )
			.on( 'column-visibility.dt.DTFC', function ( e, settings, column, vis, recalc ) {
				if ( recalc === undefined || recalc ) {
					that._fnColCalc();
					that._fnGridLayout( that );
					that._fnDraw( true );
				}
			} )
			.on( 'select.dt.DTFC deselect.dt.DTFC', function ( e, dt, type, indexes ) {
				if ( e.namespace === 'dt' ) {
					that._fnDraw( false );
				}
			} )
			.on( 'destroy.dt.DTFC', function () {
				jqTable.off( '.DTFC' );

				$(that.dom.scroller).off( '.DTFC' );
				$(window).off( '.DTFC' );
				$(that.s.dt.nTableWrapper).off( '.DTFC' );

				$(that.dom.grid.left.liner).off( '.DTFC '+wheelType );
				$(that.dom.grid.left.wrapper).remove();

				$(that.dom.grid.right.liner).off( '.DTFC '+wheelType );
				$(that.dom.grid.right.wrapper).remove();
			} );

		/* Get things right to start with - note that due to adjusting the columns, there must be
		 * another redraw of the main table. It doesn't need to be a full redraw however.
		 */
		this._fnGridLayout();
		this.s.dt.oInstance.fnDraw(false);
	},


	/**
	 * Calculate the column widths for the grid layout
	 *  @returns {void}
	 *  @private
	 */
	"_fnColCalc": function ()
	{
		var that = this;
		var iLeftWidth = 0;
		var iRightWidth = 0;

		this.s.aiInnerWidths = [];
		this.s.aiOuterWidths = [];

		$.each( this.s.dt.aoColumns, function (i, col) {
			var th = $(col.nTh);
			var border;

			if ( ! th.filter(':visible').length ) {
				that.s.aiInnerWidths.push( 0 );
				that.s.aiOuterWidths.push( 0 );
			}
			else
			{
				// Inner width is used to assign widths to cells
				// Outer width is used to calculate the container
				var iWidth = th.outerWidth();

				// When working with the left most-cell, need to add on the
				// table's border to the outerWidth, since we need to take
				// account of it, but it isn't in any cell
				if ( that.s.aiOuterWidths.length === 0 ) {
					border = $(that.s.dt.nTable).css('border-left-width');
					iWidth += typeof border === 'string' && border.indexOf('px') === -1 ?
						1 :
						parseInt( border, 10 );
				}

				// Likewise with the final column on the right
				if ( that.s.aiOuterWidths.length === that.s.dt.aoColumns.length-1 ) {
					border = $(that.s.dt.nTable).css('border-right-width');
					iWidth += typeof border === 'string' && border.indexOf('px') === -1 ?
						1 :
						parseInt( border, 10 );
				}

				that.s.aiOuterWidths.push( iWidth );
				that.s.aiInnerWidths.push( th.width() );

				if ( i < that.s.iLeftColumns )
				{
					iLeftWidth += iWidth;
				}

				if ( that.s.iTableColumns-that.s.iRightColumns <= i )
				{
					iRightWidth += iWidth;
				}
			}
		} );

		this.s.iLeftWidth = iLeftWidth;
		this.s.iRightWidth = iRightWidth;
	},


	/**
	 * Set up the DOM for the fixed column. The way the layout works is to create a 1x3 grid
	 * for the left column, the DataTable (for which we just reuse the scrolling element DataTable
	 * puts into the DOM) and the right column. In each of he two fixed column elements there is a
	 * grouping wrapper element and then a head, body and footer wrapper. In each of these we then
	 * place the cloned header, body or footer tables. This effectively gives as 3x3 grid structure.
	 *  @returns {void}
	 *  @private
	 */
	"_fnGridSetup": function ()
	{
		var that = this;
		var oOverflow = this._fnDTOverflow();
		var block;

		this.dom.body = this.s.dt.nTable;
		this.dom.header = this.s.dt.nTHead.parentNode;
		this.dom.header.parentNode.parentNode.style.position = "relative";

		var nSWrapper =
			$('<div class="DTFC_ScrollWrapper" style="position:relative; clear:both;">'+
				'<div class="DTFC_LeftWrapper" style="position:absolute; top:0; left:0;" aria-hidden="true">'+
					'<div class="DTFC_LeftHeadWrapper" style="position:relative; top:0; left:0; overflow:hidden;"></div>'+
					'<div class="DTFC_LeftBodyWrapper" style="position:relative; top:0; left:0; height:0; overflow:hidden;">'+
						'<div class="DTFC_LeftBodyLiner" style="position:relative; top:0; left:0; overflow-y:scroll;"></div>'+
					'</div>'+
					'<div class="DTFC_LeftFootWrapper" style="position:relative; top:0; left:0; overflow:hidden;"></div>'+
				'</div>'+
				'<div class="DTFC_RightWrapper" style="position:absolute; top:0; right:0;" aria-hidden="true">'+
					'<div class="DTFC_RightHeadWrapper" style="position:relative; top:0; left:0;">'+
						'<div class="DTFC_RightHeadBlocker DTFC_Blocker" style="position:absolute; top:0; bottom:0;"></div>'+
					'</div>'+
					'<div class="DTFC_RightBodyWrapper" style="position:relative; top:0; left:0; height:0; overflow:hidden;">'+
						'<div class="DTFC_RightBodyLiner" style="position:relative; top:0; left:0; overflow-y:scroll;"></div>'+
					'</div>'+
					'<div class="DTFC_RightFootWrapper" style="position:relative; top:0; left:0;">'+
						'<div class="DTFC_RightFootBlocker DTFC_Blocker" style="position:absolute; top:0; bottom:0;"></div>'+
					'</div>'+
				'</div>'+
			'</div>')[0];
		var nLeft = nSWrapper.childNodes[0];
		var nRight = nSWrapper.childNodes[1];

		this.dom.grid.dt.parentNode.insertBefore( nSWrapper, this.dom.grid.dt );
		nSWrapper.appendChild( this.dom.grid.dt );

		this.dom.grid.wrapper = nSWrapper;

		if ( this.s.iLeftColumns > 0 )
		{
			this.dom.grid.left.wrapper = nLeft;
			this.dom.grid.left.head = nLeft.childNodes[0];
			this.dom.grid.left.body = nLeft.childNodes[1];
			this.dom.grid.left.liner = $('div.DTFC_LeftBodyLiner', nSWrapper)[0];

			nSWrapper.appendChild( nLeft );
		}

		if ( this.s.iRightColumns > 0 )
		{
			this.dom.grid.right.wrapper = nRight;
			this.dom.grid.right.head = nRight.childNodes[0];
			this.dom.grid.right.body = nRight.childNodes[1];
			this.dom.grid.right.liner = $('div.DTFC_RightBodyLiner', nSWrapper)[0];

			nRight.style.right = oOverflow.bar+"px";

			block = $('div.DTFC_RightHeadBlocker', nSWrapper)[0];
			block.style.width = oOverflow.bar+"px";
			block.style.right = -oOverflow.bar+"px";
			this.dom.grid.right.headBlock = block;

			block = $('div.DTFC_RightFootBlocker', nSWrapper)[0];
			block.style.width = oOverflow.bar+"px";
			block.style.right = -oOverflow.bar+"px";
			this.dom.grid.right.footBlock = block;

			nSWrapper.appendChild( nRight );
		}

		if ( this.s.dt.nTFoot )
		{
			this.dom.footer = this.s.dt.nTFoot.parentNode;
			if ( this.s.iLeftColumns > 0 )
			{
				this.dom.grid.left.foot = nLeft.childNodes[2];
			}
			if ( this.s.iRightColumns > 0 )
			{
				this.dom.grid.right.foot = nRight.childNodes[2];
			}
		}

		// RTL support - swap the position of the left and right columns (#48)
		if ( this.s.rtl ) {
			$('div.DTFC_RightHeadBlocker', nSWrapper).css( {
				left: -oOverflow.bar+'px',
				right: ''
			} );
		}
	},


	/**
	 * Style and position the grid used for the FixedColumns layout
	 *  @returns {void}
	 *  @private
	 */
	"_fnGridLayout": function ()
	{
		var that = this;
		var oGrid = this.dom.grid;
		var iWidth = $(oGrid.wrapper).width();
		var iBodyHeight = this.s.dt.nTable.parentNode.offsetHeight;
		var iFullHeight = this.s.dt.nTable.parentNode.parentNode.offsetHeight;
		var oOverflow = this._fnDTOverflow();
		var iLeftWidth = this.s.iLeftWidth;
		var iRightWidth = this.s.iRightWidth;
		var rtl = $(this.dom.body).css('direction') === 'rtl';
		var wrapper;
		var scrollbarAdjust = function ( node, width ) {
			if ( ! oOverflow.bar ) {
				// If there is no scrollbar (Macs) we need to hide the auto scrollbar
				node.style.width = (width+20)+"px";
				node.style.paddingRight = "20px";
				node.style.boxSizing = "border-box";
			}
			else if ( that._firefoxScrollError() ) {
				// See the above function for why this is required
				if ( $(node).height() > 34 ) {
					node.style.width = (width+oOverflow.bar)+"px";
				}
			}
			else {
				// Otherwise just overflow by the scrollbar
				node.style.width = (width+oOverflow.bar)+"px";
			}
		};

		// When x scrolling - don't paint the fixed columns over the x scrollbar
		if ( oOverflow.x )
		{
			iBodyHeight -= oOverflow.bar;
		}

		oGrid.wrapper.style.height = iFullHeight+"px";

		if ( this.s.iLeftColumns > 0 )
		{
			wrapper = oGrid.left.wrapper;
			wrapper.style.width = iLeftWidth+'px';
			wrapper.style.height = '1px';

			// Swap the position of the left and right columns for rtl (#48)
			// This is always up against the edge, scrollbar on the far side
			if ( rtl ) {
				wrapper.style.left = '';
				wrapper.style.right = 0;
			}
			else {
				wrapper.style.left = 0;
				wrapper.style.right = '';
			}

			oGrid.left.body.style.height = iBodyHeight+"px";
			if ( oGrid.left.foot ) {
				oGrid.left.foot.style.top = (oOverflow.x ? oOverflow.bar : 0)+"px"; // shift footer for scrollbar
			}

			scrollbarAdjust( oGrid.left.liner, iLeftWidth );
			oGrid.left.liner.style.height = iBodyHeight+"px";
			oGrid.left.liner.style.maxHeight = iBodyHeight+"px";
		}

		if ( this.s.iRightColumns > 0 )
		{
			wrapper = oGrid.right.wrapper;
			wrapper.style.width = iRightWidth+'px';
			wrapper.style.height = '1px';

			// Need to take account of the vertical scrollbar
			if ( this.s.rtl ) {
				wrapper.style.left = oOverflow.y ? oOverflow.bar+'px' : 0;
				wrapper.style.right = '';
			}
			else {
				wrapper.style.left = '';
				wrapper.style.right = oOverflow.y ? oOverflow.bar+'px' : 0;
			}

			oGrid.right.body.style.height = iBodyHeight+"px";
			if ( oGrid.right.foot ) {
				oGrid.right.foot.style.top = (oOverflow.x ? oOverflow.bar : 0)+"px";
			}

			scrollbarAdjust( oGrid.right.liner, iRightWidth );
			oGrid.right.liner.style.height = iBodyHeight+"px";
			oGrid.right.liner.style.maxHeight = iBodyHeight+"px";

			oGrid.right.headBlock.style.display = oOverflow.y ? 'block' : 'none';
			oGrid.right.footBlock.style.display = oOverflow.y ? 'block' : 'none';
		}
	},


	/**
	 * Get information about the DataTable's scrolling state - specifically if the table is scrolling
	 * on either the x or y axis, and also the scrollbar width.
	 *  @returns {object} Information about the DataTables scrolling state with the properties:
	 *    'x', 'y' and 'bar'
	 *  @private
	 */
	"_fnDTOverflow": function ()
	{
		var nTable = this.s.dt.nTable;
		var nTableScrollBody = nTable.parentNode;
		var out = {
			"x": false,
			"y": false,
			"bar": this.s.dt.oScroll.iBarWidth
		};

		if ( nTable.offsetWidth > nTableScrollBody.clientWidth )
		{
			out.x = true;
		}

		if ( nTable.offsetHeight > nTableScrollBody.clientHeight )
		{
			out.y = true;
		}

		return out;
	},


	/**
	 * Clone and position the fixed columns
	 *  @returns {void}
	 *  @param   {Boolean} bAll Indicate if the header and footer should be updated as well (true)
	 *  @private
	 */
	"_fnDraw": function ( bAll )
	{
		this._fnGridLayout();
		this._fnCloneLeft( bAll );
		this._fnCloneRight( bAll );

		/* Draw callback function */
		if ( this.s.fnDrawCallback !== null )
		{
			this.s.fnDrawCallback.call( this, this.dom.clone.left, this.dom.clone.right );
		}

		/* Event triggering */
		$(this).trigger( 'draw.dtfc', {
			"leftClone": this.dom.clone.left,
			"rightClone": this.dom.clone.right
		} );
	},


	/**
	 * Clone the right columns
	 *  @returns {void}
	 *  @param   {Boolean} bAll Indicate if the header and footer should be updated as well (true)
	 *  @private
	 */
	"_fnCloneRight": function ( bAll )
	{
		if ( this.s.iRightColumns <= 0 ) {
			return;
		}

		var that = this,
			i, jq,
			aiColumns = [];

		for ( i=this.s.iTableColumns-this.s.iRightColumns ; i<this.s.iTableColumns ; i++ ) {
			if ( this.s.dt.aoColumns[i].bVisible ) {
				aiColumns.push( i );
			}
		}

		this._fnClone( this.dom.clone.right, this.dom.grid.right, aiColumns, bAll );
	},


	/**
	 * Clone the left columns
	 *  @returns {void}
	 *  @param   {Boolean} bAll Indicate if the header and footer should be updated as well (true)
	 *  @private
	 */
	"_fnCloneLeft": function ( bAll )
	{
		if ( this.s.iLeftColumns <= 0 ) {
			return;
		}

		var that = this,
			i, jq,
			aiColumns = [];

		for ( i=0 ; i<this.s.iLeftColumns ; i++ ) {
			if ( this.s.dt.aoColumns[i].bVisible ) {
				aiColumns.push( i );
			}
		}

		this._fnClone( this.dom.clone.left, this.dom.grid.left, aiColumns, bAll );
	},


	/**
	 * Make a copy of the layout object for a header or footer element from DataTables. Note that
	 * this method will clone the nodes in the layout object.
	 *  @returns {Array} Copy of the layout array
	 *  @param   {Object} aoOriginal Layout array from DataTables (aoHeader or aoFooter)
	 *  @param   {Object} aiColumns Columns to copy
	 *  @param   {boolean} events Copy cell events or not
	 *  @private
	 */
	"_fnCopyLayout": function ( aoOriginal, aiColumns, events )
	{
		var aReturn = [];
		var aClones = [];
		var aCloned = [];

		for ( var i=0, iLen=aoOriginal.length ; i<iLen ; i++ )
		{
			var aRow = [];
			aRow.nTr = $(aoOriginal[i].nTr).clone(events, false)[0];

			for ( var j=0, jLen=this.s.iTableColumns ; j<jLen ; j++ )
			{
				if ( $.inArray( j, aiColumns ) === -1 )
				{
					continue;
				}

				var iCloned = $.inArray( aoOriginal[i][j].cell, aCloned );
				if ( iCloned === -1 )
				{
					var nClone = $(aoOriginal[i][j].cell).clone(events, false)[0];
					aClones.push( nClone );
					aCloned.push( aoOriginal[i][j].cell );

					aRow.push( {
						"cell": nClone,
						"unique": aoOriginal[i][j].unique
					} );
				}
				else
				{
					aRow.push( {
						"cell": aClones[ iCloned ],
						"unique": aoOriginal[i][j].unique
					} );
				}
			}

			aReturn.push( aRow );
		}

		return aReturn;
	},


	/**
	 * Clone the DataTable nodes and place them in the DOM (sized correctly)
	 *  @returns {void}
	 *  @param   {Object} oClone Object containing the header, footer and body cloned DOM elements
	 *  @param   {Object} oGrid Grid object containing the display grid elements for the cloned
	 *                    column (left or right)
	 *  @param   {Array} aiColumns Column indexes which should be operated on from the DataTable
	 *  @param   {Boolean} bAll Indicate if the header and footer should be updated as well (true)
	 *  @private
	 */
	"_fnClone": function ( oClone, oGrid, aiColumns, bAll )
	{
		var that = this,
			i, iLen, j, jLen, jq, nTarget, iColumn, nClone, iIndex, aoCloneLayout,
			jqCloneThead, aoFixedHeader,
			dt = this.s.dt;

		/*
		 * Header
		 */
		if ( bAll )
		{
			$(oClone.header).remove();

			oClone.header = $(this.dom.header).clone(true, false)[0];
			oClone.header.className += " DTFC_Cloned";
			oClone.header.style.width = "100%";
			oGrid.head.appendChild( oClone.header );

			/* Copy the DataTables layout cache for the header for our floating column */
			aoCloneLayout = this._fnCopyLayout( dt.aoHeader, aiColumns, true );
			jqCloneThead = $('>thead', oClone.header);
			jqCloneThead.empty();

			/* Add the created cloned TR elements to the table */
			for ( i=0, iLen=aoCloneLayout.length ; i<iLen ; i++ )
			{
				jqCloneThead[0].appendChild( aoCloneLayout[i].nTr );
			}

			/* Use the handy _fnDrawHead function in DataTables to do the rowspan/colspan
			 * calculations for us
			 */
			dt.oApi._fnDrawHead( dt, aoCloneLayout, true );
		}
		else
		{
			/* To ensure that we copy cell classes exactly, regardless of colspan, multiple rows
			 * etc, we make a copy of the header from the DataTable again, but don't insert the
			 * cloned cells, just copy the classes across. To get the matching layout for the
			 * fixed component, we use the DataTables _fnDetectHeader method, allowing 1:1 mapping
			 */
			aoCloneLayout = this._fnCopyLayout( dt.aoHeader, aiColumns, false );
			aoFixedHeader=[];

			dt.oApi._fnDetectHeader( aoFixedHeader, $('>thead', oClone.header)[0] );

			for ( i=0, iLen=aoCloneLayout.length ; i<iLen ; i++ )
			{
				for ( j=0, jLen=aoCloneLayout[i].length ; j<jLen ; j++ )
				{
					aoFixedHeader[i][j].cell.className = aoCloneLayout[i][j].cell.className;

					// If jQuery UI theming is used we need to copy those elements as well
					$('span.DataTables_sort_icon', aoFixedHeader[i][j].cell).each( function () {
						this.className = $('span.DataTables_sort_icon', aoCloneLayout[i][j].cell)[0].className;
					} );
				}
			}
		}
		this._fnEqualiseHeights( 'thead', this.dom.header, oClone.header );

		/*
		 * Body
		 */
		if ( this.s.sHeightMatch == 'auto' )
		{
			/* Remove any heights which have been applied already and let the browser figure it out */
			$('>tbody>tr', that.dom.body).css('height', 'auto');
		}

		if ( oClone.body !== null )
		{
			$(oClone.body).remove();
			oClone.body = null;
		}

		oClone.body = $(this.dom.body).clone(true)[0];
		oClone.body.className += " DTFC_Cloned";
		oClone.body.style.paddingBottom = dt.oScroll.iBarWidth+"px";
		oClone.body.style.marginBottom = (dt.oScroll.iBarWidth*2)+"px"; /* For IE */
		if ( oClone.body.getAttribute('id') !== null )
		{
			oClone.body.removeAttribute('id');
		}

		$('>thead>tr', oClone.body).empty();
		$('>tfoot', oClone.body).remove();

		var nBody = $('tbody', oClone.body)[0];
		$(nBody).empty();
		if ( dt.aiDisplay.length > 0 )
		{
			/* Copy the DataTables' header elements to force the column width in exactly the
			 * same way that DataTables does it - have the header element, apply the width and
			 * colapse it down
			 */
			var nInnerThead = $('>thead>tr', oClone.body)[0];
			for ( iIndex=0 ; iIndex<aiColumns.length ; iIndex++ )
			{
				iColumn = aiColumns[iIndex];

				nClone = $(dt.aoColumns[iColumn].nTh).clone(true)[0];
				nClone.innerHTML = "";

				var oStyle = nClone.style;
				oStyle.paddingTop = "0";
				oStyle.paddingBottom = "0";
				oStyle.borderTopWidth = "0";
				oStyle.borderBottomWidth = "0";
				oStyle.height = 0;
				oStyle.width = that.s.aiInnerWidths[iColumn]+"px";

				nInnerThead.appendChild( nClone );
			}

			/* Add in the tbody elements, cloning form the master table */
			$('>tbody>tr', that.dom.body).each( function (z) {
				var i = that.s.dt.oFeatures.bServerSide===false ?
					that.s.dt.aiDisplay[ that.s.dt._iDisplayStart+z ] : z;
				var aTds = that.s.dt.aoData[ i ].anCells || $(this).children('td, th');

				var n = this.cloneNode(false);
				n.removeAttribute('id');
				n.setAttribute( 'data-dt-row', i );

				for ( iIndex=0 ; iIndex<aiColumns.length ; iIndex++ )
				{
					iColumn = aiColumns[iIndex];

					if ( aTds.length > 0 )
					{
						nClone = $( aTds[iColumn] ).clone(true, true)[0];
						nClone.removeAttribute( 'id' );
						nClone.setAttribute( 'data-dt-row', i );
						nClone.setAttribute( 'data-dt-column', iColumn );
						n.appendChild( nClone );
					}
				}
				nBody.appendChild( n );
			} );
		}
		else
		{
			$('>tbody>tr', that.dom.body).each( function (z) {
				nClone = this.cloneNode(true);
				nClone.className += ' DTFC_NoData';
				$('td', nClone).html('');
				nBody.appendChild( nClone );
			} );
		}

		oClone.body.style.width = "100%";
		oClone.body.style.margin = "0";
		oClone.body.style.padding = "0";

		// Interop with Scroller - need to use a height forcing element in the
		// scrolling area in the same way that Scroller does in the body scroll.
		if ( dt.oScroller !== undefined )
		{
			var scrollerForcer = dt.oScroller.dom.force;

			if ( ! oGrid.forcer ) {
				oGrid.forcer = scrollerForcer.cloneNode( true );
				oGrid.liner.appendChild( oGrid.forcer );
			}
			else {
				oGrid.forcer.style.height = scrollerForcer.style.height;
			}
		}

		oGrid.liner.appendChild( oClone.body );

		this._fnEqualiseHeights( 'tbody', that.dom.body, oClone.body );

		/*
		 * Footer
		 */
		if ( dt.nTFoot !== null )
		{
			if ( bAll )
			{
				if ( oClone.footer !== null )
				{
					oClone.footer.parentNode.removeChild( oClone.footer );
				}
				oClone.footer = $(this.dom.footer).clone(true, true)[0];
				oClone.footer.className += " DTFC_Cloned";
				oClone.footer.style.width = "100%";
				oGrid.foot.appendChild( oClone.footer );

				/* Copy the footer just like we do for the header */
				aoCloneLayout = this._fnCopyLayout( dt.aoFooter, aiColumns, true );
				var jqCloneTfoot = $('>tfoot', oClone.footer);
				jqCloneTfoot.empty();

				for ( i=0, iLen=aoCloneLayout.length ; i<iLen ; i++ )
				{
					jqCloneTfoot[0].appendChild( aoCloneLayout[i].nTr );
				}
				dt.oApi._fnDrawHead( dt, aoCloneLayout, true );
			}
			else
			{
				aoCloneLayout = this._fnCopyLayout( dt.aoFooter, aiColumns, false );
				var aoCurrFooter=[];

				dt.oApi._fnDetectHeader( aoCurrFooter, $('>tfoot', oClone.footer)[0] );

				for ( i=0, iLen=aoCloneLayout.length ; i<iLen ; i++ )
				{
					for ( j=0, jLen=aoCloneLayout[i].length ; j<jLen ; j++ )
					{
						aoCurrFooter[i][j].cell.className = aoCloneLayout[i][j].cell.className;
					}
				}
			}
			this._fnEqualiseHeights( 'tfoot', this.dom.footer, oClone.footer );
		}

		/* Equalise the column widths between the header footer and body - body get's priority */
		var anUnique = dt.oApi._fnGetUniqueThs( dt, $('>thead', oClone.header)[0] );
		$(anUnique).each( function (i) {
			iColumn = aiColumns[i];
			this.style.width = that.s.aiInnerWidths[iColumn]+"px";
		} );

		if ( that.s.dt.nTFoot !== null )
		{
			anUnique = dt.oApi._fnGetUniqueThs( dt, $('>tfoot', oClone.footer)[0] );
			$(anUnique).each( function (i) {
				iColumn = aiColumns[i];
				this.style.width = that.s.aiInnerWidths[iColumn]+"px";
			} );
		}
	},


	/**
	 * From a given table node (THEAD etc), get a list of TR direct child elements
	 *  @param   {Node} nIn Table element to search for TR elements (THEAD, TBODY or TFOOT element)
	 *  @returns {Array} List of TR elements found
	 *  @private
	 */
	"_fnGetTrNodes": function ( nIn )
	{
		var aOut = [];
		for ( var i=0, iLen=nIn.childNodes.length ; i<iLen ; i++ )
		{
			if ( nIn.childNodes[i].nodeName.toUpperCase() == "TR" )
			{
				aOut.push( nIn.childNodes[i] );
			}
		}
		return aOut;
	},


	/**
	 * Equalise the heights of the rows in a given table node in a cross browser way
	 *  @returns {void}
	 *  @param   {String} nodeName Node type - thead, tbody or tfoot
	 *  @param   {Node} original Original node to take the heights from
	 *  @param   {Node} clone Copy the heights to
	 *  @private
	 */
	"_fnEqualiseHeights": function ( nodeName, original, clone )
	{
		if ( this.s.sHeightMatch == 'none' && nodeName !== 'thead' && nodeName !== 'tfoot' )
		{
			return;
		}

		var that = this,
			i, iLen, iHeight, iHeight2, iHeightOriginal, iHeightClone,
			rootOriginal = original.getElementsByTagName(nodeName)[0],
			rootClone    = clone.getElementsByTagName(nodeName)[0],
			jqBoxHack    = $('>'+nodeName+'>tr:eq(0)', original).children(':first'),
			iBoxHack     = jqBoxHack.outerHeight() - jqBoxHack.height(),
			anOriginal   = this._fnGetTrNodes( rootOriginal ),
			anClone      = this._fnGetTrNodes( rootClone ),
			heights      = [];

		for ( i=0, iLen=anClone.length ; i<iLen ; i++ )
		{
			iHeightOriginal = anOriginal[i].offsetHeight;
			iHeightClone = anClone[i].offsetHeight;
			iHeight = iHeightClone > iHeightOriginal ? iHeightClone : iHeightOriginal;

			if ( this.s.sHeightMatch == 'semiauto' )
			{
				anOriginal[i]._DTTC_iHeight = iHeight;
			}

			heights.push( iHeight );
		}

		for ( i=0, iLen=anClone.length ; i<iLen ; i++ )
		{
			anClone[i].style.height = heights[i]+"px";
			anOriginal[i].style.height = heights[i]+"px";
		}
	},

	/**
	 * Determine if the UA suffers from Firefox's overflow:scroll scrollbars
	 * not being shown bug.
	 *
	 * Firefox doesn't draw scrollbars, even if it is told to using
	 * overflow:scroll, if the div is less than 34px height. See bugs 292284 and
	 * 781885. Using UA detection here since this is particularly hard to detect
	 * using objects - its a straight up rendering error in Firefox.
	 *
	 * @return {boolean} True if Firefox error is present, false otherwise
	 */
	_firefoxScrollError: function () {
		if ( _firefoxScroll === undefined ) {
			var test = $('<div/>')
				.css( {
					position: 'absolute',
					top: 0,
					left: 0,
					height: 10,
					width: 50,
					overflow: 'scroll'
				} )
				.appendTo( 'body' );

			// Make sure this doesn't apply on Macs with 0 width scrollbars
			_firefoxScroll = (
				test[0].clientWidth === test[0].offsetWidth && this._fnDTOverflow().bar !== 0
			);

			test.remove();
		}

		return _firefoxScroll;
	}
} );



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Statics
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/**
 * FixedColumns default settings for initialisation
 *  @name FixedColumns.defaults
 *  @namespace
 *  @static
 */
FixedColumns.defaults = /** @lends FixedColumns.defaults */{
	/**
	 * Number of left hand columns to fix in position
	 *  @type     int
	 *  @default  1
	 *  @static
	 *  @example
	 *      var  = $('#example').dataTable( {
	 *          "scrollX": "100%"
	 *      } );
	 *      new $.fn.dataTable.fixedColumns( table, {
	 *          "leftColumns": 2
	 *      } );
	 */
	"iLeftColumns": 1,

	/**
	 * Number of right hand columns to fix in position
	 *  @type     int
	 *  @default  0
	 *  @static
	 *  @example
	 *      var table = $('#example').dataTable( {
	 *          "scrollX": "100%"
	 *      } );
	 *      new $.fn.dataTable.fixedColumns( table, {
	 *          "rightColumns": 1
	 *      } );
	 */
	"iRightColumns": 0,

	/**
	 * Draw callback function which is called when FixedColumns has redrawn the fixed assets
	 *  @type     function(object, object):void
	 *  @default  null
	 *  @static
	 *  @example
	 *      var table = $('#example').dataTable( {
	 *          "scrollX": "100%"
	 *      } );
	 *      new $.fn.dataTable.fixedColumns( table, {
	 *          "drawCallback": function () {
	 *	            alert( "FixedColumns redraw" );
	 *	        }
	 *      } );
	 */
	"fnDrawCallback": null,

	/**
	 * Height matching algorthim to use. This can be "none" which will result in no height
	 * matching being applied by FixedColumns (height matching could be forced by CSS in this
	 * case), "semiauto" whereby the height calculation will be performed once, and the result
	 * cached to be used again (fnRecalculateHeight can be used to force recalculation), or
	 * "auto" when height matching is performed on every draw (slowest but must accurate)
	 *  @type     string
	 *  @default  semiauto
	 *  @static
	 *  @example
	 *      var table = $('#example').dataTable( {
	 *          "scrollX": "100%"
	 *      } );
	 *      new $.fn.dataTable.fixedColumns( table, {
	 *          "heightMatch": "auto"
	 *      } );
	 */
	"sHeightMatch": "semiauto"
};




/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Constants
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/**
 * FixedColumns version
 *  @name      FixedColumns.version
 *  @type      String
 *  @default   See code
 *  @static
 */
FixedColumns.version = "3.3.0";



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * DataTables API integration
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

DataTable.Api.register( 'fixedColumns()', function () {
	return this;
} );

DataTable.Api.register( 'fixedColumns().update()', function () {
	return this.iterator( 'table', function ( ctx ) {
		if ( ctx._oFixedColumns ) {
			ctx._oFixedColumns.fnUpdate();
		}
	} );
} );

DataTable.Api.register( 'fixedColumns().relayout()', function () {
	return this.iterator( 'table', function ( ctx ) {
		if ( ctx._oFixedColumns ) {
			ctx._oFixedColumns.fnRedrawLayout();
		}
	} );
} );

DataTable.Api.register( 'rows().recalcHeight()', function () {
	return this.iterator( 'row', function ( ctx, idx ) {
		if ( ctx._oFixedColumns ) {
			ctx._oFixedColumns.fnRecalculateHeight( this.row(idx).node() );
		}
	} );
} );

DataTable.Api.register( 'fixedColumns().rowIndex()', function ( row ) {
	row = $(row);

	return row.parents('.DTFC_Cloned').length ?
		this.rows( { page: 'current' } ).indexes()[ row.index() ] :
		this.row( row ).index();
} );

DataTable.Api.register( 'fixedColumns().cellIndex()', function ( cell ) {
	cell = $(cell);

	if ( cell.parents('.DTFC_Cloned').length ) {
		var rowClonedIdx = cell.parent().index();
		var rowIdx = this.rows( { page: 'current' } ).indexes()[ rowClonedIdx ];
		var columnIdx;

		if ( cell.parents('.DTFC_LeftWrapper').length ) {
			columnIdx = cell.index();
		}
		else {
			var columns = this.columns().flatten().length;
			columnIdx = columns - this.context[0]._oFixedColumns.s.iRightColumns + cell.index();
		}

		return {
			row: rowIdx,
			column: this.column.index( 'toData', columnIdx ),
			columnVisible: columnIdx
		};
	}
	else {
		return this.cell( cell ).index();
	}
} );

DataTable.Api.registerPlural( 'cells().fixedNodes()', 'cell().fixedNode()', function () {
	return this.iterator( 'cell', function ( settings, row, column ) {
		return settings._oFixedColumns
			? settings._oFixedColumns.fnToFixedNode( row, column )
			: this.node();
	}, 1 );
} );




/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Initialisation
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

// Attach a listener to the document which listens for DataTables initialisation
// events so we can automatically initialise
$(document).on( 'init.dt.fixedColumns', function (e, settings) {
	if ( e.namespace !== 'dt' ) {
		return;
	}

	var init = settings.oInit.fixedColumns;
	var defaults = DataTable.defaults.fixedColumns;

	if ( init || defaults ) {
		var opts = $.extend( {}, init, defaults );

		if ( init !== false ) {
			new FixedColumns( settings, opts );
		}
	}
} );



// Make FixedColumns accessible from the DataTables instance
$.fn.dataTable.FixedColumns = FixedColumns;
$.fn.DataTable.FixedColumns = FixedColumns;

return FixedColumns;
}));


/*! FixedHeader 3.1.6
 * 2009-2019 SpryMedia Ltd - datatables.net/license
 */

/**
 * @summary     FixedHeader
 * @description Fix a table's header or footer, so it is always visible while
 *              scrolling
 * @version     3.1.6
 * @file        dataTables.fixedHeader.js
 * @author      SpryMedia Ltd (www.sprymedia.co.uk)
 * @contact     www.sprymedia.co.uk/contact
 * @copyright   Copyright 2009-2019 SpryMedia Ltd.
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license/mit
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */

(function( factory ){
	if ( typeof define === 'function' && define.amd ) {
		// AMD
		define( ['jquery', 'datatables.net'], function ( $ ) {
			return factory( $, window, document );
		} );
	}
	else if ( typeof exports === 'object' ) {
		// CommonJS
		module.exports = function (root, $) {
			if ( ! root ) {
				root = window;
			}

			if ( ! $ || ! $.fn.dataTable ) {
				$ = require('datatables.net')(root, $).$;
			}

			return factory( $, root, root.document );
		};
	}
	else {
		// Browser
		factory( jQuery, window, document );
	}
}(function( $, window, document, undefined ) {
'use strict';
var DataTable = $.fn.dataTable;


var _instCounter = 0;

var FixedHeader = function ( dt, config ) {
	// Sanity check - you just know it will happen
	if ( ! (this instanceof FixedHeader) ) {
		throw "FixedHeader must be initialised with the 'new' keyword.";
	}

	// Allow a boolean true for defaults
	if ( config === true ) {
		config = {};
	}

	dt = new DataTable.Api( dt );

	this.c = $.extend( true, {}, FixedHeader.defaults, config );

	this.s = {
		dt: dt,
		position: {
			theadTop: 0,
			tbodyTop: 0,
			tfootTop: 0,
			tfootBottom: 0,
			width: 0,
			left: 0,
			tfootHeight: 0,
			theadHeight: 0,
			windowHeight: $(window).height(),
			visible: true
		},
		headerMode: null,
		footerMode: null,
		autoWidth: dt.settings()[0].oFeatures.bAutoWidth,
		namespace: '.dtfc'+(_instCounter++),
		scrollLeft: {
			header: -1,
			footer: -1
		},
		enable: true
	};

	this.dom = {
		floatingHeader: null,
		thead: $(dt.table().header()),
		tbody: $(dt.table().body()),
		tfoot: $(dt.table().footer()),
		header: {
			host: null,
			floating: null,
			placeholder: null
		},
		footer: {
			host: null,
			floating: null,
			placeholder: null
		}
	};

	this.dom.header.host = this.dom.thead.parent();
	this.dom.footer.host = this.dom.tfoot.parent();

	var dtSettings = dt.settings()[0];
	if ( dtSettings._fixedHeader ) {
		throw "FixedHeader already initialised on table "+dtSettings.nTable.id;
	}

	dtSettings._fixedHeader = this;

	this._constructor();
};


/*
 * Variable: FixedHeader
 * Purpose:  Prototype for FixedHeader
 * Scope:    global
 */
$.extend( FixedHeader.prototype, {
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * API methods
	 */

	/**
	 * Kill off FH and any events
	 */
	destroy: function () {
		this.s.dt.off( '.dtfc' );
		$(window).off( this.s.namespace );

		if ( this.c.header ) {
			this._modeChange( 'in-place', 'header', true );
		}

		if ( this.c.footer && this.dom.tfoot.length ) {
			this._modeChange( 'in-place', 'footer', true );
		}
	},

	/**
	 * Enable / disable the fixed elements
	 *
	 * @param  {boolean} enable `true` to enable, `false` to disable
	 */
	enable: function ( enable, update )
	{
		this.s.enable = enable;

		if ( update || update === undefined ) {
			this._positions();
			this._scroll( true );
		}
	},

	/**
	 * Get enabled status
	 */
	enabled: function ()
	{
		return this.s.enable;
	},
	
	/**
	 * Set header offset 
	 *
	 * @param  {int} new value for headerOffset
	 */
	headerOffset: function ( offset )
	{
		if ( offset !== undefined ) {
			this.c.headerOffset = offset;
			this.update();
		}

		return this.c.headerOffset;
	},
	
	/**
	 * Set footer offset
	 *
	 * @param  {int} new value for footerOffset
	 */
	footerOffset: function ( offset )
	{
		if ( offset !== undefined ) {
			this.c.footerOffset = offset;
			this.update();
		}

		return this.c.footerOffset;
	},

	
	/**
	 * Recalculate the position of the fixed elements and force them into place
	 */
	update: function ()
	{
		var table = this.s.dt.table().node();

		if ( $(table).is(':visible') ) {
			this.enable( true, false );
		}
		else {
			this.enable( false, false );
		}

		this._positions();
		this._scroll( true );
	},


	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Constructor
	 */
	
	/**
	 * FixedHeader constructor - adding the required event listeners and
	 * simple initialisation
	 *
	 * @private
	 */
	_constructor: function ()
	{
		var that = this;
		var dt = this.s.dt;

		$(window)
			.on( 'scroll'+this.s.namespace, function () {
				that._scroll();
			} )
			.on( 'resize'+this.s.namespace, DataTable.util.throttle( function () {
				that.s.position.windowHeight = $(window).height();
				that.update();
			}, 50 ) );

		var autoHeader = $('.fh-fixedHeader');
		if ( ! this.c.headerOffset && autoHeader.length ) {
			this.c.headerOffset = autoHeader.outerHeight();
		}

		var autoFooter = $('.fh-fixedFooter');
		if ( ! this.c.footerOffset && autoFooter.length ) {
			this.c.footerOffset = autoFooter.outerHeight();
		}

		dt.on( 'column-reorder.dt.dtfc column-visibility.dt.dtfc draw.dt.dtfc column-sizing.dt.dtfc responsive-display.dt.dtfc', function () {
			that.update();
		} );

		dt.on( 'destroy.dtfc', function () {
			that.destroy();
		} );

		this._positions();
		this._scroll();
	},


	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Private methods
	 */

	/**
	 * Clone a fixed item to act as a place holder for the original element
	 * which is moved into a clone of the table element, and moved around the
	 * document to give the fixed effect.
	 *
	 * @param  {string}  item  'header' or 'footer'
	 * @param  {boolean} force Force the clone to happen, or allow automatic
	 *   decision (reuse existing if available)
	 * @private
	 */
	_clone: function ( item, force )
	{
		var dt = this.s.dt;
		var itemDom = this.dom[ item ];
		var itemElement = item === 'header' ?
			this.dom.thead :
			this.dom.tfoot;

		if ( ! force && itemDom.floating ) {
			// existing floating element - reuse it
			itemDom.floating.removeClass( 'fixedHeader-floating fixedHeader-locked' );
		}
		else {
			if ( itemDom.floating ) {
				itemDom.placeholder.remove();
				this._unsize( item );
				itemDom.floating.children().detach();
				itemDom.floating.remove();
			}

			itemDom.floating = $( dt.table().node().cloneNode( false ) )
				.css( 'table-layout', 'fixed' )
				.attr( 'aria-hidden', 'true' )
				.removeAttr( 'id' )
				.append( itemElement )
				.appendTo( 'body' );

			// Insert a fake thead/tfoot into the DataTable to stop it jumping around
			itemDom.placeholder = itemElement.clone( false );
			itemDom.placeholder
				.find( '*[id]' )
				.removeAttr( 'id' );

			itemDom.host.prepend( itemDom.placeholder );

			// Clone widths
			this._matchWidths( itemDom.placeholder, itemDom.floating );
		}
	},

	/**
	 * Copy widths from the cells in one element to another. This is required
	 * for the footer as the footer in the main table takes its sizes from the
	 * header columns. That isn't present in the footer so to have it still
	 * align correctly, the sizes need to be copied over. It is also required
	 * for the header when auto width is not enabled
	 *
	 * @param  {jQuery} from Copy widths from
	 * @param  {jQuery} to   Copy widths to
	 * @private
	 */
	_matchWidths: function ( from, to ) {
		var get = function ( name ) {
			return $(name, from)
				.map( function () {
					return $(this).width();
				} ).toArray();
		};

		var set = function ( name, toWidths ) {
			$(name, to).each( function ( i ) {
				$(this).css( {
					width: toWidths[i],
					minWidth: toWidths[i]
				} );
			} );
		};

		var thWidths = get( 'th' );
		var tdWidths = get( 'td' );

		set( 'th', thWidths );
		set( 'td', tdWidths );
	},

	/**
	 * Remove assigned widths from the cells in an element. This is required
	 * when inserting the footer back into the main table so the size is defined
	 * by the header columns and also when auto width is disabled in the
	 * DataTable.
	 *
	 * @param  {string} item The `header` or `footer`
	 * @private
	 */
	_unsize: function ( item ) {
		var el = this.dom[ item ].floating;

		if ( el && (item === 'footer' || (item === 'header' && ! this.s.autoWidth)) ) {
			$('th, td', el).css( {
				width: '',
				minWidth: ''
			} );
		}
		else if ( el && item === 'header' ) {
			$('th, td', el).css( 'min-width', '' );
		}
	},

	/**
	 * Reposition the floating elements to take account of horizontal page
	 * scroll
	 *
	 * @param  {string} item       The `header` or `footer`
	 * @param  {int}    scrollLeft Document scrollLeft
	 * @private
	 */
	_horizontal: function ( item, scrollLeft )
	{
		var itemDom = this.dom[ item ];
		var position = this.s.position;
		var lastScrollLeft = this.s.scrollLeft;

		if ( itemDom.floating && lastScrollLeft[ item ] !== scrollLeft ) {
			itemDom.floating.css( 'left', position.left - scrollLeft );

			lastScrollLeft[ item ] = scrollLeft;
		}
	},

	/**
	 * Change from one display mode to another. Each fixed item can be in one
	 * of:
	 *
	 * * `in-place` - In the main DataTable
	 * * `in` - Floating over the DataTable
	 * * `below` - (Header only) Fixed to the bottom of the table body
	 * * `above` - (Footer only) Fixed to the top of the table body
	 * 
	 * @param  {string}  mode        Mode that the item should be shown in
	 * @param  {string}  item        'header' or 'footer'
	 * @param  {boolean} forceChange Force a redraw of the mode, even if already
	 *     in that mode.
	 * @private
	 */
	_modeChange: function ( mode, item, forceChange )
	{
		var dt = this.s.dt;
		var itemDom = this.dom[ item ];
		var position = this.s.position;

		// Record focus. Browser's will cause input elements to loose focus if
		// they are inserted else where in the doc
		var tablePart = this.dom[ item==='footer' ? 'tfoot' : 'thead' ];
		var focus = $.contains( tablePart[0], document.activeElement ) ?
			document.activeElement :
			null;
		
		if ( focus ) {
			focus.blur();
		}

		if ( mode === 'in-place' ) {
			// Insert the header back into the table's real header
			if ( itemDom.placeholder ) {
				itemDom.placeholder.remove();
				itemDom.placeholder = null;
			}

			this._unsize( item );

			if ( item === 'header' ) {
				itemDom.host.prepend( tablePart );
			}
			else {
				itemDom.host.append( tablePart );
			}

			if ( itemDom.floating ) {
				itemDom.floating.remove();
				itemDom.floating = null;
			}
		}
		else if ( mode === 'in' ) {
			// Remove the header from the read header and insert into a fixed
			// positioned floating table clone
			this._clone( item, forceChange );

			itemDom.floating
				.addClass( 'fixedHeader-floating' )
				.css( item === 'header' ? 'top' : 'bottom', this.c[item+'Offset'] )
				.css( 'left', position.left+'px' )
				.css( 'width', position.width+'px' );

			if ( item === 'footer' ) {
				itemDom.floating.css( 'top', '' );
			}
		}
		else if ( mode === 'below' ) { // only used for the header
			// Fix the position of the floating header at base of the table body
			this._clone( item, forceChange );

			itemDom.floating
				.addClass( 'fixedHeader-locked' )
				.css( 'top', position.tfootTop - position.theadHeight )
				.css( 'left', position.left+'px' )
				.css( 'width', position.width+'px' );
		}
		else if ( mode === 'above' ) { // only used for the footer
			// Fix the position of the floating footer at top of the table body
			this._clone( item, forceChange );

			itemDom.floating
				.addClass( 'fixedHeader-locked' )
				.css( 'top', position.tbodyTop )
				.css( 'left', position.left+'px' )
				.css( 'width', position.width+'px' );
		}

		// Restore focus if it was lost
		if ( focus && focus !== document.activeElement ) {
			setTimeout( function () {
				focus.focus();
			}, 10 );
		}

		this.s.scrollLeft.header = -1;
		this.s.scrollLeft.footer = -1;
		this.s[item+'Mode'] = mode;
	},

	/**
	 * Cache the positional information that is required for the mode
	 * calculations that FixedHeader performs.
	 *
	 * @private
	 */
	_positions: function ()
	{
		var dt = this.s.dt;
		var table = dt.table();
		var position = this.s.position;
		var dom = this.dom;
		var tableNode = $(table.node());

		// Need to use the header and footer that are in the main table,
		// regardless of if they are clones, since they hold the positions we
		// want to measure from
		var thead = tableNode.children('thead');
		var tfoot = tableNode.children('tfoot');
		var tbody = dom.tbody;

		position.visible = tableNode.is(':visible');
		position.width = tableNode.outerWidth();
		position.left = tableNode.offset().left;
		position.theadTop = thead.offset().top;
		position.tbodyTop = tbody.offset().top;
		position.tbodyHeight = tbody.outerHeight();
		position.theadHeight = position.tbodyTop - position.theadTop;

		if ( tfoot.length ) {
			position.tfootTop = tfoot.offset().top;
			position.tfootBottom = position.tfootTop + tfoot.outerHeight();
			position.tfootHeight = position.tfootBottom - position.tfootTop;
		}
		else {
			position.tfootTop = position.tbodyTop + tbody.outerHeight();
			position.tfootBottom = position.tfootTop;
			position.tfootHeight = position.tfootTop;
		}
	},


	/**
	 * Mode calculation - determine what mode the fixed items should be placed
	 * into.
	 *
	 * @param  {boolean} forceChange Force a redraw of the mode, even if already
	 *     in that mode.
	 * @private
	 */
	_scroll: function ( forceChange )
	{
		var windowTop = $(document).scrollTop();
		var windowLeft = $(document).scrollLeft();
		var position = this.s.position;
		var headerMode, footerMode;

		if ( this.c.header ) {
			if ( ! this.s.enable ) {
				headerMode = 'in-place';
			}
			else if ( ! position.visible || windowTop <= position.theadTop - this.c.headerOffset ) {
				headerMode = 'in-place';
			}
			else if ( windowTop <= position.tfootTop - position.theadHeight - this.c.headerOffset ) {
				headerMode = 'in';
			}
			else {
				headerMode = 'below';
			}

			if ( forceChange || headerMode !== this.s.headerMode ) {
				this._modeChange( headerMode, 'header', forceChange );
			}

			this._horizontal( 'header', windowLeft );
		}

		if ( this.c.footer && this.dom.tfoot.length ) {
			if ( ! this.s.enable ) {
				headerMode = 'in-place';
			}
			else if ( ! position.visible || windowTop + position.windowHeight >= position.tfootBottom + this.c.footerOffset ) {
				footerMode = 'in-place';
			}
			else if ( position.windowHeight + windowTop > position.tbodyTop + position.tfootHeight + this.c.footerOffset ) {
				footerMode = 'in';
			}
			else {
				footerMode = 'above';
			}

			if ( forceChange || footerMode !== this.s.footerMode ) {
				this._modeChange( footerMode, 'footer', forceChange );
			}

			this._horizontal( 'footer', windowLeft );
		}
	}
} );


/**
 * Version
 * @type {String}
 * @static
 */
FixedHeader.version = "3.1.6";

/**
 * Defaults
 * @type {Object}
 * @static
 */
FixedHeader.defaults = {
	header: true,
	footer: false,
	headerOffset: 0,
	footerOffset: 0
};


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * DataTables interfaces
 */

// Attach for constructor access
$.fn.dataTable.FixedHeader = FixedHeader;
$.fn.DataTable.FixedHeader = FixedHeader;


// DataTables creation - check if the FixedHeader option has been defined on the
// table and if so, initialise
$(document).on( 'init.dt.dtfh', function (e, settings, json) {
	if ( e.namespace !== 'dt' ) {
		return;
	}

	var init = settings.oInit.fixedHeader;
	var defaults = DataTable.defaults.fixedHeader;

	if ( (init || defaults) && ! settings._fixedHeader ) {
		var opts = $.extend( {}, defaults, init );

		if ( init !== false ) {
			new FixedHeader( settings, opts );
		}
	}
} );

// DataTables API methods
DataTable.Api.register( 'fixedHeader()', function () {} );

DataTable.Api.register( 'fixedHeader.adjust()', function () {
	return this.iterator( 'table', function ( ctx ) {
		var fh = ctx._fixedHeader;

		if ( fh ) {
			fh.update();
		}
	} );
} );

DataTable.Api.register( 'fixedHeader.enable()', function ( flag ) {
	return this.iterator( 'table', function ( ctx ) {
		var fh = ctx._fixedHeader;

		flag = ( flag !== undefined ? flag : true );
		if ( fh && flag !== fh.enabled() ) {
			fh.enable( flag );
		}
	} );
} );

DataTable.Api.register( 'fixedHeader.enabled()', function () {
	if ( this.context.length ) {
		var fx = this.content[0]._fixedHeader;

		if ( fh ) {
			return fh.enabled();
		}
	}

	return false;
} );

DataTable.Api.register( 'fixedHeader.disable()', function ( ) {
	return this.iterator( 'table', function ( ctx ) {
		var fh = ctx._fixedHeader;

		if ( fh && fh.enabled() ) {
			fh.enable( false );
		}
	} );
} );

$.each( ['header', 'footer'], function ( i, el ) {
	DataTable.Api.register( 'fixedHeader.'+el+'Offset()', function ( offset ) {
		var ctx = this.context;

		if ( offset === undefined ) {
			return ctx.length && ctx[0]._fixedHeader ?
				ctx[0]._fixedHeader[el +'Offset']() :
				undefined;
		}

		return this.iterator( 'table', function ( ctx ) {
			var fh = ctx._fixedHeader;

			if ( fh ) {
				fh[ el +'Offset' ]( offset );
			}
		} );
	} );
} );


return FixedHeader;
}));


/*! KeyTable 2.5.1
 * 2009-2019 SpryMedia Ltd - datatables.net/license
 */

/**
 * @summary     KeyTable
 * @description Spreadsheet like keyboard navigation for DataTables
 * @version     2.5.1
 * @file        dataTables.keyTable.js
 * @author      SpryMedia Ltd (www.sprymedia.co.uk)
 * @contact     www.sprymedia.co.uk/contact
 * @copyright   Copyright 2009-2019 SpryMedia Ltd.
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license/mit
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */

(function( factory ){
	if ( typeof define === 'function' && define.amd ) {
		// AMD
		define( ['jquery', 'datatables.net'], function ( $ ) {
			return factory( $, window, document );
		} );
	}
	else if ( typeof exports === 'object' ) {
		// CommonJS
		module.exports = function (root, $) {
			if ( ! root ) {
				root = window;
			}

			if ( ! $ || ! $.fn.dataTable ) {
				$ = require('datatables.net')(root, $).$;
			}

			return factory( $, root, root.document );
		};
	}
	else {
		// Browser
		factory( jQuery, window, document );
	}
}(function( $, window, document, undefined ) {
'use strict';
var DataTable = $.fn.dataTable;
var namespaceCounter = 0;


var KeyTable = function ( dt, opts ) {
	// Sanity check that we are using DataTables 1.10 or newer
	if ( ! DataTable.versionCheck || ! DataTable.versionCheck( '1.10.8' ) ) {
		throw 'KeyTable requires DataTables 1.10.8 or newer';
	}

	// User and defaults configuration object
	this.c = $.extend( true, {},
		DataTable.defaults.keyTable,
		KeyTable.defaults,
		opts
	);

	// Internal settings
	this.s = {
		/** @type {DataTable.Api} DataTables' API instance */
		dt: new DataTable.Api( dt ),

		enable: true,

		/** @type {bool} Flag for if a draw is triggered by focus */
		focusDraw: false,

		/** @type {bool} Flag to indicate when waiting for a draw to happen.
		  *   Will ignore key presses at this point
		  */
		waitingForDraw: false,

		/** @type {object} Information about the last cell that was focused */
		lastFocus: null,

		/** @type {string} Unique namespace per instance */
		namespace: '.keyTable-'+(namespaceCounter++)
	};

	// DOM items
	this.dom = {

	};

	// Check if row reorder has already been initialised on this table
	var settings = this.s.dt.settings()[0];
	var exisiting = settings.keytable;
	if ( exisiting ) {
		return exisiting;
	}

	settings.keytable = this;
	this._constructor();
};


$.extend( KeyTable.prototype, {
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * API methods for DataTables API interface
	 */

	/**
	 * Blur the table's cell focus
	 */
	blur: function ()
	{
		this._blur();
	},

	/**
	 * Enable cell focus for the table
	 *
	 * @param  {string} state Can be `true`, `false` or `-string navigation-only`
	 */
	enable: function ( state )
	{
		this.s.enable = state;
	},

	/**
	 * Focus on a cell
	 * @param  {integer} row    Row index
	 * @param  {integer} column Column index
	 */
	focus: function ( row, column )
	{
		this._focus( this.s.dt.cell( row, column ) );
	},

	/**
	 * Is the cell focused
	 * @param  {object} cell Cell index to check
	 * @returns {boolean} true if focused, false otherwise
	 */
	focused: function ( cell )
	{
		var lastFocus = this.s.lastFocus;

		if ( ! lastFocus ) {
			return false;
		}

		var lastIdx = this.s.lastFocus.cell.index();
		return cell.row === lastIdx.row && cell.column === lastIdx.column;
	},


	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Constructor
	 */

	/**
	 * Initialise the KeyTable instance
	 *
	 * @private
	 */
	_constructor: function ()
	{
		this._tabInput();

		var that = this;
		var dt = this.s.dt;
		var table = $( dt.table().node() );
		var namespace = this.s.namespace;
		var editorBlock = false;

		// Need to be able to calculate the cell positions relative to the table
		if ( table.css('position') === 'static' ) {
			table.css( 'position', 'relative' );
		}

		// Click to focus
		$( dt.table().body() ).on( 'click'+namespace, 'th, td', function (e) {
			if ( that.s.enable === false ) {
				return;
			}

			var cell = dt.cell( this );

			if ( ! cell.any() ) {
				return;
			}

			that._focus( cell, null, false, e );
		} );

		// Key events
		$( document ).on( 'keydown'+namespace, function (e) {
			if ( ! editorBlock ) {
				that._key( e );
			}
		} );

		// Click blur
		if ( this.c.blurable ) {
			$( document ).on( 'mousedown'+namespace, function ( e ) {
				// Click on the search input will blur focus
				if ( $(e.target).parents( '.dataTables_filter' ).length ) {
					that._blur();
				}

				// If the click was inside the DataTables container, don't blur
				if ( $(e.target).parents().filter( dt.table().container() ).length ) {
					return;
				}

				// Don't blur in Editor form
				if ( $(e.target).parents('div.DTE').length ) {
					return;
				}

				// Or an Editor date input
				if ( $(e.target).parents('div.editor-datetime').length ) {
					return;
				}

				//If the click was inside the fixed columns container, don't blur
				if ( $(e.target).parents().filter('.DTFC_Cloned').length ) {
					return;
				}

				that._blur();
			} );
		}

		if ( this.c.editor ) {
			var editor = this.c.editor;

			// Need to disable KeyTable when the main editor is shown
			editor.on( 'open.keyTableMain', function (e, mode, action) {
				if ( mode !== 'inline' && that.s.enable ) {
					that.enable( false );

					editor.one( 'close'+namespace, function () {
						that.enable( true );
					} );
				}
			} );

			if ( this.c.editOnFocus ) {
				dt.on( 'key-focus'+namespace+' key-refocus'+namespace, function ( e, dt, cell, orig ) {
					that._editor( null, orig, true );
				} );
			}

			// Activate Editor when a key is pressed (will be ignored, if
			// already active).
			dt.on( 'key'+namespace, function ( e, dt, key, cell, orig ) {
				that._editor( key, orig, false );
			} );

			// Active editing on double click - it will already have focus from
			// the click event handler above
			$( dt.table().body() ).on( 'dblclick'+namespace, 'th, td', function (e) {
				if ( that.s.enable === false ) {
					return;
				}

				var cell = dt.cell( this );

				if ( ! cell.any() ) {
					return;
				}

				that._editor( null, e, true );
			} );

			// While Editor is busy processing, we don't want to process any key events
			editor
				.on('preSubmit', function () {
					editorBlock = true;
				} )
				.on('preSubmitCancelled', function () {
					editorBlock = false;
				} )
				.on('submitComplete', function () {
					editorBlock = false;
				} );
		}

		// Stave saving
		if ( dt.settings()[0].oFeatures.bStateSave ) {
			dt.on( 'stateSaveParams'+namespace, function (e, s, d) {
				d.keyTable = that.s.lastFocus ?
					that.s.lastFocus.cell.index() :
					null;
			} );
		}

		// Redraw - retain focus on the current cell
		dt.on( 'draw'+namespace, function (e) {
			if ( that.s.focusDraw ) {
				return;
			}

			var lastFocus = that.s.lastFocus;

			if ( lastFocus && lastFocus.node && $(lastFocus.node).closest('body') === document.body ) {
				var relative = that.s.lastFocus.relative;
				var info = dt.page.info();
				var row = relative.row + info.start;

				if ( info.recordsDisplay === 0 ) {
					return;
				}

				// Reverse if needed
				if ( row >= info.recordsDisplay ) {
					row = info.recordsDisplay - 1;
				}

				that._focus( row, relative.column, true, e );
			}
		} );

		// Clipboard support
		if ( this.c.clipboard ) {
			this._clipboard();
		}

		dt.on( 'destroy'+namespace, function () {
			that._blur( true );

			// Event tidy up
			dt.off( namespace );

			$( dt.table().body() )
				.off( 'click'+namespace, 'th, td' )
				.off( 'dblclick'+namespace, 'th, td' );

			$( document )
				.off( 'mousedown'+namespace )
				.off( 'keydown'+namespace )
				.off( 'copy'+namespace )
				.off( 'paste'+namespace );
		} );

		// Initial focus comes from state or options
		var state = dt.state.loaded();

		if ( state && state.keyTable ) {
			// Wait until init is done
			dt.one( 'init', function () {
				var cell = dt.cell( state.keyTable );

				// Ensure that the saved cell still exists
				if ( cell.any() ) {
					cell.focus();
				}
			} );
		}
		else if ( this.c.focus ) {
			dt.cell( this.c.focus ).focus();
		}
	},


	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Private methods
	 */

	/**
	 * Blur the control
	 *
	 * @param {boolean} [noEvents=false] Don't trigger updates / events (for destroying)
	 * @private
	 */
	_blur: function (noEvents)
	{
		if ( ! this.s.enable || ! this.s.lastFocus ) {
			return;
		}

		var cell = this.s.lastFocus.cell;

		$( cell.node() ).removeClass( this.c.className );
		this.s.lastFocus = null;

		if ( ! noEvents ) {
			this._updateFixedColumns(cell.index().column);

			this._emitEvent( 'key-blur', [ this.s.dt, cell ] );
		}
	},


	/**
	 * Clipboard interaction handlers
	 *
	 * @private
	 */
	_clipboard: function () {
		var dt = this.s.dt;
		var that = this;
		var namespace = this.s.namespace;

		// IE8 doesn't support getting selected text
		if ( ! window.getSelection ) {
			return;
		}

		$(document).on( 'copy'+namespace, function (ejq) {
			var e = ejq.originalEvent;
			var selection = window.getSelection().toString();
			var focused = that.s.lastFocus;

			// Only copy cell text to clipboard if there is no other selection
			// and there is a focused cell
			if ( ! selection && focused ) {
				e.clipboardData.setData(
					'text/plain',
					focused.cell.render( that.c.clipboardOrthogonal )
				);
				e.preventDefault();
			}
		} );

		$(document).on( 'paste'+namespace, function (ejq) {
			var e = ejq.originalEvent;
			var focused = that.s.lastFocus;
			var activeEl = document.activeElement;
			var editor = that.c.editor;
			var pastedText;

			if ( focused && (! activeEl || activeEl.nodeName.toLowerCase() === 'body') ) {
				e.preventDefault();

				if ( window.clipboardData && window.clipboardData.getData ) {
					// IE
					pastedText = window.clipboardData.getData('Text');
				}
				else if ( e.clipboardData && e.clipboardData.getData ) {
					// Everything else
					pastedText = e.clipboardData.getData('text/plain');
				}

				if ( editor ) {
					// Got Editor - need to activate inline editing,
					// set the value and submit
					editor
						.inline( focused.cell.index() )
						.set( editor.displayed()[0], pastedText )
						.submit();
				}
				else {
					// No editor, so just dump the data in
					focused.cell.data( pastedText );
					dt.draw(false);
				}
			}
		} );
	},


	/**
	 * Get an array of the column indexes that KeyTable can operate on. This
	 * is a merge of the user supplied columns and the visible columns.
	 *
	 * @private
	 */
	_columns: function ()
	{
		var dt = this.s.dt;
		var user = dt.columns( this.c.columns ).indexes();
		var out = [];

		dt.columns( ':visible' ).every( function (i) {
			if ( user.indexOf( i ) !== -1 ) {
				out.push( i );
			}
		} );

		return out;
	},


	/**
	 * Perform excel like navigation for Editor by triggering an edit on key
	 * press
	 *
	 * @param  {integer} key Key code for the pressed key
	 * @param  {object} orig Original event
	 * @private
	 */
	_editor: function ( key, orig, hardEdit )
	{
		var that = this;
		var dt = this.s.dt;
		var editor = this.c.editor;
		var editCell = this.s.lastFocus.cell;
		var namespace = this.s.namespace;

		// Do nothing if there is already an inline edit in this cell
		if ( $('div.DTE', editCell.node()).length ) {
			return;
		}

		// Don't activate Editor on control key presses
		if ( key !== null && (
			(key >= 0x00 && key <= 0x09) ||
			key === 0x0b ||
			key === 0x0c ||
			(key >= 0x0e && key <= 0x1f) ||
			(key >= 0x70 && key <= 0x7b) ||
			(key >= 0x7f && key <= 0x9f)
		) ) {
			return;
		}

		orig.stopPropagation();

		// Return key should do nothing - for textareas it would empty the
		// contents
		if ( key === 13 ) {
			orig.preventDefault();
		}

		var editInline = function () {
			editor
				.one( 'open'+namespace, function () {
					// Remove cancel open
					editor.off( 'cancelOpen'+namespace );

					// Excel style - select all text
					if ( ! hardEdit ) {
						$('div.DTE_Field_InputControl input, div.DTE_Field_InputControl textarea').select();
					}

					// Reduce the keys the Keys listens for
					dt.keys.enable( hardEdit ? 'tab-only' : 'navigation-only' );

					// On blur of the navigation submit
					dt.on( 'key-blur.editor', function (e, dt, cell) {
						if ( editor.displayed() && cell.node() === editCell.node() ) {
							editor.submit();
						}
					} );

					// Highlight the cell a different colour on full edit
					if ( hardEdit ) {
						$( dt.table().container() ).addClass('dtk-focus-alt');
					}

					// If the dev cancels the submit, we need to return focus
					editor.on( 'preSubmitCancelled'+namespace, function () {
						setTimeout( function () {
							that._focus( editCell, null, false );
						}, 50 );
					} );

					editor.on( 'submitUnsuccessful'+namespace, function () {
						that._focus( editCell, null, false );
					} );

					// Restore full key navigation on close
					editor.one( 'close', function () {
						dt.keys.enable( true );
						dt.off( 'key-blur.editor' );
						editor.off( namespace );
						$( dt.table().container() ).removeClass('dtk-focus-alt');
					} );
				} )
				.one( 'cancelOpen'+namespace, function () {
					// `preOpen` can cancel the display of the form, so it
					// might be that the open event handler isn't needed
					editor.off( namespace );
				} )
				.inline( editCell.index() );
		};

		// Editor 1.7 listens for `return` on keyup, so if return is the trigger
		// key, we need to wait for `keyup` otherwise Editor would just submit
		// the content triggered by this keypress.
		if ( key === 13 ) {
			hardEdit = true;

			$(document).one( 'keyup', function () { // immediately removed
				editInline();
			} );
		}
		else {
			editInline();
		}
	},


	/**
	 * Emit an event on the DataTable for listeners
	 *
	 * @param  {string} name Event name
	 * @param  {array} args Event arguments
	 * @private
	 */
	_emitEvent: function ( name, args )
	{
		this.s.dt.iterator( 'table', function ( ctx, i ) {
			$(ctx.nTable).triggerHandler( name, args );
		} );
	},


	/**
	 * Focus on a particular cell, shifting the table's paging if required
	 *
	 * @param  {DataTables.Api|integer} row Can be given as an API instance that
	 *   contains the cell to focus or as an integer. As the latter it is the
	 *   visible row index (from the whole data set) - NOT the data index
	 * @param  {integer} [column] Not required if a cell is given as the first
	 *   parameter. Otherwise this is the column data index for the cell to
	 *   focus on
	 * @param {boolean} [shift=true] Should the viewport be moved to show cell
	 * @private
	 */
	_focus: function ( row, column, shift, originalEvent )
	{
		var that = this;
		var dt = this.s.dt;
		var pageInfo = dt.page.info();
		var lastFocus = this.s.lastFocus;

		if ( ! originalEvent) {
			originalEvent = null;
		}

		if ( ! this.s.enable ) {
			return;
		}

		if ( typeof row !== 'number' ) {
			// Its an API instance - check that there is actually a row
			if ( ! row.any() ) {
				return;
			}

			// Convert the cell to a row and column
			var index = row.index();
			column = index.column;
			row = dt
				.rows( { filter: 'applied', order: 'applied' } )
				.indexes()
				.indexOf( index.row );
			
			// Don't focus rows that were filtered out.
			if ( row < 0 ) {
				return;
			}

			// For server-side processing normalise the row by adding the start
			// point, since `rows().indexes()` includes only rows that are
			// available at the client-side
			if ( pageInfo.serverSide ) {
				row += pageInfo.start;
			}
		}

		// Is the row on the current page? If not, we need to redraw to show the
		// page
		if ( pageInfo.length !== -1 && (row < pageInfo.start || row >= pageInfo.start+pageInfo.length) ) {
			this.s.focusDraw = true;
			this.s.waitingForDraw = true;

			dt
				.one( 'draw', function () {
					that.s.focusDraw = false;
					that.s.waitingForDraw = false;
					that._focus( row, column, undefined, originalEvent );
				} )
				.page( Math.floor( row / pageInfo.length ) )
				.draw( false );

			return;
		}

		// In the available columns?
		if ( $.inArray( column, this._columns() ) === -1 ) {
			return;
		}

		// De-normalise the server-side processing row, so we select the row
		// in its displayed position
		if ( pageInfo.serverSide ) {
			row -= pageInfo.start;
		}

		// Get the cell from the current position - ignoring any cells which might
		// not have been rendered (therefore can't use `:eq()` selector).
		var cells = dt.cells( null, column, {search: 'applied', order: 'applied'} ).flatten();
		var cell = dt.cell( cells[ row ] );

		if ( lastFocus ) {
			// Don't trigger a refocus on the same cell
			if ( lastFocus.node === cell.node() ) {
				this._emitEvent( 'key-refocus', [ this.s.dt, cell, originalEvent || null ] );
				return;
			}

			// Otherwise blur the old focus
			this._blur();
		}

		// Clear focus from other tables
		this._removeOtherFocus();

		var node = $( cell.node() );
		node.addClass( this.c.className );

		this._updateFixedColumns(column);

		// Shift viewpoint and page to make cell visible
		if ( shift === undefined || shift === true ) {
			this._scroll( $(window), $(document.body), node, 'offset' );

			var bodyParent = dt.table().body().parentNode;
			if ( bodyParent !== dt.table().header().parentNode ) {
				var parent = $(bodyParent.parentNode);

				this._scroll( parent, parent, node, 'position' );
			}
		}

		// Event and finish
		this.s.lastFocus = {
			cell: cell,
			node: cell.node(),
			relative: {
				row: dt.rows( { page: 'current' } ).indexes().indexOf( cell.index().row ),
				column: cell.index().column
			}
		};

		this._emitEvent( 'key-focus', [ this.s.dt, cell, originalEvent || null ] );
		dt.state.save();
	},


	/**
	 * Handle key press
	 *
	 * @param  {object} e Event
	 * @private
	 */
	_key: function ( e )
	{
		// If we are waiting for a draw to happen from another key event, then
		// do nothing for this new key press.
		if ( this.s.waitingForDraw ) {
			e.preventDefault();
			return;
		}

		var enable = this.s.enable;
		var navEnable = enable === true || enable === 'navigation-only';
		if ( ! enable ) {
			return;
		}

		if ( (e.keyCode === 0 || e.ctrlKey || e.metaKey || e.altKey) && !(e.ctrlKey && e.altKey) ) {
			return;
		}

		// If not focused, then there is no key action to take
		var lastFocus = this.s.lastFocus;
		if ( ! lastFocus ) {
			return;
		}

		// And the last focus still exists!
		if ( ! this.s.dt.cell(lastFocus.node).any() ) {
			this.s.lastFocus = null;
			return;
		}

		var that = this;
		var dt = this.s.dt;
		var scrolling = this.s.dt.settings()[0].oScroll.sY ? true : false;

		// If we are not listening for this key, do nothing
		if ( this.c.keys && $.inArray( e.keyCode, this.c.keys ) === -1 ) {
			return;
		}

		switch( e.keyCode ) {
			case 9: // tab
				// `enable` can be tab-only
				this._shift( e, e.shiftKey ? 'left' : 'right', true );
				break;

			case 27: // esc
				if ( this.s.blurable && enable === true ) {
					this._blur();
				}
				break;

			case 33: // page up (previous page)
			case 34: // page down (next page)
				if ( navEnable && !scrolling ) {
					e.preventDefault();

					dt
						.page( e.keyCode === 33 ? 'previous' : 'next' )
						.draw( false );
				}
				break;

			case 35: // end (end of current page)
			case 36: // home (start of current page)
				if ( navEnable ) {
					e.preventDefault();
					var indexes = dt.cells( {page: 'current'} ).indexes();
					var colIndexes = this._columns();

					this._focus( dt.cell(
						indexes[ e.keyCode === 35 ? indexes.length-1 : colIndexes[0] ]
					), null, true, e );
				}
				break;

			case 37: // left arrow
				if ( navEnable ) {
					this._shift( e, 'left' );
				}
				break;

			case 38: // up arrow
				if ( navEnable ) {
					this._shift( e, 'up' );
				}
				break;

			case 39: // right arrow
				if ( navEnable ) {
					this._shift( e, 'right' );
				}
				break;

			case 40: // down arrow
				if ( navEnable ) {
					this._shift( e, 'down' );
				}
				break;

			case 113: // F2 - Excel like hard edit
				if ( this.c.editor ) {
					this._editor(null, e, true);
					break;
				}
				// else fallthrough

			default:
				// Everything else - pass through only when fully enabled
				if ( enable === true ) {
					this._emitEvent( 'key', [ dt, e.keyCode, this.s.lastFocus.cell, e ] );
				}
				break;
		}
	},

	/**
	 * Remove focus from all tables other than this one
	 */
	_removeOtherFocus: function ()
	{
		var thisTable = this.s.dt.table().node();

		$.fn.dataTable.tables({api:true}).iterator('table', function (settings) {
			if (this.table().node() !== thisTable) {
				this.cell.blur();
			}
		});
	},

	/**
	 * Scroll a container to make a cell visible in it. This can be used for
	 * both DataTables scrolling and native window scrolling.
	 *
	 * @param  {jQuery} container Scrolling container
	 * @param  {jQuery} scroller  Item being scrolled
	 * @param  {jQuery} cell      Cell in the scroller
	 * @param  {string} posOff    `position` or `offset` - which to use for the
	 *   calculation. `offset` for the document, otherwise `position`
	 * @private
	 */
	_scroll: function ( container, scroller, cell, posOff )
	{
		var offset = cell[posOff]();
		var height = cell.outerHeight();
		var width = cell.outerWidth();

		var scrollTop = scroller.scrollTop();
		var scrollLeft = scroller.scrollLeft();
		var containerHeight = container.height();
		var containerWidth = container.width();

		// If Scroller is being used, the table can be `position: absolute` and that
		// needs to be taken account of in the offset. If no Scroller, this will be 0
		if ( posOff === 'position' ) {
			offset.top += parseInt( cell.closest('table').css('top'), 10 );
		}

		// Top correction
		if ( offset.top < scrollTop ) {
			scroller.scrollTop( offset.top );
		}

		// Left correction
		if ( offset.left < scrollLeft ) {
			scroller.scrollLeft( offset.left );
		}

		// Bottom correction
		if ( offset.top + height > scrollTop + containerHeight && height < containerHeight ) {
			scroller.scrollTop( offset.top + height - containerHeight );
		}

		// Right correction
		if ( offset.left + width > scrollLeft + containerWidth && width < containerWidth ) {
			scroller.scrollLeft( offset.left + width - containerWidth );
		}
	},


	/**
	 * Calculate a single offset movement in the table - up, down, left and
	 * right and then perform the focus if possible
	 *
	 * @param  {object}  e           Event object
	 * @param  {string}  direction   Movement direction
	 * @param  {boolean} keyBlurable `true` if the key press can result in the
	 *   table being blurred. This is so arrow keys won't blur the table, but
	 *   tab will.
	 * @private
	 */
	_shift: function ( e, direction, keyBlurable )
	{
		var that         = this;
		var dt           = this.s.dt;
		var pageInfo     = dt.page.info();
		var rows         = pageInfo.recordsDisplay;
		var currentCell  = this.s.lastFocus.cell;
		var columns      = this._columns();

		if ( ! currentCell ) {
			return;
		}

		var currRow = dt
			.rows( { filter: 'applied', order: 'applied' } )
			.indexes()
			.indexOf( currentCell.index().row );

		// When server-side processing, `rows().indexes()` only gives the rows
		// that are available at the client-side, so we need to normalise the
		// row's current position by the display start point
		if ( pageInfo.serverSide ) {
			currRow += pageInfo.start;
		}

		var currCol = dt
			.columns( columns )
			.indexes()
			.indexOf( currentCell.index().column );

		var
			row = currRow,
			column = columns[ currCol ]; // row is the display, column is an index

		if ( direction === 'right' ) {
			if ( currCol >= columns.length - 1 ) {
				row++;
				column = columns[0];
			}
			else {
				column = columns[ currCol+1 ];
			}
		}
		else if ( direction === 'left' ) {
			if ( currCol === 0 ) {
				row--;
				column = columns[ columns.length - 1 ];
			}
			else {
				column = columns[ currCol-1 ];
			}
		}
		else if ( direction === 'up' ) {
			row--;
		}
		else if ( direction === 'down' ) {
			row++;
		}

		if ( row >= 0 && row < rows && $.inArray( column, columns ) !== -1 ) {
			if (e) {
				e.preventDefault();
			}

			this._focus( row, column, true, e );
		}
		else if ( ! keyBlurable || ! this.c.blurable ) {
			// No new focus, but if the table isn't blurable, then don't loose
			// focus
			if (e) {
				e.preventDefault();
			}
		}
		else {
			this._blur();
		}
	},


	/**
	 * Create a hidden input element that can receive focus on behalf of the
	 * table
	 *
	 * @private
	 */
	_tabInput: function ()
	{
		var that = this;
		var dt = this.s.dt;
		var tabIndex = this.c.tabIndex !== null ?
			this.c.tabIndex :
			dt.settings()[0].iTabIndex;

		if ( tabIndex == -1 ) {
			return;
		}

		var div = $('<div><input type="text" tabindex="'+tabIndex+'"/></div>')
			.css( {
				position: 'absolute',
				height: 1,
				width: 0,
				overflow: 'hidden'
			} )
			.insertBefore( dt.table().node() );

		div.children().on( 'focus', function (e) {
			var cell = dt.cell(':eq(0)', that._columns(), {page: 'current'});

			if ( cell.any() ) {
				that._focus( cell, null, true, e );
			}
		} );
	},

	/**
	 * Update fixed columns if they are enabled and if the cell we are
	 * focusing is inside a fixed column
	 * @param  {integer} column Index of the column being changed
	 * @private
	 */
	_updateFixedColumns: function( column )
	{
		var dt = this.s.dt;
		var settings = dt.settings()[0];

		if ( settings._oFixedColumns ) {
			var leftCols = settings._oFixedColumns.s.iLeftColumns;
			var rightCols = settings.aoColumns.length - settings._oFixedColumns.s.iRightColumns;

			if (column < leftCols || column >= rightCols) {
				dt.fixedColumns().update();
			}
		}
	}
} );


/**
 * KeyTable default settings for initialisation
 *
 * @namespace
 * @name KeyTable.defaults
 * @static
 */
KeyTable.defaults = {
	/**
	 * Can focus be removed from the table
	 * @type {Boolean}
	 */
	blurable: true,

	/**
	 * Class to give to the focused cell
	 * @type {String}
	 */
	className: 'focus',

	/**
	 * Enable or disable clipboard support
	 * @type {Boolean}
	 */
	clipboard: true,

	/**
	 * Orthogonal data that should be copied to clipboard
	 * @type {string}
	 */
	clipboardOrthogonal: 'display',

	/**
	 * Columns that can be focused. This is automatically merged with the
	 * visible columns as only visible columns can gain focus.
	 * @type {String}
	 */
	columns: '', // all

	/**
	 * Editor instance to automatically perform Excel like navigation
	 * @type {Editor}
	 */
	editor: null,

	/**
	 * Trigger editing immediately on focus
	 * @type {boolean}
	 */
	editOnFocus: false,

	/**
	 * Select a cell to automatically select on start up. `null` for no
	 * automatic selection
	 * @type {cell-selector}
	 */
	focus: null,

	/**
	 * Array of keys to listen for
	 * @type {null|array}
	 */
	keys: null,

	/**
	 * Tab index for where the table should sit in the document's tab flow
	 * @type {integer|null}
	 */
	tabIndex: null
};



KeyTable.version = "2.5.1";


$.fn.dataTable.KeyTable = KeyTable;
$.fn.DataTable.KeyTable = KeyTable;


DataTable.Api.register( 'cell.blur()', function () {
	return this.iterator( 'table', function (ctx) {
		if ( ctx.keytable ) {
			ctx.keytable.blur();
		}
	} );
} );

DataTable.Api.register( 'cell().focus()', function () {
	return this.iterator( 'cell', function (ctx, row, column) {
		if ( ctx.keytable ) {
			ctx.keytable.focus( row, column );
		}
	} );
} );

DataTable.Api.register( 'keys.disable()', function () {
	return this.iterator( 'table', function (ctx) {
		if ( ctx.keytable ) {
			ctx.keytable.enable( false );
		}
	} );
} );

DataTable.Api.register( 'keys.enable()', function ( opts ) {
	return this.iterator( 'table', function (ctx) {
		if ( ctx.keytable ) {
			ctx.keytable.enable( opts === undefined ? true : opts );
		}
	} );
} );

DataTable.Api.register( 'keys.move()', function ( dir ) {
	return this.iterator( 'table', function (ctx) {
		if ( ctx.keytable ) {
			ctx.keytable._shift( null, dir, false );
		}
	} );
} );

// Cell selector
DataTable.ext.selector.cell.push( function ( settings, opts, cells ) {
	var focused = opts.focused;
	var kt = settings.keytable;
	var out = [];

	if ( ! kt || focused === undefined ) {
		return cells;
	}

	for ( var i=0, ien=cells.length ; i<ien ; i++ ) {
		if ( (focused === true &&  kt.focused( cells[i] ) ) ||
			 (focused === false && ! kt.focused( cells[i] ) )
		) {
			out.push( cells[i] );
		}
	}

	return out;
} );


// Attach a listener to the document which listens for DataTables initialisation
// events so we can automatically initialise
$(document).on( 'preInit.dt.dtk', function (e, settings, json) {
	if ( e.namespace !== 'dt' ) {
		return;
	}

	var init = settings.oInit.keys;
	var defaults = DataTable.defaults.keys;

	if ( init || defaults ) {
		var opts = $.extend( {}, defaults, init );

		if ( init !== false ) {
			new KeyTable( settings, opts  );
		}
	}
} );


return KeyTable;
}));


/*! Responsive 2.2.3
 * 2014-2018 SpryMedia Ltd - datatables.net/license
 */

/**
 * @summary     Responsive
 * @description Responsive tables plug-in for DataTables
 * @version     2.2.3
 * @file        dataTables.responsive.js
 * @author      SpryMedia Ltd (www.sprymedia.co.uk)
 * @contact     www.sprymedia.co.uk/contact
 * @copyright   Copyright 2014-2018 SpryMedia Ltd.
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license/mit
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */
(function( factory ){
	if ( typeof define === 'function' && define.amd ) {
		// AMD
		define( ['jquery', 'datatables.net'], function ( $ ) {
			return factory( $, window, document );
		} );
	}
	else if ( typeof exports === 'object' ) {
		// CommonJS
		module.exports = function (root, $) {
			if ( ! root ) {
				root = window;
			}

			if ( ! $ || ! $.fn.dataTable ) {
				$ = require('datatables.net')(root, $).$;
			}

			return factory( $, root, root.document );
		};
	}
	else {
		// Browser
		factory( jQuery, window, document );
	}
}(function( $, window, document, undefined ) {
'use strict';
var DataTable = $.fn.dataTable;


/**
 * Responsive is a plug-in for the DataTables library that makes use of
 * DataTables' ability to change the visibility of columns, changing the
 * visibility of columns so the displayed columns fit into the table container.
 * The end result is that complex tables will be dynamically adjusted to fit
 * into the viewport, be it on a desktop, tablet or mobile browser.
 *
 * Responsive for DataTables has two modes of operation, which can used
 * individually or combined:
 *
 * * Class name based control - columns assigned class names that match the
 *   breakpoint logic can be shown / hidden as required for each breakpoint.
 * * Automatic control - columns are automatically hidden when there is no
 *   room left to display them. Columns removed from the right.
 *
 * In additional to column visibility control, Responsive also has built into
 * options to use DataTables' child row display to show / hide the information
 * from the table that has been hidden. There are also two modes of operation
 * for this child row display:
 *
 * * Inline - when the control element that the user can use to show / hide
 *   child rows is displayed inside the first column of the table.
 * * Column - where a whole column is dedicated to be the show / hide control.
 *
 * Initialisation of Responsive is performed by:
 *
 * * Adding the class `responsive` or `dt-responsive` to the table. In this case
 *   Responsive will automatically be initialised with the default configuration
 *   options when the DataTable is created.
 * * Using the `responsive` option in the DataTables configuration options. This
 *   can also be used to specify the configuration options, or simply set to
 *   `true` to use the defaults.
 *
 *  @class
 *  @param {object} settings DataTables settings object for the host table
 *  @param {object} [opts] Configuration options
 *  @requires jQuery 1.7+
 *  @requires DataTables 1.10.3+
 *
 *  @example
 *      $('#example').DataTable( {
 *        responsive: true
 *      } );
 *    } );
 */
var Responsive = function ( settings, opts ) {
	// Sanity check that we are using DataTables 1.10 or newer
	if ( ! DataTable.versionCheck || ! DataTable.versionCheck( '1.10.10' ) ) {
		throw 'DataTables Responsive requires DataTables 1.10.10 or newer';
	}

	this.s = {
		dt: new DataTable.Api( settings ),
		columns: [],
		current: []
	};

	// Check if responsive has already been initialised on this table
	if ( this.s.dt.settings()[0].responsive ) {
		return;
	}

	// details is an object, but for simplicity the user can give it as a string
	// or a boolean
	if ( opts && typeof opts.details === 'string' ) {
		opts.details = { type: opts.details };
	}
	else if ( opts && opts.details === false ) {
		opts.details = { type: false };
	}
	else if ( opts && opts.details === true ) {
		opts.details = { type: 'inline' };
	}

	this.c = $.extend( true, {}, Responsive.defaults, DataTable.defaults.responsive, opts );
	settings.responsive = this;
	this._constructor();
};

$.extend( Responsive.prototype, {
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Constructor
	 */

	/**
	 * Initialise the Responsive instance
	 *
	 * @private
	 */
	_constructor: function ()
	{
		var that = this;
		var dt = this.s.dt;
		var dtPrivateSettings = dt.settings()[0];
		var oldWindowWidth = $(window).width();

		dt.settings()[0]._responsive = this;

		// Use DataTables' throttle function to avoid processor thrashing on
		// resize
		$(window).on( 'resize.dtr orientationchange.dtr', DataTable.util.throttle( function () {
			// iOS has a bug whereby resize can fire when only scrolling
			// See: http://stackoverflow.com/questions/8898412
			var width = $(window).width();

			if ( width !== oldWindowWidth ) {
				that._resize();
				oldWindowWidth = width;
			}
		} ) );

		// DataTables doesn't currently trigger an event when a row is added, so
		// we need to hook into its private API to enforce the hidden rows when
		// new data is added
		dtPrivateSettings.oApi._fnCallbackReg( dtPrivateSettings, 'aoRowCreatedCallback', function (tr, data, idx) {
			if ( $.inArray( false, that.s.current ) !== -1 ) {
				$('>td, >th', tr).each( function ( i ) {
					var idx = dt.column.index( 'toData', i );

					if ( that.s.current[idx] === false ) {
						$(this).css('display', 'none');
					}
				} );
			}
		} );

		// Destroy event handler
		dt.on( 'destroy.dtr', function () {
			dt.off( '.dtr' );
			$( dt.table().body() ).off( '.dtr' );
			$(window).off( 'resize.dtr orientationchange.dtr' );

			// Restore the columns that we've hidden
			$.each( that.s.current, function ( i, val ) {
				if ( val === false ) {
					that._setColumnVis( i, true );
				}
			} );
		} );

		// Reorder the breakpoints array here in case they have been added out
		// of order
		this.c.breakpoints.sort( function (a, b) {
			return a.width < b.width ? 1 :
				a.width > b.width ? -1 : 0;
		} );

		this._classLogic();
		this._resizeAuto();

		// Details handler
		var details = this.c.details;

		if ( details.type !== false ) {
			that._detailsInit();

			// DataTables will trigger this event on every column it shows and
			// hides individually
			dt.on( 'column-visibility.dtr', function () {
				// Use a small debounce to allow multiple columns to be set together
				if ( that._timer ) {
					clearTimeout( that._timer );
				}

				that._timer = setTimeout( function () {
					that._timer = null;

					that._classLogic();
					that._resizeAuto();
					that._resize();

					that._redrawChildren();
				}, 100 );
			} );

			// Redraw the details box on each draw which will happen if the data
			// has changed. This is used until DataTables implements a native
			// `updated` event for rows
			dt.on( 'draw.dtr', function () {
				that._redrawChildren();
			} );

			$(dt.table().node()).addClass( 'dtr-'+details.type );
		}

		dt.on( 'column-reorder.dtr', function (e, settings, details) {
			that._classLogic();
			that._resizeAuto();
			that._resize();
		} );

		// Change in column sizes means we need to calc
		dt.on( 'column-sizing.dtr', function () {
			that._resizeAuto();
			that._resize();
		});

		// On Ajax reload we want to reopen any child rows which are displayed
		// by responsive
		dt.on( 'preXhr.dtr', function () {
			var rowIds = [];
			dt.rows().every( function () {
				if ( this.child.isShown() ) {
					rowIds.push( this.id(true) );
				}
			} );

			dt.one( 'draw.dtr', function () {
				that._resizeAuto();
				that._resize();

				dt.rows( rowIds ).every( function () {
					that._detailsDisplay( this, false );
				} );
			} );
		});

		dt.on( 'init.dtr', function (e, settings, details) {
			that._resizeAuto();
			that._resize();

			// If columns were hidden, then DataTables needs to adjust the
			// column sizing
			if ( $.inArray( false, that.s.current ) ) {
				dt.columns.adjust();
			}
		} );

		// First pass - draw the table for the current viewport size
		this._resize();
	},


	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Private methods
	 */

	/**
	 * Calculate the visibility for the columns in a table for a given
	 * breakpoint. The result is pre-determined based on the class logic if
	 * class names are used to control all columns, but the width of the table
	 * is also used if there are columns which are to be automatically shown
	 * and hidden.
	 *
	 * @param  {string} breakpoint Breakpoint name to use for the calculation
	 * @return {array} Array of boolean values initiating the visibility of each
	 *   column.
	 *  @private
	 */
	_columnsVisiblity: function ( breakpoint )
	{
		var dt = this.s.dt;
		var columns = this.s.columns;
		var i, ien;

		// Create an array that defines the column ordering based first on the
		// column's priority, and secondly the column index. This allows the
		// columns to be removed from the right if the priority matches
		var order = columns
			.map( function ( col, idx ) {
				return {
					columnIdx: idx,
					priority: col.priority
				};
			} )
			.sort( function ( a, b ) {
				if ( a.priority !== b.priority ) {
					return a.priority - b.priority;
				}
				return a.columnIdx - b.columnIdx;
			} );

		// Class logic - determine which columns are in this breakpoint based
		// on the classes. If no class control (i.e. `auto`) then `-` is used
		// to indicate this to the rest of the function
		var display = $.map( columns, function ( col, i ) {
			if ( dt.column(i).visible() === false ) {
				return 'not-visible';
			}
			return col.auto && col.minWidth === null ?
				false :
				col.auto === true ?
					'-' :
					$.inArray( breakpoint, col.includeIn ) !== -1;
		} );

		// Auto column control - first pass: how much width is taken by the
		// ones that must be included from the non-auto columns
		var requiredWidth = 0;
		for ( i=0, ien=display.length ; i<ien ; i++ ) {
			if ( display[i] === true ) {
				requiredWidth += columns[i].minWidth;
			}
		}

		// Second pass, use up any remaining width for other columns. For
		// scrolling tables we need to subtract the width of the scrollbar. It
		// may not be requires which makes this sub-optimal, but it would
		// require another full redraw to make complete use of those extra few
		// pixels
		var scrolling = dt.settings()[0].oScroll;
		var bar = scrolling.sY || scrolling.sX ? scrolling.iBarWidth : 0;
		var widthAvailable = dt.table().container().offsetWidth - bar;
		var usedWidth = widthAvailable - requiredWidth;

		// Control column needs to always be included. This makes it sub-
		// optimal in terms of using the available with, but to stop layout
		// thrashing or overflow. Also we need to account for the control column
		// width first so we know how much width is available for the other
		// columns, since the control column might not be the first one shown
		for ( i=0, ien=display.length ; i<ien ; i++ ) {
			if ( columns[i].control ) {
				usedWidth -= columns[i].minWidth;
			}
		}

		// Allow columns to be shown (counting by priority and then right to
		// left) until we run out of room
		var empty = false;
		for ( i=0, ien=order.length ; i<ien ; i++ ) {
			var colIdx = order[i].columnIdx;

			if ( display[colIdx] === '-' && ! columns[colIdx].control && columns[colIdx].minWidth ) {
				// Once we've found a column that won't fit we don't let any
				// others display either, or columns might disappear in the
				// middle of the table
				if ( empty || usedWidth - columns[colIdx].minWidth < 0 ) {
					empty = true;
					display[colIdx] = false;
				}
				else {
					display[colIdx] = true;
				}

				usedWidth -= columns[colIdx].minWidth;
			}
		}

		// Determine if the 'control' column should be shown (if there is one).
		// This is the case when there is a hidden column (that is not the
		// control column). The two loops look inefficient here, but they are
		// trivial and will fly through. We need to know the outcome from the
		// first , before the action in the second can be taken
		var showControl = false;

		for ( i=0, ien=columns.length ; i<ien ; i++ ) {
			if ( ! columns[i].control && ! columns[i].never && display[i] === false ) {
				showControl = true;
				break;
			}
		}

		for ( i=0, ien=columns.length ; i<ien ; i++ ) {
			if ( columns[i].control ) {
				display[i] = showControl;
			}

			// Replace not visible string with false from the control column detection above
			if ( display[i] === 'not-visible' ) {
				display[i] = false;
			}
		}

		// Finally we need to make sure that there is at least one column that
		// is visible
		if ( $.inArray( true, display ) === -1 ) {
			display[0] = true;
		}

		return display;
	},


	/**
	 * Create the internal `columns` array with information about the columns
	 * for the table. This includes determining which breakpoints the column
	 * will appear in, based upon class names in the column, which makes up the
	 * vast majority of this method.
	 *
	 * @private
	 */
	_classLogic: function ()
	{
		var that = this;
		var calc = {};
		var breakpoints = this.c.breakpoints;
		var dt = this.s.dt;
		var columns = dt.columns().eq(0).map( function (i) {
			var column = this.column(i);
			var className = column.header().className;
			var priority = dt.settings()[0].aoColumns[i].responsivePriority;

			if ( priority === undefined ) {
				var dataPriority = $(column.header()).data('priority');

				priority = dataPriority !== undefined ?
					dataPriority * 1 :
					10000;
			}

			return {
				className: className,
				includeIn: [],
				auto:      false,
				control:   false,
				never:     className.match(/\bnever\b/) ? true : false,
				priority:  priority
			};
		} );

		// Simply add a breakpoint to `includeIn` array, ensuring that there are
		// no duplicates
		var add = function ( colIdx, name ) {
			var includeIn = columns[ colIdx ].includeIn;

			if ( $.inArray( name, includeIn ) === -1 ) {
				includeIn.push( name );
			}
		};

		var column = function ( colIdx, name, operator, matched ) {
			var size, i, ien;

			if ( ! operator ) {
				columns[ colIdx ].includeIn.push( name );
			}
			else if ( operator === 'max-' ) {
				// Add this breakpoint and all smaller
				size = that._find( name ).width;

				for ( i=0, ien=breakpoints.length ; i<ien ; i++ ) {
					if ( breakpoints[i].width <= size ) {
						add( colIdx, breakpoints[i].name );
					}
				}
			}
			else if ( operator === 'min-' ) {
				// Add this breakpoint and all larger
				size = that._find( name ).width;

				for ( i=0, ien=breakpoints.length ; i<ien ; i++ ) {
					if ( breakpoints[i].width >= size ) {
						add( colIdx, breakpoints[i].name );
					}
				}
			}
			else if ( operator === 'not-' ) {
				// Add all but this breakpoint
				for ( i=0, ien=breakpoints.length ; i<ien ; i++ ) {
					if ( breakpoints[i].name.indexOf( matched ) === -1 ) {
						add( colIdx, breakpoints[i].name );
					}
				}
			}
		};

		// Loop over each column and determine if it has a responsive control
		// class
		columns.each( function ( col, i ) {
			var classNames = col.className.split(' ');
			var hasClass = false;

			// Split the class name up so multiple rules can be applied if needed
			for ( var k=0, ken=classNames.length ; k<ken ; k++ ) {
				var className = $.trim( classNames[k] );

				if ( className === 'all' ) {
					// Include in all
					hasClass = true;
					col.includeIn = $.map( breakpoints, function (a) {
						return a.name;
					} );
					return;
				}
				else if ( className === 'none' || col.never ) {
					// Include in none (default) and no auto
					hasClass = true;
					return;
				}
				else if ( className === 'control' ) {
					// Special column that is only visible, when one of the other
					// columns is hidden. This is used for the details control
					hasClass = true;
					col.control = true;
					return;
				}

				$.each( breakpoints, function ( j, breakpoint ) {
					// Does this column have a class that matches this breakpoint?
					var brokenPoint = breakpoint.name.split('-');
					var re = new RegExp( '(min\\-|max\\-|not\\-)?('+brokenPoint[0]+')(\\-[_a-zA-Z0-9])?' );
					var match = className.match( re );

					if ( match ) {
						hasClass = true;

						if ( match[2] === brokenPoint[0] && match[3] === '-'+brokenPoint[1] ) {
							// Class name matches breakpoint name fully
							column( i, breakpoint.name, match[1], match[2]+match[3] );
						}
						else if ( match[2] === brokenPoint[0] && ! match[3] ) {
							// Class name matched primary breakpoint name with no qualifier
							column( i, breakpoint.name, match[1], match[2] );
						}
					}
				} );
			}

			// If there was no control class, then automatic sizing is used
			if ( ! hasClass ) {
				col.auto = true;
			}
		} );

		this.s.columns = columns;
	},


	/**
	 * Show the details for the child row
	 *
	 * @param  {DataTables.Api} row    API instance for the row
	 * @param  {boolean}        update Update flag
	 * @private
	 */
	_detailsDisplay: function ( row, update )
	{
		var that = this;
		var dt = this.s.dt;
		var details = this.c.details;

		if ( details && details.type !== false ) {
			var res = details.display( row, update, function () {
				return details.renderer(
					dt, row[0], that._detailsObj(row[0])
				);
			} );

			if ( res === true || res === false ) {
				$(dt.table().node()).triggerHandler( 'responsive-display.dt', [dt, row, res, update] );
			}
		}
	},


	/**
	 * Initialisation for the details handler
	 *
	 * @private
	 */
	_detailsInit: function ()
	{
		var that    = this;
		var dt      = this.s.dt;
		var details = this.c.details;

		// The inline type always uses the first child as the target
		if ( details.type === 'inline' ) {
			details.target = 'td:first-child, th:first-child';
		}

		// Keyboard accessibility
		dt.on( 'draw.dtr', function () {
			that._tabIndexes();
		} );
		that._tabIndexes(); // Initial draw has already happened

		$( dt.table().body() ).on( 'keyup.dtr', 'td, th', function (e) {
			if ( e.keyCode === 13 && $(this).data('dtr-keyboard') ) {
				$(this).click();
			}
		} );

		// type.target can be a string jQuery selector or a column index
		var target   = details.target;
		var selector = typeof target === 'string' ? target : 'td, th';

		// Click handler to show / hide the details rows when they are available
		$( dt.table().body() )
			.on( 'click.dtr mousedown.dtr mouseup.dtr', selector, function (e) {
				// If the table is not collapsed (i.e. there is no hidden columns)
				// then take no action
				if ( ! $(dt.table().node()).hasClass('collapsed' ) ) {
					return;
				}

				// Check that the row is actually a DataTable's controlled node
				if ( $.inArray( $(this).closest('tr').get(0), dt.rows().nodes().toArray() ) === -1 ) {
					return;
				}

				// For column index, we determine if we should act or not in the
				// handler - otherwise it is already okay
				if ( typeof target === 'number' ) {
					var targetIdx = target < 0 ?
						dt.columns().eq(0).length + target :
						target;

					if ( dt.cell( this ).index().column !== targetIdx ) {
						return;
					}
				}

				// $().closest() includes itself in its check
				var row = dt.row( $(this).closest('tr') );

				// Check event type to do an action
				if ( e.type === 'click' ) {
					// The renderer is given as a function so the caller can execute it
					// only when they need (i.e. if hiding there is no point is running
					// the renderer)
					that._detailsDisplay( row, false );
				}
				else if ( e.type === 'mousedown' ) {
					// For mouse users, prevent the focus ring from showing
					$(this).css('outline', 'none');
				}
				else if ( e.type === 'mouseup' ) {
					// And then re-allow at the end of the click
					$(this).blur().css('outline', '');
				}
			} );
	},


	/**
	 * Get the details to pass to a renderer for a row
	 * @param  {int} rowIdx Row index
	 * @private
	 */
	_detailsObj: function ( rowIdx )
	{
		var that = this;
		var dt = this.s.dt;

		return $.map( this.s.columns, function( col, i ) {
			// Never and control columns should not be passed to the renderer
			if ( col.never || col.control ) {
				return;
			}

			return {
				title:       dt.settings()[0].aoColumns[ i ].sTitle,
				data:        dt.cell( rowIdx, i ).render( that.c.orthogonal ),
				hidden:      dt.column( i ).visible() && !that.s.current[ i ],
				columnIndex: i,
				rowIndex:    rowIdx
			};
		} );
	},


	/**
	 * Find a breakpoint object from a name
	 *
	 * @param  {string} name Breakpoint name to find
	 * @return {object}      Breakpoint description object
	 * @private
	 */
	_find: function ( name )
	{
		var breakpoints = this.c.breakpoints;

		for ( var i=0, ien=breakpoints.length ; i<ien ; i++ ) {
			if ( breakpoints[i].name === name ) {
				return breakpoints[i];
			}
		}
	},


	/**
	 * Re-create the contents of the child rows as the display has changed in
	 * some way.
	 *
	 * @private
	 */
	_redrawChildren: function ()
	{
		var that = this;
		var dt = this.s.dt;

		dt.rows( {page: 'current'} ).iterator( 'row', function ( settings, idx ) {
			var row = dt.row( idx );

			that._detailsDisplay( dt.row( idx ), true );
		} );
	},


	/**
	 * Alter the table display for a resized viewport. This involves first
	 * determining what breakpoint the window currently is in, getting the
	 * column visibilities to apply and then setting them.
	 *
	 * @private
	 */
	_resize: function ()
	{
		var that = this;
		var dt = this.s.dt;
		var width = $(window).width();
		var breakpoints = this.c.breakpoints;
		var breakpoint = breakpoints[0].name;
		var columns = this.s.columns;
		var i, ien;
		var oldVis = this.s.current.slice();

		// Determine what breakpoint we are currently at
		for ( i=breakpoints.length-1 ; i>=0 ; i-- ) {
			if ( width <= breakpoints[i].width ) {
				breakpoint = breakpoints[i].name;
				break;
			}
		}
		
		// Show the columns for that break point
		var columnsVis = this._columnsVisiblity( breakpoint );
		this.s.current = columnsVis;

		// Set the class before the column visibility is changed so event
		// listeners know what the state is. Need to determine if there are
		// any columns that are not visible but can be shown
		var collapsedClass = false;
		for ( i=0, ien=columns.length ; i<ien ; i++ ) {
			if ( columnsVis[i] === false && ! columns[i].never && ! columns[i].control && ! dt.column(i).visible() === false ) {
				collapsedClass = true;
				break;
			}
		}

		$( dt.table().node() ).toggleClass( 'collapsed', collapsedClass );

		var changed = false;
		var visible = 0;

		dt.columns().eq(0).each( function ( colIdx, i ) {
			if ( columnsVis[i] === true ) {
				visible++;
			}

			if ( columnsVis[i] !== oldVis[i] ) {
				changed = true;
				that._setColumnVis( colIdx, columnsVis[i] );
			}
		} );

		if ( changed ) {
			this._redrawChildren();

			// Inform listeners of the change
			$(dt.table().node()).trigger( 'responsive-resize.dt', [dt, this.s.current] );

			// If no records, update the "No records" display element
			if ( dt.page.info().recordsDisplay === 0 ) {
				$('td', dt.table().body()).eq(0).attr('colspan', visible);
			}
		}
	},


	/**
	 * Determine the width of each column in the table so the auto column hiding
	 * has that information to work with. This method is never going to be 100%
	 * perfect since column widths can change slightly per page, but without
	 * seriously compromising performance this is quite effective.
	 *
	 * @private
	 */
	_resizeAuto: function ()
	{
		var dt = this.s.dt;
		var columns = this.s.columns;

		// Are we allowed to do auto sizing?
		if ( ! this.c.auto ) {
			return;
		}

		// Are there any columns that actually need auto-sizing, or do they all
		// have classes defined
		if ( $.inArray( true, $.map( columns, function (c) { return c.auto; } ) ) === -1 ) {
			return;
		}

		// Need to restore all children. They will be reinstated by a re-render
		if ( ! $.isEmptyObject( _childNodeStore ) ) {
			$.each( _childNodeStore, function ( key ) {
				var idx = key.split('-');

				_childNodesRestore( dt, idx[0]*1, idx[1]*1 );
			} );
		}

		// Clone the table with the current data in it
		var tableWidth   = dt.table().node().offsetWidth;
		var columnWidths = dt.columns;
		var clonedTable  = dt.table().node().cloneNode( false );
		var clonedHeader = $( dt.table().header().cloneNode( false ) ).appendTo( clonedTable );
		var clonedBody   = $( dt.table().body() ).clone( false, false ).empty().appendTo( clonedTable ); // use jQuery because of IE8

		// Header
		var headerCells = dt.columns()
			.header()
			.filter( function (idx) {
				return dt.column(idx).visible();
			} )
			.to$()
			.clone( false )
			.css( 'display', 'table-cell' )
			.css( 'min-width', 0 );

		// Body rows - we don't need to take account of DataTables' column
		// visibility since we implement our own here (hence the `display` set)
		$(clonedBody)
			.append( $(dt.rows( { page: 'current' } ).nodes()).clone( false ) )
			.find( 'th, td' ).css( 'display', '' );

		// Footer
		var footer = dt.table().footer();
		if ( footer ) {
			var clonedFooter = $( footer.cloneNode( false ) ).appendTo( clonedTable );
			var footerCells = dt.columns()
				.footer()
				.filter( function (idx) {
					return dt.column(idx).visible();
				} )
				.to$()
				.clone( false )
				.css( 'display', 'table-cell' );

			$('<tr/>')
				.append( footerCells )
				.appendTo( clonedFooter );
		}

		$('<tr/>')
			.append( headerCells )
			.appendTo( clonedHeader );

		// In the inline case extra padding is applied to the first column to
		// give space for the show / hide icon. We need to use this in the
		// calculation
		if ( this.c.details.type === 'inline' ) {
			$(clonedTable).addClass( 'dtr-inline collapsed' );
		}
		
		// It is unsafe to insert elements with the same name into the DOM
		// multiple times. For example, cloning and inserting a checked radio
		// clears the chcecked state of the original radio.
		$( clonedTable ).find( '[name]' ).removeAttr( 'name' );

		// A position absolute table would take the table out of the flow of
		// our container element, bypassing the height and width (Scroller)
		$( clonedTable ).css( 'position', 'relative' )
		
		var inserted = $('<div/>')
			.css( {
				width: 1,
				height: 1,
				overflow: 'hidden',
				clear: 'both'
			} )
			.append( clonedTable );

		inserted.insertBefore( dt.table().node() );

		// The cloned header now contains the smallest that each column can be
		headerCells.each( function (i) {
			var idx = dt.column.index( 'fromVisible', i );
			columns[ idx ].minWidth =  this.offsetWidth || 0;
		} );

		inserted.remove();
	},

	/**
	 * Set a column's visibility.
	 *
	 * We don't use DataTables' column visibility controls in order to ensure
	 * that column visibility can Responsive can no-exist. Since only IE8+ is
	 * supported (and all evergreen browsers of course) the control of the
	 * display attribute works well.
	 *
	 * @param {integer} col      Column index
	 * @param {boolean} showHide Show or hide (true or false)
	 * @private
	 */
	_setColumnVis: function ( col, showHide )
	{
		var dt = this.s.dt;
		var display = showHide ? '' : 'none'; // empty string will remove the attr

		$( dt.column( col ).header() ).css( 'display', display );
		$( dt.column( col ).footer() ).css( 'display', display );
		dt.column( col ).nodes().to$().css( 'display', display );

		// If the are child nodes stored, we might need to reinsert them
		if ( ! $.isEmptyObject( _childNodeStore ) ) {
			dt.cells( null, col ).indexes().each( function (idx) {
				_childNodesRestore( dt, idx.row, idx.column );
			} );
		}
	},


	/**
	 * Update the cell tab indexes for keyboard accessibility. This is called on
	 * every table draw - that is potentially inefficient, but also the least
	 * complex option given that column visibility can change on the fly. Its a
	 * shame user-focus was removed from CSS 3 UI, as it would have solved this
	 * issue with a single CSS statement.
	 *
	 * @private
	 */
	_tabIndexes: function ()
	{
		var dt = this.s.dt;
		var cells = dt.cells( { page: 'current' } ).nodes().to$();
		var ctx = dt.settings()[0];
		var target = this.c.details.target;

		cells.filter( '[data-dtr-keyboard]' ).removeData( '[data-dtr-keyboard]' );

		if ( typeof target === 'number' ) {
			dt.cells( null, target, { page: 'current' } ).nodes().to$()
				.attr( 'tabIndex', ctx.iTabIndex )
				.data( 'dtr-keyboard', 1 );
		}
		else {
			// This is a bit of a hack - we need to limit the selected nodes to just
			// those of this table
			if ( target === 'td:first-child, th:first-child' ) {
				target = '>td:first-child, >th:first-child';
			}

			$( target, dt.rows( { page: 'current' } ).nodes() )
				.attr( 'tabIndex', ctx.iTabIndex )
				.data( 'dtr-keyboard', 1 );
		}
	}
} );


/**
 * List of default breakpoints. Each item in the array is an object with two
 * properties:
 *
 * * `name` - the breakpoint name.
 * * `width` - the breakpoint width
 *
 * @name Responsive.breakpoints
 * @static
 */
Responsive.breakpoints = [
	{ name: 'desktop',  width: Infinity },
	{ name: 'tablet-l', width: 1024 },
	{ name: 'tablet-p', width: 768 },
	{ name: 'mobile-l', width: 480 },
	{ name: 'mobile-p', width: 320 }
];


/**
 * Display methods - functions which define how the hidden data should be shown
 * in the table.
 *
 * @namespace
 * @name Responsive.defaults
 * @static
 */
Responsive.display = {
	childRow: function ( row, update, render ) {
		if ( update ) {
			if ( $(row.node()).hasClass('parent') ) {
				row.child( render(), 'child' ).show();

				return true;
			}
		}
		else {
			if ( ! row.child.isShown()  ) {
				row.child( render(), 'child' ).show();
				$( row.node() ).addClass( 'parent' );

				return true;
			}
			else {
				row.child( false );
				$( row.node() ).removeClass( 'parent' );

				return false;
			}
		}
	},

	childRowImmediate: function ( row, update, render ) {
		if ( (! update && row.child.isShown()) || ! row.responsive.hasHidden() ) {
			// User interaction and the row is show, or nothing to show
			row.child( false );
			$( row.node() ).removeClass( 'parent' );

			return false;
		}
		else {
			// Display
			row.child( render(), 'child' ).show();
			$( row.node() ).addClass( 'parent' );

			return true;
		}
	},

	// This is a wrapper so the modal options for Bootstrap and jQuery UI can
	// have options passed into them. This specific one doesn't need to be a
	// function but it is for consistency in the `modal` name
	modal: function ( options ) {
		return function ( row, update, render ) {
			if ( ! update ) {
				// Show a modal
				var close = function () {
					modal.remove(); // will tidy events for us
					$(document).off( 'keypress.dtr' );
				};

				var modal = $('<div class="dtr-modal"/>')
					.append( $('<div class="dtr-modal-display"/>')
						.append( $('<div class="dtr-modal-content"/>')
							.append( render() )
						)
						.append( $('<div class="dtr-modal-close">&times;</div>' )
							.click( function () {
								close();
							} )
						)
					)
					.append( $('<div class="dtr-modal-background"/>')
						.click( function () {
							close();
						} )
					)
					.appendTo( 'body' );

				$(document).on( 'keyup.dtr', function (e) {
					if ( e.keyCode === 27 ) {
						e.stopPropagation();

						close();
					}
				} );
			}
			else {
				$('div.dtr-modal-content')
					.empty()
					.append( render() );
			}

			if ( options && options.header ) {
				$('div.dtr-modal-content').prepend(
					'<h2>'+options.header( row )+'</h2>'
				);
			}
		};
	}
};


var _childNodeStore = {};

function _childNodes( dt, row, col ) {
	var name = row+'-'+col;

	if ( _childNodeStore[ name ] ) {
		return _childNodeStore[ name ];
	}

	// https://jsperf.com/childnodes-array-slice-vs-loop
	var nodes = [];
	var children = dt.cell( row, col ).node().childNodes;
	for ( var i=0, ien=children.length ; i<ien ; i++ ) {
		nodes.push( children[i] );
	}

	_childNodeStore[ name ] = nodes;

	return nodes;
}

function _childNodesRestore( dt, row, col ) {
	var name = row+'-'+col;

	if ( ! _childNodeStore[ name ] ) {
		return;
	}

	var node = dt.cell( row, col ).node();
	var store = _childNodeStore[ name ];
	var parent = store[0].parentNode;
	var parentChildren = parent.childNodes;
	var a = [];

	for ( var i=0, ien=parentChildren.length ; i<ien ; i++ ) {
		a.push( parentChildren[i] );
	}

	for ( var j=0, jen=a.length ; j<jen ; j++ ) {
		node.appendChild( a[j] );
	}

	_childNodeStore[ name ] = undefined;
}


/**
 * Display methods - functions which define how the hidden data should be shown
 * in the table.
 *
 * @namespace
 * @name Responsive.defaults
 * @static
 */
Responsive.renderer = {
	listHiddenNodes: function () {
		return function ( api, rowIdx, columns ) {
			var ul = $('<ul data-dtr-index="'+rowIdx+'" class="dtr-details"/>');
			var found = false;

			var data = $.each( columns, function ( i, col ) {
				if ( col.hidden ) {
					$(
						'<li data-dtr-index="'+col.columnIndex+'" data-dt-row="'+col.rowIndex+'" data-dt-column="'+col.columnIndex+'">'+
							'<span class="dtr-title">'+
								col.title+
							'</span> '+
						'</li>'
					)
						.append( $('<span class="dtr-data"/>').append( _childNodes( api, col.rowIndex, col.columnIndex ) ) )// api.cell( col.rowIndex, col.columnIndex ).node().childNodes ) )
						.appendTo( ul );

					found = true;
				}
			} );

			return found ?
				ul :
				false;
		};
	},

	listHidden: function () {
		return function ( api, rowIdx, columns ) {
			var data = $.map( columns, function ( col ) {
				return col.hidden ?
					'<li data-dtr-index="'+col.columnIndex+'" data-dt-row="'+col.rowIndex+'" data-dt-column="'+col.columnIndex+'">'+
						'<span class="dtr-title">'+
							col.title+
						'</span> '+
						'<span class="dtr-data">'+
							col.data+
						'</span>'+
					'</li>' :
					'';
			} ).join('');

			return data ?
				$('<ul data-dtr-index="'+rowIdx+'" class="dtr-details"/>').append( data ) :
				false;
		}
	},

	tableAll: function ( options ) {
		options = $.extend( {
			tableClass: ''
		}, options );

		return function ( api, rowIdx, columns ) {
			var data = $.map( columns, function ( col ) {
				return '<tr data-dt-row="'+col.rowIndex+'" data-dt-column="'+col.columnIndex+'">'+
						'<td>'+col.title+':'+'</td> '+
						'<td>'+col.data+'</td>'+
					'</tr>';
			} ).join('');

			return $('<table class="'+options.tableClass+' dtr-details" width="100%"/>').append( data );
		}
	}
};

/**
 * Responsive default settings for initialisation
 *
 * @namespace
 * @name Responsive.defaults
 * @static
 */
Responsive.defaults = {
	/**
	 * List of breakpoints for the instance. Note that this means that each
	 * instance can have its own breakpoints. Additionally, the breakpoints
	 * cannot be changed once an instance has been creased.
	 *
	 * @type {Array}
	 * @default Takes the value of `Responsive.breakpoints`
	 */
	breakpoints: Responsive.breakpoints,

	/**
	 * Enable / disable auto hiding calculations. It can help to increase
	 * performance slightly if you disable this option, but all columns would
	 * need to have breakpoint classes assigned to them
	 *
	 * @type {Boolean}
	 * @default  `true`
	 */
	auto: true,

	/**
	 * Details control. If given as a string value, the `type` property of the
	 * default object is set to that value, and the defaults used for the rest
	 * of the object - this is for ease of implementation.
	 *
	 * The object consists of the following properties:
	 *
	 * * `display` - A function that is used to show and hide the hidden details
	 * * `renderer` - function that is called for display of the child row data.
	 *   The default function will show the data from the hidden columns
	 * * `target` - Used as the selector for what objects to attach the child
	 *   open / close to
	 * * `type` - `false` to disable the details display, `inline` or `column`
	 *   for the two control types
	 *
	 * @type {Object|string}
	 */
	details: {
		display: Responsive.display.childRow,

		renderer: Responsive.renderer.listHidden(),

		target: 0,

		type: 'inline'
	},

	/**
	 * Orthogonal data request option. This is used to define the data type
	 * requested when Responsive gets the data to show in the child row.
	 *
	 * @type {String}
	 */
	orthogonal: 'display'
};


/*
 * API
 */
var Api = $.fn.dataTable.Api;

// Doesn't do anything - work around for a bug in DT... Not documented
Api.register( 'responsive()', function () {
	return this;
} );

Api.register( 'responsive.index()', function ( li ) {
	li = $(li);

	return {
		column: li.data('dtr-index'),
		row:    li.parent().data('dtr-index')
	};
} );

Api.register( 'responsive.rebuild()', function () {
	return this.iterator( 'table', function ( ctx ) {
		if ( ctx._responsive ) {
			ctx._responsive._classLogic();
		}
	} );
} );

Api.register( 'responsive.recalc()', function () {
	return this.iterator( 'table', function ( ctx ) {
		if ( ctx._responsive ) {
			ctx._responsive._resizeAuto();
			ctx._responsive._resize();
		}
	} );
} );

Api.register( 'responsive.hasHidden()', function () {
	var ctx = this.context[0];

	return ctx._responsive ?
		$.inArray( false, ctx._responsive.s.current ) !== -1 :
		false;
} );

Api.registerPlural( 'columns().responsiveHidden()', 'column().responsiveHidden()', function () {
	return this.iterator( 'column', function ( settings, column ) {
		return settings._responsive ?
			settings._responsive.s.current[ column ] :
			false;
	}, 1 );
} );


/**
 * Version information
 *
 * @name Responsive.version
 * @static
 */
Responsive.version = '2.2.3';


$.fn.dataTable.Responsive = Responsive;
$.fn.DataTable.Responsive = Responsive;

// Attach a listener to the document which listens for DataTables initialisation
// events so we can automatically initialise
$(document).on( 'preInit.dt.dtr', function (e, settings, json) {
	if ( e.namespace !== 'dt' ) {
		return;
	}

	if ( $(settings.nTable).hasClass( 'responsive' ) ||
		 $(settings.nTable).hasClass( 'dt-responsive' ) ||
		 settings.oInit.responsive ||
		 DataTable.defaults.responsive
	) {
		var init = settings.oInit.responsive;

		if ( init !== false ) {
			new Responsive( settings, $.isPlainObject( init ) ? init : {}  );
		}
	}
} );


return Responsive;
}));


/*! RowGroup 1.1.1
 * 2017-2019 SpryMedia Ltd - datatables.net/license
 */

/**
 * @summary     RowGroup
 * @description RowGrouping for DataTables
 * @version     1.1.1
 * @file        dataTables.rowGroup.js
 * @author      SpryMedia Ltd (www.sprymedia.co.uk)
 * @contact     datatables.net
 * @copyright   Copyright 2017-2019 SpryMedia Ltd.
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license/mit
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */

(function( factory ){
	if ( typeof define === 'function' && define.amd ) {
		// AMD
		define( ['jquery', 'datatables.net'], function ( $ ) {
			return factory( $, window, document );
		} );
	}
	else if ( typeof exports === 'object' ) {
		// CommonJS
		module.exports = function (root, $) {
			if ( ! root ) {
				root = window;
			}

			if ( ! $ || ! $.fn.dataTable ) {
				$ = require('datatables.net')(root, $).$;
			}

			return factory( $, root, root.document );
		};
	}
	else {
		// Browser
		factory( jQuery, window, document );
	}
}(function( $, window, document, undefined ) {
'use strict';
var DataTable = $.fn.dataTable;


var RowGroup = function ( dt, opts ) {
	// Sanity check that we are using DataTables 1.10 or newer
	if ( ! DataTable.versionCheck || ! DataTable.versionCheck( '1.10.8' ) ) {
		throw 'RowGroup requires DataTables 1.10.8 or newer';
	}

	// User and defaults configuration object
	this.c = $.extend( true, {},
		DataTable.defaults.rowGroup,
		RowGroup.defaults,
		opts
	);

	// Internal settings
	this.s = {
		dt: new DataTable.Api( dt )
	};

	// DOM items
	this.dom = {

	};

	// Check if row grouping has already been initialised on this table
	var settings = this.s.dt.settings()[0];
	var existing = settings.rowGroup;
	if ( existing ) {
		return existing;
	}

	settings.rowGroup = this;
	this._constructor();
};


$.extend( RowGroup.prototype, {
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * API methods for DataTables API interface
	 */

	/**
	 * Get/set the grouping data source - need to call draw after this is
	 * executed as a setter
	 * @returns string~RowGroup
	 */
	dataSrc: function ( val )
	{
		if ( val === undefined ) {
			return this.c.dataSrc;
		}

		var dt = this.s.dt;

		this.c.dataSrc = val;

		$(dt.table().node()).triggerHandler( 'rowgroup-datasrc.dt', [ dt, val ] );

		return this;
	},

	/**
	 * Disable - need to call draw after this is executed
	 * @returns RowGroup
	 */
	disable: function ()
	{
		this.c.enable = false;
		return this;
	},

	/**
	 * Enable - need to call draw after this is executed
	 * @returns RowGroup
	 */
	enable: function ( flag )
	{
		if ( flag === false ) {
			return this.disable();
		}

		this.c.enable = true;
		return this;
	},


	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Constructor
	 */
	_constructor: function ()
	{
		var that = this;
		var dt = this.s.dt;

		dt.on( 'draw.dtrg', function () {
			if ( that.c.enable ) {
				that._draw();
			}
		} );

		dt.on( 'column-visibility.dt.dtrg responsive-resize.dt.dtrg', function () {
			that._adjustColspan();
		} );

		dt.on( 'destroy', function () {
			dt.off( '.dtrg' );
		} );

		dt.on('responsive-resize.dt', function () {
			that._adjustColspan();
		})
	},


	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Private methods
	 */

	/**
	 * Adjust column span when column visibility changes
	 * @private
	 */
	_adjustColspan: function ()
	{
		$( 'tr.'+this.c.className, this.s.dt.table().body() ).find('td')
			.attr( 'colspan', this._colspan() );
	},

	/**
	 * Get the number of columns that a grouping row should span
	 * @private
	 */
	_colspan: function ()
	{
		return this.s.dt.columns().visible().reduce( function (a, b) {
			return a + b;
		}, 0 );
	},


	/**
	 * Update function that is called whenever we need to draw the grouping rows.
	 * This is basically a bootstrap for the self iterative _group and _groupDisplay
	 * methods
	 * @private
	 */
	_draw: function ()
	{
		var dt = this.s.dt;
		var groupedRows = this._group( 0, dt.rows( { page: 'current' } ).indexes() );

		this._groupDisplay( 0, groupedRows );
	},

	/**
	 * Get the grouping information from a data set (index) of rows
	 * @param {number} level Nesting level
	 * @param {DataTables.Api} rows API of the rows to consider for this group
	 * @returns {object[]} Nested grouping information - it is structured like this:
	 *	{
	 *		dataPoint: 'Edinburgh',
	 *		rows: [ 1,2,3,4,5,6,7 ],
	 *		children: [ {
	 *			dataPoint: 'developer'
	 *			rows: [ 1, 2, 3 ]
	 *		},
	 *		{
	 *			dataPoint: 'support',
	 *			rows: [ 4, 5, 6, 7 ]
	 *		} ]
	 *	}
	 * @private
	 */
	_group: function ( level, rows ) {
		var fns = $.isArray( this.c.dataSrc ) ? this.c.dataSrc : [ this.c.dataSrc ];
		var fn = DataTable.ext.oApi._fnGetObjectDataFn( fns[ level ] );
		var dt = this.s.dt;
		var group, last;
		var data = [];
		var that = this;

		for ( var i=0, ien=rows.length ; i<ien ; i++ ) {
			var rowIndex = rows[i];
			var rowData = dt.row( rowIndex ).data();
			var group = fn( rowData );

			if ( group === null || group === undefined ) {
				group = that.c.emptyDataGroup;
			}
			
			if ( last === undefined || group !== last ) {
				data.push( {
					dataPoint: group,
					rows: []
				} );

				last = group;
			}

			data[ data.length-1 ].rows.push( rowIndex );
		}

		if ( fns[ level+1 ] !== undefined ) {
			for ( var i=0, ien=data.length ; i<ien ; i++ ) {
				data[i].children = this._group( level+1, data[i].rows );
			}
		}

		return data;
	},

	/**
	 * Row group display - insert the rows into the document
	 * @param {number} level Nesting level
	 * @param {object[]} groups Takes the nested array from `_group`
	 * @private
	 */
	_groupDisplay: function ( level, groups )
	{
		var dt = this.s.dt;
		var display;
	
		for ( var i=0, ien=groups.length ; i<ien ; i++ ) {
			var group = groups[i];
			var groupName = group.dataPoint;
			var row;
			var rows = group.rows;

			if ( this.c.startRender ) {
				display = this.c.startRender.call( this, dt.rows(rows), groupName, level );
				row = this._rowWrap( display, this.c.startClassName, level );

				if ( row ) {
					row.insertBefore( dt.row( rows[0] ).node() );
				}
			}

			if ( this.c.endRender ) {
				display = this.c.endRender.call( this, dt.rows(rows), groupName, level );
				row = this._rowWrap( display, this.c.endClassName, level );

				if ( row ) {
					row.insertAfter( dt.row( rows[ rows.length-1 ] ).node() );
				}
			}

			if ( group.children ) {
				this._groupDisplay( level+1, group.children );
			}
		}
	},

	/**
	 * Take a rendered value from an end user and make it suitable for display
	 * as a row, by wrapping it in a row, or detecting that it is a row.
	 * @param {node|jQuery|string} display Display value
	 * @param {string} className Class to add to the row
	 * @param {array} group
	 * @param {number} group level
	 * @private
	 */
	_rowWrap: function ( display, className, level )
	{
		var row;
		
		if ( display === null || display === '' ) {
			display = this.c.emptyDataGroup;
		}

		if ( display === undefined || display === null ) {
			return null;
		}
		
		if ( typeof display === 'object' && display.nodeName && display.nodeName.toLowerCase() === 'tr') {
			row = $(display);
		}
		else if (display instanceof $ && display.length && display[0].nodeName.toLowerCase() === 'tr') {
			row = display;
		}
		else {
			row = $('<tr/>')
				.append(
					$('<td/>')
						.attr( 'colspan', this._colspan() )
						.append( display  )
				);
		}

		return row
			.addClass( this.c.className )
			.addClass( className )
			.addClass( 'dtrg-level-'+level );
	}
} );


/**
 * RowGroup default settings for initialisation
 *
 * @namespace
 * @name RowGroup.defaults
 * @static
 */
RowGroup.defaults = {
	/**
	 * Class to apply to grouping rows - applied to both the start and
	 * end grouping rows.
	 * @type string
	 */
	className: 'dtrg-group',

	/**
	 * Data property from which to read the grouping information
	 * @type string|integer|array
	 */
	dataSrc: 0,

	/**
	 * Text to show if no data is found for a group
	 * @type string
	 */
	emptyDataGroup: 'No group',

	/**
	 * Initial enablement state
	 * @boolean
	 */
	enable: true,

	/**
	 * Class name to give to the end grouping row
	 * @type string
	 */
	endClassName: 'dtrg-end',

	/**
	 * End grouping label function
	 * @function
	 */
	endRender: null,

	/**
	 * Class name to give to the start grouping row
	 * @type string
	 */
	startClassName: 'dtrg-start',

	/**
	 * Start grouping label function
	 * @function
	 */
	startRender: function ( rows, group ) {
		return group;
	}
};


RowGroup.version = "1.1.1";


$.fn.dataTable.RowGroup = RowGroup;
$.fn.DataTable.RowGroup = RowGroup;


DataTable.Api.register( 'rowGroup()', function () {
	return this;
} );

DataTable.Api.register( 'rowGroup().disable()', function () {
	return this.iterator( 'table', function (ctx) {
		if ( ctx.rowGroup ) {
			ctx.rowGroup.enable( false );
		}
	} );
} );

DataTable.Api.register( 'rowGroup().enable()', function ( opts ) {
	return this.iterator( 'table', function (ctx) {
		if ( ctx.rowGroup ) {
			ctx.rowGroup.enable( opts === undefined ? true : opts );
		}
	} );
} );

DataTable.Api.register( 'rowGroup().dataSrc()', function ( val ) {
	if ( val === undefined ) {
		return this.context[0].rowGroup.dataSrc();
	}

	return this.iterator( 'table', function (ctx) {
		if ( ctx.rowGroup ) {
			ctx.rowGroup.dataSrc( val );
		}
	} );
} );


// Attach a listener to the document which listens for DataTables initialisation
// events so we can automatically initialise
$(document).on( 'preInit.dt.dtrg', function (e, settings, json) {
	if ( e.namespace !== 'dt' ) {
		return;
	}

	var init = settings.oInit.rowGroup;
	var defaults = DataTable.defaults.rowGroup;

	if ( init || defaults ) {
		var opts = $.extend( {}, defaults, init );

		if ( init !== false ) {
			new RowGroup( settings, opts  );
		}
	}
} );


return RowGroup;

}));


/*! RowReorder 1.2.6
 * 2015-2019 SpryMedia Ltd - datatables.net/license
 */

/**
 * @summary     RowReorder
 * @description Row reordering extension for DataTables
 * @version     1.2.6
 * @file        dataTables.rowReorder.js
 * @author      SpryMedia Ltd (www.sprymedia.co.uk)
 * @contact     www.sprymedia.co.uk/contact
 * @copyright   Copyright 2015-2019 SpryMedia Ltd.
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license/mit
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */

(function( factory ){
	if ( typeof define === 'function' && define.amd ) {
		// AMD
		define( ['jquery', 'datatables.net'], function ( $ ) {
			return factory( $, window, document );
		} );
	}
	else if ( typeof exports === 'object' ) {
		// CommonJS
		module.exports = function (root, $) {
			if ( ! root ) {
				root = window;
			}

			if ( ! $ || ! $.fn.dataTable ) {
				$ = require('datatables.net')(root, $).$;
			}

			return factory( $, root, root.document );
		};
	}
	else {
		// Browser
		factory( jQuery, window, document );
	}
}(function( $, window, document, undefined ) {
'use strict';
var DataTable = $.fn.dataTable;


/**
 * RowReorder provides the ability in DataTables to click and drag rows to
 * reorder them. When a row is dropped the data for the rows effected will be
 * updated to reflect the change. Normally this data point should also be the
 * column being sorted upon in the DataTable but this does not need to be the
 * case. RowReorder implements a "data swap" method - so the rows being
 * reordered take the value of the data point from the row that used to occupy
 * the row's new position.
 *
 * Initialisation is done by either:
 *
 * * `rowReorder` parameter in the DataTable initialisation object
 * * `new $.fn.dataTable.RowReorder( table, opts )` after DataTables
 *   initialisation.
 * 
 *  @class
 *  @param {object} settings DataTables settings object for the host table
 *  @param {object} [opts] Configuration options
 *  @requires jQuery 1.7+
 *  @requires DataTables 1.10.7+
 */
var RowReorder = function ( dt, opts ) {
	// Sanity check that we are using DataTables 1.10 or newer
	if ( ! DataTable.versionCheck || ! DataTable.versionCheck( '1.10.8' ) ) {
		throw 'DataTables RowReorder requires DataTables 1.10.8 or newer';
	}

	// User and defaults configuration object
	this.c = $.extend( true, {},
		DataTable.defaults.rowReorder,
		RowReorder.defaults,
		opts
	);

	// Internal settings
	this.s = {
		/** @type {integer} Scroll body top cache */
		bodyTop: null,

		/** @type {DataTable.Api} DataTables' API instance */
		dt: new DataTable.Api( dt ),

		/** @type {function} Data fetch function */
		getDataFn: DataTable.ext.oApi._fnGetObjectDataFn( this.c.dataSrc ),

		/** @type {array} Pixel positions for row insertion calculation */
		middles: null,

		/** @type {Object} Cached dimension information for use in the mouse move event handler */
		scroll: {},

		/** @type {integer} Interval object used for smooth scrolling */
		scrollInterval: null,

		/** @type {function} Data set function */
		setDataFn: DataTable.ext.oApi._fnSetObjectDataFn( this.c.dataSrc ),

		/** @type {Object} Mouse down information */
		start: {
			top: 0,
			left: 0,
			offsetTop: 0,
			offsetLeft: 0,
			nodes: []
		},

		/** @type {integer} Window height cached value */
		windowHeight: 0,

		/** @type {integer} Document outer height cached value */
		documentOuterHeight: 0,

		/** @type {integer} DOM clone outer height cached value */
		domCloneOuterHeight: 0
	};

	// DOM items
	this.dom = {
		/** @type {jQuery} Cloned row being moved around */
		clone: null,

		/** @type {jQuery} DataTables scrolling container */
		dtScroll: $('div.dataTables_scrollBody', this.s.dt.table().container())
	};

	// Check if row reorder has already been initialised on this table
	var settings = this.s.dt.settings()[0];
	var exisiting = settings.rowreorder;
	if ( exisiting ) {
		return exisiting;
	}

	settings.rowreorder = this;
	this._constructor();
};


$.extend( RowReorder.prototype, {
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Constructor
	 */

	/**
	 * Initialise the RowReorder instance
	 *
	 * @private
	 */
	_constructor: function ()
	{
		var that = this;
		var dt = this.s.dt;
		var table = $( dt.table().node() );

		// Need to be able to calculate the row positions relative to the table
		if ( table.css('position') === 'static' ) {
			table.css( 'position', 'relative' );
		}

		// listen for mouse down on the target column - we have to implement
		// this rather than using HTML5 drag and drop as drag and drop doesn't
		// appear to work on table rows at this time. Also mobile browsers are
		// not supported.
		// Use `table().container()` rather than just the table node for IE8 -
		// otherwise it only works once...
		$(dt.table().container()).on( 'mousedown.rowReorder touchstart.rowReorder', this.c.selector, function (e) {
			if ( ! that.c.enable ) {
				return;
			}

			// Ignore excluded children of the selector
			if ( $(e.target).is(that.c.excludedChildren) ) {
				return true;
			}

			var tr = $(this).closest('tr');
			var row = dt.row( tr );

			// Double check that it is a DataTable row
			if ( row.any() ) {
				that._emitEvent( 'pre-row-reorder', {
					node: row.node(),
					index: row.index()
				} );

				that._mouseDown( e, tr );
				return false;
			}
		} );

		dt.on( 'destroy.rowReorder', function () {
			$(dt.table().container()).off( '.rowReorder' );
			dt.off( '.rowReorder' );
		} );
	},


	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Private methods
	 */
	
	/**
	 * Cache the measurements that RowReorder needs in the mouse move handler
	 * to attempt to speed things up, rather than reading from the DOM.
	 *
	 * @private
	 */
	_cachePositions: function ()
	{
		var dt = this.s.dt;

		// Frustratingly, if we add `position:relative` to the tbody, the
		// position is still relatively to the parent. So we need to adjust
		// for that
		var headerHeight = $( dt.table().node() ).find('thead').outerHeight();

		// Need to pass the nodes through jQuery to get them in document order,
		// not what DataTables thinks it is, since we have been altering the
		// order
		var nodes = $.unique( dt.rows( { page: 'current' } ).nodes().toArray() );
		var tops = $.map( nodes, function ( node, i ) {
			return $(node).position().top - headerHeight;
		} );

		var middles = $.map( tops, function ( top, i ) {
			return tops.length < i-1 ?
				(top + tops[i+1]) / 2 :
				(top + top + $( dt.row( ':last-child' ).node() ).outerHeight() ) / 2;
		} );

		this.s.middles = middles;
		this.s.bodyTop = $( dt.table().body() ).offset().top;
		this.s.windowHeight = $(window).height();
		this.s.documentOuterHeight = $(document).outerHeight();
	},


	/**
	 * Clone a row so it can be floated around the screen
	 *
	 * @param  {jQuery} target Node to be cloned
	 * @private
	 */
	_clone: function ( target )
	{
		var dt = this.s.dt;
		var clone = $( dt.table().node().cloneNode(false) )
			.addClass( 'dt-rowReorder-float' )
			.append('<tbody/>')
			.append( target.clone( false ) );

		// Match the table and column widths - read all sizes before setting
		// to reduce reflows
		var tableWidth = target.outerWidth();
		var tableHeight = target.outerHeight();
		var sizes = target.children().map( function () {
			return $(this).width();
		} );

		clone
			.width( tableWidth )
			.height( tableHeight )
			.find('tr').children().each( function (i) {
				this.style.width = sizes[i]+'px';
			} );

		// Insert into the document to have it floating around
		clone.appendTo( 'body' );

		this.dom.clone = clone;
		this.s.domCloneOuterHeight = clone.outerHeight();
	},


	/**
	 * Update the cloned item's position in the document
	 *
	 * @param  {object} e Event giving the mouse's position
	 * @private
	 */
	_clonePosition: function ( e )
	{
		var start = this.s.start;
		var topDiff = this._eventToPage( e, 'Y' ) - start.top;
		var leftDiff = this._eventToPage( e, 'X' ) - start.left;
		var snap = this.c.snapX;
		var left;
		var top = topDiff + start.offsetTop;

		if ( snap === true ) {
			left = start.offsetLeft;
		}
		else if ( typeof snap === 'number' ) {
			left = start.offsetLeft + snap;
		}
		else {
			left = leftDiff + start.offsetLeft;
		}

		if(top < 0) {
			top = 0
		}
		else if(top + this.s.domCloneOuterHeight > this.s.documentOuterHeight) {
			top = this.s.documentOuterHeight - this.s.domCloneOuterHeight;
		}

		this.dom.clone.css( {
			top: top,
			left: left
		} );
	},


	/**
	 * Emit an event on the DataTable for listeners
	 *
	 * @param  {string} name Event name
	 * @param  {array} args Event arguments
	 * @private
	 */
	_emitEvent: function ( name, args )
	{
		this.s.dt.iterator( 'table', function ( ctx, i ) {
			$(ctx.nTable).triggerHandler( name+'.dt', args );
		} );
	},


	/**
	 * Get pageX/Y position from an event, regardless of if it is a mouse or
	 * touch event.
	 *
	 * @param  {object} e Event
	 * @param  {string} pos X or Y (must be a capital)
	 * @private
	 */
	_eventToPage: function ( e, pos )
	{
		if ( e.type.indexOf( 'touch' ) !== -1 ) {
			return e.originalEvent.touches[0][ 'page'+pos ];
		}

		return e[ 'page'+pos ];
	},


	/**
	 * Mouse down event handler. Read initial positions and add event handlers
	 * for the move.
	 *
	 * @param  {object} e      Mouse event
	 * @param  {jQuery} target TR element that is to be moved
	 * @private
	 */
	_mouseDown: function ( e, target )
	{
		var that = this;
		var dt = this.s.dt;
		var start = this.s.start;

		var offset = target.offset();
		start.top = this._eventToPage( e, 'Y' );
		start.left = this._eventToPage( e, 'X' );
		start.offsetTop = offset.top;
		start.offsetLeft = offset.left;
		start.nodes = $.unique( dt.rows( { page: 'current' } ).nodes().toArray() );

		this._cachePositions();
		this._clone( target );
		this._clonePosition( e );

		this.dom.target = target;
		target.addClass( 'dt-rowReorder-moving' );

		$( document )
			.on( 'mouseup.rowReorder touchend.rowReorder', function (e) {
				that._mouseUp(e);
			} )
			.on( 'mousemove.rowReorder touchmove.rowReorder', function (e) {
				that._mouseMove(e);
			} );

		// Check if window is x-scrolling - if not, disable it for the duration
		// of the drag
		if ( $(window).width() === $(document).width() ) {
			$(document.body).addClass( 'dt-rowReorder-noOverflow' );
		}

		// Cache scrolling information so mouse move doesn't need to read.
		// This assumes that the window and DT scroller will not change size
		// during an row drag, which I think is a fair assumption
		var scrollWrapper = this.dom.dtScroll;
		this.s.scroll = {
			windowHeight: $(window).height(),
			windowWidth:  $(window).width(),
			dtTop:        scrollWrapper.length ? scrollWrapper.offset().top : null,
			dtLeft:       scrollWrapper.length ? scrollWrapper.offset().left : null,
			dtHeight:     scrollWrapper.length ? scrollWrapper.outerHeight() : null,
			dtWidth:      scrollWrapper.length ? scrollWrapper.outerWidth() : null
		};
	},


	/**
	 * Mouse move event handler - move the cloned row and shuffle the table's
	 * rows if required.
	 *
	 * @param  {object} e Mouse event
	 * @private
	 */
	_mouseMove: function ( e )
	{
		this._clonePosition( e );

		// Transform the mouse position into a position in the table's body
		var bodyY = this._eventToPage( e, 'Y' ) - this.s.bodyTop;
		var middles = this.s.middles;
		var insertPoint = null;
		var dt = this.s.dt;
		var body = dt.table().body();

		// Determine where the row should be inserted based on the mouse
		// position
		for ( var i=0, ien=middles.length ; i<ien ; i++ ) {
			if ( bodyY < middles[i] ) {
				insertPoint = i;
				break;
			}
		}

		if ( insertPoint === null ) {
			insertPoint = middles.length;
		}

		// Perform the DOM shuffle if it has changed from last time
		if ( this.s.lastInsert === null || this.s.lastInsert !== insertPoint ) {
			if ( insertPoint === 0 ) {
				this.dom.target.prependTo( body );
			}
			else {
				var nodes = $.unique( dt.rows( { page: 'current' } ).nodes().toArray() );

				if ( insertPoint > this.s.lastInsert ) {
					this.dom.target.insertAfter( nodes[ insertPoint-1 ] );
				}
				else {
					this.dom.target.insertBefore( nodes[ insertPoint ] );
				}
			}

			this._cachePositions();

			this.s.lastInsert = insertPoint;
		}

		this._shiftScroll( e );
	},


	/**
	 * Mouse up event handler - release the event handlers and perform the
	 * table updates
	 *
	 * @param  {object} e Mouse event
	 * @private
	 */
	_mouseUp: function ( e )
	{
		var that = this;
		var dt = this.s.dt;
		var i, ien;
		var dataSrc = this.c.dataSrc;

		this.dom.clone.remove();
		this.dom.clone = null;

		this.dom.target.removeClass( 'dt-rowReorder-moving' );
		//this.dom.target = null;

		$(document).off( '.rowReorder' );
		$(document.body).removeClass( 'dt-rowReorder-noOverflow' );

		clearInterval( this.s.scrollInterval );
		this.s.scrollInterval = null;

		// Calculate the difference
		var startNodes = this.s.start.nodes;
		var endNodes = $.unique( dt.rows( { page: 'current' } ).nodes().toArray() );
		var idDiff = {};
		var fullDiff = [];
		var diffNodes = [];
		var getDataFn = this.s.getDataFn;
		var setDataFn = this.s.setDataFn;

		for ( i=0, ien=startNodes.length ; i<ien ; i++ ) {
			if ( startNodes[i] !== endNodes[i] ) {
				var id = dt.row( endNodes[i] ).id();
				var endRowData = dt.row( endNodes[i] ).data();
				var startRowData = dt.row( startNodes[i] ).data();

				if ( id ) {
					idDiff[ id ] = getDataFn( startRowData );
				}

				fullDiff.push( {
					node: endNodes[i],
					oldData: getDataFn( endRowData ),
					newData: getDataFn( startRowData ),
					newPosition: i,
					oldPosition: $.inArray( endNodes[i], startNodes )
				} );

				diffNodes.push( endNodes[i] );
			}
		}
		
		// Create event args
		var eventArgs = [ fullDiff, {
			dataSrc:       dataSrc,
			nodes:         diffNodes,
			values:        idDiff,
			triggerRow:    dt.row( this.dom.target ),
			originalEvent: e
		} ];
		
		// Emit event
		this._emitEvent( 'row-reorder', eventArgs );

		var update = function () {
			if ( that.c.update ) {
				for ( i=0, ien=fullDiff.length ; i<ien ; i++ ) {
					var row = dt.row( fullDiff[i].node );
					var rowData = row.data();

					setDataFn( rowData, fullDiff[i].newData );

					// Invalidate the cell that has the same data source as the dataSrc
					dt.columns().every( function () {
						if ( this.dataSrc() === dataSrc ) {
							dt.cell( fullDiff[i].node, this.index() ).invalidate( 'data' );
						}
					} );
				}

				// Trigger row reordered event
				that._emitEvent( 'row-reordered', eventArgs );

				dt.draw( false );
			}
		};

		// Editor interface
		if ( this.c.editor ) {
			// Disable user interaction while Editor is submitting
			this.c.enable = false;

			this.c.editor
				.edit(
					diffNodes,
					false,
					$.extend( {submit: 'changed'}, this.c.formOptions )
				)
				.multiSet( dataSrc, idDiff )
				.one( 'preSubmitCancelled.rowReorder', function () {
					that.c.enable = true;
					that.c.editor.off( '.rowReorder' );
					dt.draw( false );
				} )
				.one( 'submitUnsuccessful.rowReorder', function () {
					dt.draw( false );
				} )
				.one( 'submitSuccess.rowReorder', function () {
					update();
				} )
				.one( 'submitComplete', function () {
					that.c.enable = true;
					that.c.editor.off( '.rowReorder' );
				} )
				.submit();
		}
		else {
			update();
		}
	},


	/**
	 * Move the window and DataTables scrolling during a drag to scroll new
	 * content into view.
	 *
	 * This matches the `_shiftScroll` method used in AutoFill, but only
	 * horizontal scrolling is considered here.
	 *
	 * @param  {object} e Mouse move event object
	 * @private
	 */
	_shiftScroll: function ( e )
	{
		var that = this;
		var dt = this.s.dt;
		var scroll = this.s.scroll;
		var runInterval = false;
		var scrollSpeed = 5;
		var buffer = 65;
		var
			windowY = e.pageY - document.body.scrollTop,
			windowVert,
			dtVert;

		// Window calculations - based on the mouse position in the window,
		// regardless of scrolling
		if ( windowY < buffer ) {
			windowVert = scrollSpeed * -1;
		}
		else if ( windowY > scroll.windowHeight - buffer ) {
			windowVert = scrollSpeed;
		}

		// DataTables scrolling calculations - based on the table's position in
		// the document and the mouse position on the page
		if ( scroll.dtTop !== null && e.pageY < scroll.dtTop + buffer ) {
			dtVert = scrollSpeed * -1;
		}
		else if ( scroll.dtTop !== null && e.pageY > scroll.dtTop + scroll.dtHeight - buffer ) {
			dtVert = scrollSpeed;
		}

		// This is where it gets interesting. We want to continue scrolling
		// without requiring a mouse move, so we need an interval to be
		// triggered. The interval should continue until it is no longer needed,
		// but it must also use the latest scroll commands (for example consider
		// that the mouse might move from scrolling up to scrolling left, all
		// with the same interval running. We use the `scroll` object to "pass"
		// this information to the interval. Can't use local variables as they
		// wouldn't be the ones that are used by an already existing interval!
		if ( windowVert || dtVert ) {
			scroll.windowVert = windowVert;
			scroll.dtVert = dtVert;
			runInterval = true;
		}
		else if ( this.s.scrollInterval ) {
			// Don't need to scroll - remove any existing timer
			clearInterval( this.s.scrollInterval );
			this.s.scrollInterval = null;
		}

		// If we need to run the interval to scroll and there is no existing
		// interval (if there is an existing one, it will continue to run)
		if ( ! this.s.scrollInterval && runInterval ) {
			this.s.scrollInterval = setInterval( function () {
				// Don't need to worry about setting scroll <0 or beyond the
				// scroll bound as the browser will just reject that.
				if ( scroll.windowVert ) {
					document.body.scrollTop += scroll.windowVert;
				}

				// DataTables scrolling
				if ( scroll.dtVert ) {
					var scroller = that.dom.dtScroll[0];

					if ( scroll.dtVert ) {
						scroller.scrollTop += scroll.dtVert;
					}
				}
			}, 20 );
		}
	}
} );



/**
 * RowReorder default settings for initialisation
 *
 * @namespace
 * @name RowReorder.defaults
 * @static
 */
RowReorder.defaults = {
	/**
	 * Data point in the host row's data source object for where to get and set
	 * the data to reorder. This will normally also be the sorting column.
	 *
	 * @type {Number}
	 */
	dataSrc: 0,

	/**
	 * Editor instance that will be used to perform the update
	 *
	 * @type {DataTable.Editor}
	 */
	editor: null,

	/**
	 * Enable / disable RowReorder's user interaction
	 * @type {Boolean}
	 */
	enable: true,

	/**
	 * Form options to pass to Editor when submitting a change in the row order.
	 * See the Editor `from-options` object for details of the options
	 * available.
	 * @type {Object}
	 */
	formOptions: {},

	/**
	 * Drag handle selector. This defines the element that when dragged will
	 * reorder a row.
	 *
	 * @type {String}
	 */
	selector: 'td:first-child',

	/**
	 * Optionally lock the dragged row's x-position. This can be `true` to
	 * fix the position match the host table's, `false` to allow free movement
	 * of the row, or a number to define an offset from the host table.
	 *
	 * @type {Boolean|number}
	 */
	snapX: false,

	/**
	 * Update the table's data on drop
	 *
	 * @type {Boolean}
	 */
	update: true,

	/**
	 * Selector for children of the drag handle selector that mouseDown events
	 * will be passed through to and drag will not activate
	 *
	 * @type {String}
	 */
	excludedChildren: 'a'
};


/*
 * API
 */
var Api = $.fn.dataTable.Api;

// Doesn't do anything - work around for a bug in DT... Not documented
Api.register( 'rowReorder()', function () {
	return this;
} );

Api.register( 'rowReorder.enable()', function ( toggle ) {
	if ( toggle === undefined ) {
		toggle = true;
	}

	return this.iterator( 'table', function ( ctx ) {
		if ( ctx.rowreorder ) {
			ctx.rowreorder.c.enable = toggle;
		}
	} );
} );

Api.register( 'rowReorder.disable()', function () {
	return this.iterator( 'table', function ( ctx ) {
		if ( ctx.rowreorder ) {
			ctx.rowreorder.c.enable = false;
		}
	} );
} );


/**
 * Version information
 *
 * @name RowReorder.version
 * @static
 */
RowReorder.version = '1.2.6';


$.fn.dataTable.RowReorder = RowReorder;
$.fn.DataTable.RowReorder = RowReorder;

// Attach a listener to the document which listens for DataTables initialisation
// events so we can automatically initialise
$(document).on( 'init.dt.dtr', function (e, settings, json) {
	if ( e.namespace !== 'dt' ) {
		return;
	}

	var init = settings.oInit.rowReorder;
	var defaults = DataTable.defaults.rowReorder;

	if ( init || defaults ) {
		var opts = $.extend( {}, init, defaults );

		if ( init !== false ) {
			new RowReorder( settings, opts  );
		}
	}
} );


return RowReorder;
}));


/*! Scroller 2.0.1
 * 2011-2019 SpryMedia Ltd - datatables.net/license
 */

/**
 * @summary     Scroller
 * @description Virtual rendering for DataTables
 * @version     2.0.1
 * @file        dataTables.scroller.js
 * @author      SpryMedia Ltd (www.sprymedia.co.uk)
 * @contact     www.sprymedia.co.uk/contact
 * @copyright   Copyright 2011-2019 SpryMedia Ltd.
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license/mit
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */

(function( factory ){
	if ( typeof define === 'function' && define.amd ) {
		// AMD
		define( ['jquery', 'datatables.net'], function ( $ ) {
			return factory( $, window, document );
		} );
	}
	else if ( typeof exports === 'object' ) {
		// CommonJS
		module.exports = function (root, $) {
			if ( ! root ) {
				root = window;
			}

			if ( ! $ || ! $.fn.dataTable ) {
				$ = require('datatables.net')(root, $).$;
			}

			return factory( $, root, root.document );
		};
	}
	else {
		// Browser
		factory( jQuery, window, document );
	}
}(function( $, window, document, undefined ) {
'use strict';
var DataTable = $.fn.dataTable;


/**
 * Scroller is a virtual rendering plug-in for DataTables which allows large
 * datasets to be drawn on screen every quickly. What the virtual rendering means
 * is that only the visible portion of the table (and a bit to either side to make
 * the scrolling smooth) is drawn, while the scrolling container gives the
 * visual impression that the whole table is visible. This is done by making use
 * of the pagination abilities of DataTables and moving the table around in the
 * scrolling container DataTables adds to the page. The scrolling container is
 * forced to the height it would be for the full table display using an extra
 * element.
 *
 * Note that rows in the table MUST all be the same height. Information in a cell
 * which expands on to multiple lines will cause some odd behaviour in the scrolling.
 *
 * Scroller is initialised by simply including the letter 'S' in the sDom for the
 * table you want to have this feature enabled on. Note that the 'S' must come
 * AFTER the 't' parameter in `dom`.
 *
 * Key features include:
 *   <ul class="limit_length">
 *     <li>Speed! The aim of Scroller for DataTables is to make rendering large data sets fast</li>
 *     <li>Full compatibility with deferred rendering in DataTables for maximum speed</li>
 *     <li>Display millions of rows</li>
 *     <li>Integration with state saving in DataTables (scrolling position is saved)</li>
 *     <li>Easy to use</li>
 *   </ul>
 *
 *  @class
 *  @constructor
 *  @global
 *  @param {object} dt DataTables settings object or API instance
 *  @param {object} [opts={}] Configuration object for FixedColumns. Options 
 *    are defined by {@link Scroller.defaults}
 *
 *  @requires jQuery 1.7+
 *  @requires DataTables 1.10.0+
 *
 *  @example
 *    $(document).ready(function() {
 *        $('#example').DataTable( {
 *            "scrollY": "200px",
 *            "ajax": "media/dataset/large.txt",
 *            "scroller": true,
 *            "deferRender": true
 *        } );
 *    } );
 */
var Scroller = function ( dt, opts ) {
	/* Sanity check - you just know it will happen */
	if ( ! (this instanceof Scroller) ) {
		alert( "Scroller warning: Scroller must be initialised with the 'new' keyword." );
		return;
	}

	if ( opts === undefined ) {
		opts = {};
	}

	var dtApi = $.fn.dataTable.Api( dt );

	/**
	 * Settings object which contains customisable information for the Scroller instance
	 * @namespace
	 * @private
	 * @extends Scroller.defaults
	 */
	this.s = {
		/**
		 * DataTables settings object
		 *  @type     object
		 *  @default  Passed in as first parameter to constructor
		 */
		dt: dtApi.settings()[0],

		/**
		 * DataTables API instance
		 *  @type     DataTable.Api
		 */
		dtApi: dtApi,

		/**
		 * Pixel location of the top of the drawn table in the viewport
		 *  @type     int
		 *  @default  0
		 */
		tableTop: 0,

		/**
		 * Pixel location of the bottom of the drawn table in the viewport
		 *  @type     int
		 *  @default  0
		 */
		tableBottom: 0,

		/**
		 * Pixel location of the boundary for when the next data set should be loaded and drawn
		 * when scrolling up the way.
		 *  @type     int
		 *  @default  0
		 *  @private
		 */
		redrawTop: 0,

		/**
		 * Pixel location of the boundary for when the next data set should be loaded and drawn
		 * when scrolling down the way. Note that this is actually calculated as the offset from
		 * the top.
		 *  @type     int
		 *  @default  0
		 *  @private
		 */
		redrawBottom: 0,

		/**
		 * Auto row height or not indicator
		 *  @type     bool
		 *  @default  0
		 */
		autoHeight: true,

		/**
		 * Number of rows calculated as visible in the visible viewport
		 *  @type     int
		 *  @default  0
		 */
		viewportRows: 0,

		/**
		 * setTimeout reference for state saving, used when state saving is enabled in the DataTable
		 * and when the user scrolls the viewport in order to stop the cookie set taking too much
		 * CPU!
		 *  @type     int
		 *  @default  0
		 */
		stateTO: null,

		/**
		 * setTimeout reference for the redraw, used when server-side processing is enabled in the
		 * DataTables in order to prevent DoSing the server
		 *  @type     int
		 *  @default  null
		 */
		drawTO: null,

		heights: {
			jump: null,
			page: null,
			virtual: null,
			scroll: null,

			/**
			 * Height of rows in the table
			 *  @type     int
			 *  @default  0
			 */
			row: null,

			/**
			 * Pixel height of the viewport
			 *  @type     int
			 *  @default  0
			 */
			viewport: null,
			labelFactor: 1
		},

		topRowFloat: 0,
		scrollDrawDiff: null,
		loaderVisible: false,
		forceReposition: false,
		baseRowTop: 0,
		baseScrollTop: 0,
		mousedown: false,
		lastScrollTop: 0
	};

	// @todo The defaults should extend a `c` property and the internal settings
	// only held in the `s` property. At the moment they are mixed
	this.s = $.extend( this.s, Scroller.oDefaults, opts );

	// Workaround for row height being read from height object (see above comment)
	this.s.heights.row = this.s.rowHeight;

	/**
	 * DOM elements used by the class instance
	 * @private
	 * @namespace
	 *
	 */
	this.dom = {
		"force":    document.createElement('div'),
		"label":    $('<div class="dts_label">0</div>'),
		"scroller": null,
		"table":    null,
		"loader":   null
	};

	// Attach the instance to the DataTables instance so it can be accessed in
	// future. Don't initialise Scroller twice on the same table
	if ( this.s.dt.oScroller ) {
		return;
	}

	this.s.dt.oScroller = this;

	/* Let's do it */
	this.construct();
};



$.extend( Scroller.prototype, {
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Public methods - to be exposed via the DataTables API
	 */

	/**
	 * Calculate and store information about how many rows are to be displayed
	 * in the scrolling viewport, based on current dimensions in the browser's
	 * rendering. This can be particularly useful if the table is initially
	 * drawn in a hidden element - for example in a tab.
	 *  @param {bool} [redraw=true] Redraw the table automatically after the recalculation, with
	 *    the new dimensions forming the basis for the draw.
	 *  @returns {void}
	 */
	measure: function ( redraw )
	{
		if ( this.s.autoHeight )
		{
			this._calcRowHeight();
		}

		var heights = this.s.heights;

		if ( heights.row ) {
			heights.viewport = $.contains(document, this.dom.scroller) ?
				this.dom.scroller.clientHeight :
				this._parseHeight($(this.dom.scroller).css('height'));

			// If collapsed (no height) use the max-height parameter
			if ( ! heights.viewport ) {
				heights.viewport = this._parseHeight($(this.dom.scroller).css('max-height'));
			}

			this.s.viewportRows = parseInt( heights.viewport / heights.row, 10 )+1;
			this.s.dt._iDisplayLength = this.s.viewportRows * this.s.displayBuffer;
		}

		var label = this.dom.label.outerHeight();
		heights.labelFactor = (heights.viewport-label) / heights.scroll;

		if ( redraw === undefined || redraw )
		{
			this.s.dt.oInstance.fnDraw( false );
		}
	},

	/**
	 * Get information about current displayed record range. This corresponds to
	 * the information usually displayed in the "Info" block of the table.
	 *
	 * @returns {object} info as an object:
	 *  {
	 *      start: {int}, // the 0-indexed record at the top of the viewport
	 *      end:   {int}, // the 0-indexed record at the bottom of the viewport
	 *  }
	*/
	pageInfo: function()
	{
		var 
			dt = this.s.dt,
			iScrollTop = this.dom.scroller.scrollTop,
			iTotal = dt.fnRecordsDisplay(),
			iPossibleEnd = Math.ceil(this.pixelsToRow(iScrollTop + this.s.heights.viewport, false, this.s.ani));

		return {
			start: Math.floor(this.pixelsToRow(iScrollTop, false, this.s.ani)),
			end: iTotal < iPossibleEnd ? iTotal-1 : iPossibleEnd-1
		};
	},

	/**
	 * Calculate the row number that will be found at the given pixel position
	 * (y-scroll).
	 *
	 * Please note that when the height of the full table exceeds 1 million
	 * pixels, Scroller switches into a non-linear mode for the scrollbar to fit
	 * all of the records into a finite area, but this function returns a linear
	 * value (relative to the last non-linear positioning).
	 *  @param {int} pixels Offset from top to calculate the row number of
	 *  @param {int} [intParse=true] If an integer value should be returned
	 *  @param {int} [virtual=false] Perform the calculations in the virtual domain
	 *  @returns {int} Row index
	 */
	pixelsToRow: function ( pixels, intParse, virtual )
	{
		var diff = pixels - this.s.baseScrollTop;
		var row = virtual ?
			(this._domain( 'physicalToVirtual', this.s.baseScrollTop ) + diff) / this.s.heights.row :
			( diff / this.s.heights.row ) + this.s.baseRowTop;

		return intParse || intParse === undefined ?
			parseInt( row, 10 ) :
			row;
	},

	/**
	 * Calculate the pixel position from the top of the scrolling container for
	 * a given row
	 *  @param {int} iRow Row number to calculate the position of
	 *  @returns {int} Pixels
	 */
	rowToPixels: function ( rowIdx, intParse, virtual )
	{
		var pixels;
		var diff = rowIdx - this.s.baseRowTop;

		if ( virtual ) {
			pixels = this._domain( 'virtualToPhysical', this.s.baseScrollTop );
			pixels += diff * this.s.heights.row;
		}
		else {
			pixels = this.s.baseScrollTop;
			pixels += diff * this.s.heights.row;
		}

		return intParse || intParse === undefined ?
			parseInt( pixels, 10 ) :
			pixels;
	},


	/**
	 * Calculate the row number that will be found at the given pixel position (y-scroll)
	 *  @param {int} row Row index to scroll to
	 *  @param {bool} [animate=true] Animate the transition or not
	 *  @returns {void}
	 */
	scrollToRow: function ( row, animate )
	{
		var that = this;
		var ani = false;
		var px = this.rowToPixels( row );

		// We need to know if the table will redraw or not before doing the
		// scroll. If it will not redraw, then we need to use the currently
		// displayed table, and scroll with the physical pixels. Otherwise, we
		// need to calculate the table's new position from the virtual
		// transform.
		var preRows = ((this.s.displayBuffer-1)/2) * this.s.viewportRows;
		var drawRow = row - preRows;
		if ( drawRow < 0 ) {
			drawRow = 0;
		}

		if ( (px > this.s.redrawBottom || px < this.s.redrawTop) && this.s.dt._iDisplayStart !== drawRow ) {
			ani = true;
			px = this._domain( 'virtualToPhysical', row * this.s.heights.row );

			// If we need records outside the current draw region, but the new
			// scrolling position is inside that (due to the non-linear nature
			// for larger numbers of records), we need to force position update.
			if ( this.s.redrawTop < px && px < this.s.redrawBottom ) {
				this.s.forceReposition = true;
				animate = false;
			}
		}

		if ( animate === undefined || animate )
		{
			this.s.ani = ani;
			$(this.dom.scroller).animate( {
				"scrollTop": px
			}, function () {
				// This needs to happen after the animation has completed and
				// the final scroll event fired
				setTimeout( function () {
					that.s.ani = false;
				}, 250 );
			} );
		}
		else
		{
			$(this.dom.scroller).scrollTop( px );
		}
	},


	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Constructor
	 */

	/**
	 * Initialisation for Scroller
	 *  @returns {void}
	 *  @private
	 */
	construct: function ()
	{
		var that = this;
		var dt = this.s.dtApi;

		/* Sanity check */
		if ( !this.s.dt.oFeatures.bPaginate ) {
			this.s.dt.oApi._fnLog( this.s.dt, 0, 'Pagination must be enabled for Scroller' );
			return;
		}

		/* Insert a div element that we can use to force the DT scrolling container to
		 * the height that would be required if the whole table was being displayed
		 */
		this.dom.force.style.position = "relative";
		this.dom.force.style.top = "0px";
		this.dom.force.style.left = "0px";
		this.dom.force.style.width = "1px";

		this.dom.scroller = $('div.'+this.s.dt.oClasses.sScrollBody, this.s.dt.nTableWrapper)[0];
		this.dom.scroller.appendChild( this.dom.force );
		this.dom.scroller.style.position = "relative";

		this.dom.table = $('>table', this.dom.scroller)[0];
		this.dom.table.style.position = "absolute";
		this.dom.table.style.top = "0px";
		this.dom.table.style.left = "0px";

		// Add class to 'announce' that we are a Scroller table
		$(dt.table().container()).addClass('dts DTS');

		// Add a 'loading' indicator
		if ( this.s.loadingIndicator )
		{
			this.dom.loader = $('<div class="dataTables_processing dts_loading">'+this.s.dt.oLanguage.sLoadingRecords+'</div>')
				.css('display', 'none');

			$(this.dom.scroller.parentNode)
				.css('position', 'relative')
				.append( this.dom.loader );
		}

		this.dom.label.appendTo(this.dom.scroller);

		/* Initial size calculations */
		if ( this.s.heights.row && this.s.heights.row != 'auto' )
		{
			this.s.autoHeight = false;
		}
		this.measure( false );

		// Scrolling callback to see if a page change is needed - use a throttled
		// function for the save save callback so we aren't hitting it on every
		// scroll
		this.s.ingnoreScroll = true;
		this.s.stateSaveThrottle = this.s.dt.oApi._fnThrottle( function () {
			that.s.dtApi.state.save();
		}, 500 );
		$(this.dom.scroller).on( 'scroll.dt-scroller', function (e) {
			that._scroll.call( that );
		} );

		// In iOS we catch the touchstart event in case the user tries to scroll
		// while the display is already scrolling
		$(this.dom.scroller).on('touchstart.dt-scroller', function () {
			that._scroll.call( that );
		} );

		$(this.dom.scroller)
			.on('mousedown.dt-scroller', function () {
				that.s.mousedown = true;
			})
			.on('mouseup.dt-scroller', function () {
				that.s.mouseup = false;
				that.dom.label.css('display', 'none');
			});

		// On resize, update the information element, since the number of rows shown might change
		$(window).on( 'resize.dt-scroller', function () {
			that.measure( false );
			that._info();
		} );

		// Add a state saving parameter to the DT state saving so we can restore the exact
		// position of the scrolling. Slightly surprisingly the scroll position isn't actually
		// stored, but rather tha base units which are needed to calculate it. This allows for
		// virtual scrolling as well.
		var initialStateSave = true;
		var loadedState = dt.state.loaded();

		dt.on( 'stateSaveParams.scroller', function ( e, settings, data ) {
			// Need to used the saved position on init
			data.scroller = {
				topRow: initialStateSave && loadedState && loadedState.scroller ?
					loadedState.scroller.topRow :
					that.s.topRowFloat,
				baseScrollTop: that.s.baseScrollTop,
				baseRowTop: that.s.baseRowTop
			};

			initialStateSave = false;
		} );

		if ( loadedState && loadedState.scroller ) {
			this.s.topRowFloat = loadedState.scroller.topRow;
			this.s.baseScrollTop = loadedState.scroller.baseScrollTop;
			this.s.baseRowTop = loadedState.scroller.baseRowTop;
		}

		dt.on( 'init.scroller', function () {
			that.measure( false );

			// Setting to `jump` will instruct _draw to calculate the scroll top
			// position
			that.s.scrollType = 'jump';
			that._draw();

			// Update the scroller when the DataTable is redrawn
			dt.on( 'draw.scroller', function () {
				that._draw();
			});
		} );

		// Set height before the draw happens, allowing everything else to update
		// on draw complete without worry for roder.
		dt.on( 'preDraw.dt.scroller', function () {
			that._scrollForce();
		} );

		// Destructor
		dt.on( 'destroy.scroller', function () {
			$(window).off( 'resize.dt-scroller' );
			$(that.dom.scroller).off('.dt-scroller');
			$(that.s.dt.nTable).off( '.scroller' );

			$(that.s.dt.nTableWrapper).removeClass('DTS');
			$('div.DTS_Loading', that.dom.scroller.parentNode).remove();

			that.dom.table.style.position = "";
			that.dom.table.style.top = "";
			that.dom.table.style.left = "";
		} );
	},


	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Private methods
	 */

	/**
	 * Automatic calculation of table row height. This is just a little tricky here as using
	 * initialisation DataTables has tale the table out of the document, so we need to create
	 * a new table and insert it into the document, calculate the row height and then whip the
	 * table out.
	 *  @returns {void}
	 *  @private
	 */
	_calcRowHeight: function ()
	{
		var dt = this.s.dt;
		var origTable = dt.nTable;
		var nTable = origTable.cloneNode( false );
		var tbody = $('<tbody/>').appendTo( nTable );
		var container = $(
			'<div class="'+dt.oClasses.sWrapper+' DTS">'+
				'<div class="'+dt.oClasses.sScrollWrapper+'">'+
					'<div class="'+dt.oClasses.sScrollBody+'"></div>'+
				'</div>'+
			'</div>'
		);

		// Want 3 rows in the sizing table so :first-child and :last-child
		// CSS styles don't come into play - take the size of the middle row
		$('tbody tr:lt(4)', origTable).clone().appendTo( tbody );
        var rowsCount = $('tr', tbody).length;

        if ( rowsCount === 1 ) {
            tbody.prepend('<tr><td>&#160;</td></tr>');
            tbody.append('<tr><td>&#160;</td></tr>');
		}
		else {
            for (; rowsCount < 3; rowsCount++) {
                tbody.append('<tr><td>&#160;</td></tr>');
            }
		}
	
		$('div.'+dt.oClasses.sScrollBody, container).append( nTable );

		// If initialised using `dom`, use the holding element as the insert point
		var insertEl = this.s.dt.nHolding || origTable.parentNode;

		if ( ! $(insertEl).is(':visible') ) {
			insertEl = 'body';
		}

		container.appendTo( insertEl );
		this.s.heights.row = $('tr', tbody).eq(1).outerHeight();

		container.remove();
	},

	/**
	 * Draw callback function which is fired when the DataTable is redrawn. The main function of
	 * this method is to position the drawn table correctly the scrolling container for the rows
	 * that is displays as a result of the scrolling position.
	 *  @returns {void}
	 *  @private
	 */
	_draw: function ()
	{
		var
			that = this,
			heights = this.s.heights,
			iScrollTop = this.dom.scroller.scrollTop,
			iTableHeight = $(this.s.dt.nTable).height(),
			displayStart = this.s.dt._iDisplayStart,
			displayLen = this.s.dt._iDisplayLength,
			displayEnd = this.s.dt.fnRecordsDisplay();

		// Disable the scroll event listener while we are updating the DOM
		this.s.skip = true;

		// If paging is reset
		if ( (this.s.dt.bSorted || this.s.dt.bFiltered) && displayStart === 0 && !this.s.dt._drawHold ) {
			this.s.topRowFloat = 0;
		}

		iScrollTop = this.s.scrollType === 'jump' ?
			this._domain( 'virtualToPhysical', this.s.topRowFloat * heights.row ) :
			iScrollTop;

		// Store positional information so positional calculations can be based
		// upon the current table draw position
		this.s.baseScrollTop = iScrollTop;
		this.s.baseRowTop = this.s.topRowFloat;

		// Position the table in the virtual scroller
		var tableTop = iScrollTop - ((this.s.topRowFloat - displayStart) * heights.row);
		if ( displayStart === 0 ) {
			tableTop = 0;
		}
		else if ( displayStart + displayLen >= displayEnd ) {
			tableTop = heights.scroll - iTableHeight;
		}

		this.dom.table.style.top = tableTop+'px';

		/* Cache some information for the scroller */
		this.s.tableTop = tableTop;
		this.s.tableBottom = iTableHeight + this.s.tableTop;

		// Calculate the boundaries for where a redraw will be triggered by the
		// scroll event listener
		var boundaryPx = (iScrollTop - this.s.tableTop) * this.s.boundaryScale;
		this.s.redrawTop = iScrollTop - boundaryPx;
		this.s.redrawBottom = iScrollTop + boundaryPx > heights.scroll - heights.viewport - heights.row ?
			heights.scroll - heights.viewport - heights.row :
			iScrollTop + boundaryPx;

		this.s.skip = false;

		// Restore the scrolling position that was saved by DataTable's state
		// saving Note that this is done on the second draw when data is Ajax
		// sourced, and the first draw when DOM soured
		if ( this.s.dt.oFeatures.bStateSave && this.s.dt.oLoadedState !== null &&
			 typeof this.s.dt.oLoadedState.iScroller != 'undefined' )
		{
			// A quirk of DataTables is that the draw callback will occur on an
			// empty set if Ajax sourced, but not if server-side processing.
			var ajaxSourced = (this.s.dt.sAjaxSource || that.s.dt.ajax) && ! this.s.dt.oFeatures.bServerSide ?
				true :
				false;

			if ( ( ajaxSourced && this.s.dt.iDraw == 2) ||
			     (!ajaxSourced && this.s.dt.iDraw == 1) )
			{
				setTimeout( function () {
					$(that.dom.scroller).scrollTop( that.s.dt.oLoadedState.iScroller );
					that.s.redrawTop = that.s.dt.oLoadedState.iScroller - (heights.viewport/2);

					// In order to prevent layout thrashing we need another
					// small delay
					setTimeout( function () {
						that.s.ingnoreScroll = false;
					}, 0 );
				}, 0 );
			}
		}
		else {
			that.s.ingnoreScroll = false;
		}

		// Because of the order of the DT callbacks, the info update will
		// take precedence over the one we want here. So a 'thread' break is
		// needed.  Only add the thread break if bInfo is set
		if ( this.s.dt.oFeatures.bInfo ) {
			setTimeout( function () {
				that._info.call( that );
			}, 0 );
		}

		// Hide the loading indicator
		if ( this.dom.loader && this.s.loaderVisible ) {
			this.dom.loader.css( 'display', 'none' );
			this.s.loaderVisible = false;
		}
	},

	/**
	 * Convert from one domain to another. The physical domain is the actual
	 * pixel count on the screen, while the virtual is if we had browsers which
	 * had scrolling containers of infinite height (i.e. the absolute value)
	 *
	 *  @param {string} dir Domain transform direction, `virtualToPhysical` or
	 *    `physicalToVirtual` 
	 *  @returns {number} Calculated transform
	 *  @private
	 */
	_domain: function ( dir, val )
	{
		var heights = this.s.heights;
		var diff;
		var magic = 10000; // the point at which the non-linear calculations start to happen

		// If the virtual and physical height match, then we use a linear
		// transform between the two, allowing the scrollbar to be linear
		if ( heights.virtual === heights.scroll ) {
			return val;
		}

		// In the first 10k pixels and the last 10k pixels, we want the scrolling
		// to be linear. After that it can be non-linear. It would be unusual for
		// anyone to mouse wheel through that much.
		if ( val < magic ) {
			return val;
		}
		else if ( dir === 'virtualToPhysical' && val >= heights.virtual - magic ) {
			diff = heights.virtual - val;
			return heights.scroll - diff;
		}
		else if ( dir === 'physicalToVirtual' && val >= heights.scroll - magic ) {
			diff = heights.scroll - val;
			return heights.virtual - diff;
		}

		// Otherwise, we want a non-linear scrollbar to take account of the
		// redrawing regions at the start and end of the table, otherwise these
		// can stutter badly - on large tables 30px (for example) scroll might
		// be hundreds of rows, so the table would be redrawing every few px at
		// the start and end. Use a simple linear eq. to stop this, effectively
		// causing a kink in the scrolling ratio. It does mean the scrollbar is
		// non-linear, but with such massive data sets, the scrollbar is going
		// to be a best guess anyway
		var m = (heights.virtual - magic - magic) / (heights.scroll - magic - magic);
		var c = magic - (m*magic);

		return dir === 'virtualToPhysical' ?
			(val-c) / m :
			(m*val) + c;
	},

	/**
	 * Update any information elements that are controlled by the DataTable based on the scrolling
	 * viewport and what rows are visible in it. This function basically acts in the same way as
	 * _fnUpdateInfo in DataTables, and effectively replaces that function.
	 *  @returns {void}
	 *  @private
	 */
	_info: function ()
	{
		if ( !this.s.dt.oFeatures.bInfo )
		{
			return;
		}

		var
			dt = this.s.dt,
			language = dt.oLanguage,
			iScrollTop = this.dom.scroller.scrollTop,
			iStart = Math.floor( this.pixelsToRow(iScrollTop, false, this.s.ani)+1 ),
			iMax = dt.fnRecordsTotal(),
			iTotal = dt.fnRecordsDisplay(),
			iPossibleEnd = Math.ceil( this.pixelsToRow(iScrollTop+this.s.heights.viewport, false, this.s.ani) ),
			iEnd = iTotal < iPossibleEnd ? iTotal : iPossibleEnd,
			sStart = dt.fnFormatNumber( iStart ),
			sEnd = dt.fnFormatNumber( iEnd ),
			sMax = dt.fnFormatNumber( iMax ),
			sTotal = dt.fnFormatNumber( iTotal ),
			sOut;

		if ( dt.fnRecordsDisplay() === 0 &&
			   dt.fnRecordsDisplay() == dt.fnRecordsTotal() )
		{
			/* Empty record set */
			sOut = language.sInfoEmpty+ language.sInfoPostFix;
		}
		else if ( dt.fnRecordsDisplay() === 0 )
		{
			/* Empty record set after filtering */
			sOut = language.sInfoEmpty +' '+
				language.sInfoFiltered.replace('_MAX_', sMax)+
					language.sInfoPostFix;
		}
		else if ( dt.fnRecordsDisplay() == dt.fnRecordsTotal() )
		{
			/* Normal record set */
			sOut = language.sInfo.
					replace('_START_', sStart).
					replace('_END_',   sEnd).
					replace('_MAX_',   sMax).
					replace('_TOTAL_', sTotal)+
				language.sInfoPostFix;
		}
		else
		{
			/* Record set after filtering */
			sOut = language.sInfo.
					replace('_START_', sStart).
					replace('_END_',   sEnd).
					replace('_MAX_',   sMax).
					replace('_TOTAL_', sTotal) +' '+
				language.sInfoFiltered.replace(
					'_MAX_',
					dt.fnFormatNumber(dt.fnRecordsTotal())
				)+
				language.sInfoPostFix;
		}

		var callback = language.fnInfoCallback;
		if ( callback ) {
			sOut = callback.call( dt.oInstance,
				dt, iStart, iEnd, iMax, iTotal, sOut
			);
		}

		var n = dt.aanFeatures.i;
		if ( typeof n != 'undefined' )
		{
			for ( var i=0, iLen=n.length ; i<iLen ; i++ )
			{
				$(n[i]).html( sOut );
			}
		}

		// DT doesn't actually (yet) trigger this event, but it will in future
		$(dt.nTable).triggerHandler( 'info.dt' );
	},

	/**
	 * Parse CSS height property string as number
	 *
	 * An attempt is made to parse the string as a number. Currently supported units are 'px',
	 * 'vh', and 'rem'. 'em' is partially supported; it works as long as the parent element's
	 * font size matches the body element. Zero is returned for unrecognized strings.
	 *  @param {string} cssHeight CSS height property string
	 *  @returns {number} height
	 *  @private
	 */
	_parseHeight: function(cssHeight) {
		var height;
		var matches = /^([+-]?(?:\d+(?:\.\d+)?|\.\d+))(px|em|rem|vh)$/.exec(cssHeight);

		if (matches === null) {
			return 0;
		}

		var value = parseFloat(matches[1]);
		var unit = matches[2];

		if ( unit === 'px' ) {
			height = value;
		}
		else if ( unit === 'vh' ) {
			height = ( value / 100 ) * $(window).height();
		}
		else if ( unit === 'rem' ) {
			height = value * parseFloat($(':root').css('font-size'));
		}
		else if ( unit === 'em' ) {
			height = value * parseFloat($('body').css('font-size'));
		}

		return height ?
			height :
			0;
	},

	/**
	 * Scrolling function - fired whenever the scrolling position is changed.
	 * This method needs to use the stored values to see if the table should be
	 * redrawn as we are moving towards the end of the information that is
	 * currently drawn or not. If needed, then it will redraw the table based on
	 * the new position.
	 *  @returns {void}
	 *  @private
	 */
	_scroll: function ()
	{
		var
			that = this,
			heights = this.s.heights,
			iScrollTop = this.dom.scroller.scrollTop,
			iTopRow;

		if ( this.s.skip ) {
			return;
		}

		if ( this.s.ingnoreScroll ) {
			return;
		}

		if ( iScrollTop === this.s.lastScrollTop ) {
			return;
		}

		/* If the table has been sorted or filtered, then we use the redraw that
		 * DataTables as done, rather than performing our own
		 */
		if ( this.s.dt.bFiltered || this.s.dt.bSorted ) {
			this.s.lastScrollTop = 0;
			return;
		}

		/* Update the table's information display for what is now in the viewport */
		this._info();

		/* We don't want to state save on every scroll event - that's heavy
		 * handed, so use a timeout to update the state saving only when the
		 * scrolling has finished
		 */
		clearTimeout( this.s.stateTO );
		this.s.stateTO = setTimeout( function () {
			that.s.dtApi.state.save();
		}, 250 );

		this.s.scrollType = Math.abs(iScrollTop - this.s.lastScrollTop) > heights.viewport ?
			'jump' :
			'cont';

		this.s.topRowFloat = this.s.scrollType === 'cont' ?
			this.pixelsToRow( iScrollTop, false, false ) :
			this._domain( 'physicalToVirtual', iScrollTop ) / heights.row;

		if ( this.s.topRowFloat < 0 ) {
			this.s.topRowFloat = 0;
		}

		/* Check if the scroll point is outside the trigger boundary which would required
		 * a DataTables redraw
		 */
		if ( this.s.forceReposition || iScrollTop < this.s.redrawTop || iScrollTop > this.s.redrawBottom ) {
			var preRows = Math.ceil( ((this.s.displayBuffer-1)/2) * this.s.viewportRows );

			iTopRow = parseInt(this.s.topRowFloat, 10) - preRows;
			this.s.forceReposition = false;

			if ( iTopRow <= 0 ) {
				/* At the start of the table */
				iTopRow = 0;
			}
			else if ( iTopRow + this.s.dt._iDisplayLength > this.s.dt.fnRecordsDisplay() ) {
				/* At the end of the table */
				iTopRow = this.s.dt.fnRecordsDisplay() - this.s.dt._iDisplayLength;
				if ( iTopRow < 0 ) {
					iTopRow = 0;
				}
			}
			else if ( iTopRow % 2 !== 0 ) {
				// For the row-striping classes (odd/even) we want only to start
				// on evens otherwise the stripes will change between draws and
				// look rubbish
				iTopRow++;
			}


			if ( iTopRow != this.s.dt._iDisplayStart ) {
				/* Cache the new table position for quick lookups */
				this.s.tableTop = $(this.s.dt.nTable).offset().top;
				this.s.tableBottom = $(this.s.dt.nTable).height() + this.s.tableTop;

				var draw =  function () {
					if ( that.s.scrollDrawReq === null ) {
						that.s.scrollDrawReq = iScrollTop;
					}

					that.s.dt._iDisplayStart = iTopRow;
					that.s.dt.oApi._fnDraw( that.s.dt );
				};

				/* Do the DataTables redraw based on the calculated start point - note that when
				 * using server-side processing we introduce a small delay to not DoS the server...
				 */
				if ( this.s.dt.oFeatures.bServerSide ) {
					clearTimeout( this.s.drawTO );
					this.s.drawTO = setTimeout( draw, this.s.serverWait );
				}
				else {
					draw();
				}

				if ( this.dom.loader && ! this.s.loaderVisible ) {
					this.dom.loader.css( 'display', 'block' );
					this.s.loaderVisible = true;
				}
			}
		}
		else {
			this.s.topRowFloat = this.pixelsToRow( iScrollTop, false, true );
		}

		this.s.lastScrollTop = iScrollTop;
		this.s.stateSaveThrottle();

		if ( this.s.scrollType === 'jump' && this.s.mousedown ) {
			this.dom.label
				.html( this.s.dt.fnFormatNumber( parseInt( this.s.topRowFloat, 10 )+1 ) )
				.css( 'top', iScrollTop + (iScrollTop * heights.labelFactor ) )
				.css( 'display', 'block' );
		}
	},

	/**
	 * Force the scrolling container to have height beyond that of just the
	 * table that has been drawn so the user can scroll the whole data set.
	 *
	 * Note that if the calculated required scrolling height exceeds a maximum
	 * value (1 million pixels - hard-coded) the forcing element will be set
	 * only to that maximum value and virtual / physical domain transforms will
	 * be used to allow Scroller to display tables of any number of records.
	 *  @returns {void}
	 *  @private
	 */
	_scrollForce: function ()
	{
		var heights = this.s.heights;
		var max = 1000000;

		heights.virtual = heights.row * this.s.dt.fnRecordsDisplay();
		heights.scroll = heights.virtual;

		if ( heights.scroll > max ) {
			heights.scroll = max;
		}

		// Minimum height so there is always a row visible (the 'no rows found'
		// if reduced to zero filtering)
		this.dom.force.style.height = heights.scroll > this.s.heights.row ?
			heights.scroll+'px' :
			this.s.heights.row+'px';
	}
} );



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Statics
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


/**
 * Scroller default settings for initialisation
 *  @namespace
 *  @name Scroller.defaults
 *  @static
 */
Scroller.defaults = {
	/**
	 * Scroller uses the boundary scaling factor to decide when to redraw the table - which it
	 * typically does before you reach the end of the currently loaded data set (in order to
	 * allow the data to look continuous to a user scrolling through the data). If given as 0
	 * then the table will be redrawn whenever the viewport is scrolled, while 1 would not
	 * redraw the table until the currently loaded data has all been shown. You will want
	 * something in the middle - the default factor of 0.5 is usually suitable.
	 *  @type     float
	 *  @default  0.5
	 *  @static
	 */
	boundaryScale: 0.5,

	/**
	 * The display buffer is what Scroller uses to calculate how many rows it should pre-fetch
	 * for scrolling. Scroller automatically adjusts DataTables' display length to pre-fetch
	 * rows that will be shown in "near scrolling" (i.e. just beyond the current display area).
	 * The value is based upon the number of rows that can be displayed in the viewport (i.e.
	 * a value of 1), and will apply the display range to records before before and after the
	 * current viewport - i.e. a factor of 3 will allow Scroller to pre-fetch 1 viewport's worth
	 * of rows before the current viewport, the current viewport's rows and 1 viewport's worth
	 * of rows after the current viewport. Adjusting this value can be useful for ensuring
	 * smooth scrolling based on your data set.
	 *  @type     int
	 *  @default  7
	 *  @static
	 */
	displayBuffer: 9,

	/**
	 * Show (or not) the loading element in the background of the table. Note that you should
	 * include the dataTables.scroller.css file for this to be displayed correctly.
	 *  @type     boolean
	 *  @default  false
	 *  @static
	 */
	loadingIndicator: false,

	/**
	 * Scroller will attempt to automatically calculate the height of rows for it's internal
	 * calculations. However the height that is used can be overridden using this parameter.
	 *  @type     int|string
	 *  @default  auto
	 *  @static
	 */
	rowHeight: "auto",

	/**
	 * When using server-side processing, Scroller will wait a small amount of time to allow
	 * the scrolling to finish before requesting more data from the server. This prevents
	 * you from DoSing your own server! The wait time can be configured by this parameter.
	 *  @type     int
	 *  @default  200
	 *  @static
	 */
	serverWait: 200
};

Scroller.oDefaults = Scroller.defaults;



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Constants
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/**
 * Scroller version
 *  @type      String
 *  @default   See code
 *  @name      Scroller.version
 *  @static
 */
Scroller.version = "2.0.1";



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Initialisation
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

// Attach a listener to the document which listens for DataTables initialisation
// events so we can automatically initialise
$(document).on( 'preInit.dt.dtscroller', function (e, settings) {
	if ( e.namespace !== 'dt' ) {
		return;
	}

	var init = settings.oInit.scroller;
	var defaults = DataTable.defaults.scroller;

	if ( init || defaults ) {
		var opts = $.extend( {}, init, defaults );

		if ( init !== false ) {
			new Scroller( settings, opts  );
		}
	}
} );


// Attach Scroller to DataTables so it can be accessed as an 'extra'
$.fn.dataTable.Scroller = Scroller;
$.fn.DataTable.Scroller = Scroller;


// DataTables 1.10 API method aliases
var Api = $.fn.dataTable.Api;

Api.register( 'scroller()', function () {
	return this;
} );

// Undocumented and deprecated - is it actually useful at all?
Api.register( 'scroller().rowToPixels()', function ( rowIdx, intParse, virtual ) {
	var ctx = this.context;

	if ( ctx.length && ctx[0].oScroller ) {
		return ctx[0].oScroller.rowToPixels( rowIdx, intParse, virtual );
	}
	// undefined
} );

// Undocumented and deprecated - is it actually useful at all?
Api.register( 'scroller().pixelsToRow()', function ( pixels, intParse, virtual ) {
	var ctx = this.context;

	if ( ctx.length && ctx[0].oScroller ) {
		return ctx[0].oScroller.pixelsToRow( pixels, intParse, virtual );
	}
	// undefined
} );

// `scroller().scrollToRow()` is undocumented and deprecated. Use `scroller.toPosition()
Api.register( ['scroller().scrollToRow()', 'scroller.toPosition()'], function ( idx, ani ) {
	this.iterator( 'table', function ( ctx ) {
		if ( ctx.oScroller ) {
			ctx.oScroller.scrollToRow( idx, ani );
		}
	} );

	return this;
} );

Api.register( 'row().scrollTo()', function ( ani ) {
	var that = this;

	this.iterator( 'row', function ( ctx, rowIdx ) {
		if ( ctx.oScroller ) {
			var displayIdx = that
				.rows( { order: 'applied', search: 'applied' } )
				.indexes()
				.indexOf( rowIdx );

			ctx.oScroller.scrollToRow( displayIdx, ani );
		}
	} );

	return this;
} );

Api.register( 'scroller.measure()', function ( redraw ) {
	this.iterator( 'table', function ( ctx ) {
		if ( ctx.oScroller ) {
			ctx.oScroller.measure( redraw );
		}
	} );

	return this;
} );

Api.register( 'scroller.page()', function() {
	var ctx = this.context;

	if ( ctx.length && ctx[0].oScroller ) {
		return ctx[0].oScroller.pageInfo();
	}
	// undefined
} );

return Scroller;
}));


/*! SearchPanes 1.0.1
 * 2019-2020 SpryMedia Ltd - datatables.net/license
 */
(function () {
    'use strict';

    var DataTable = $.fn.dataTable;
    var SearchPane = /** @class */ (function () {
        /**
         * Creates the panes, sets up the search function
         * @param paneSettings The settings for the searchPanes
         * @param opts The options for the default features
         * @param idx the index of the column for this pane
         * @returns {object} the pane that has been created, including the table and the index of the pane
         */
        function SearchPane(paneSettings, opts, idx, layout, panesContainer, panes) {
            var _this = this;
            if (panes === void 0) { panes = null; }
            // Check that the required version of DataTables is included
            if (!DataTable || !DataTable.versionCheck || !DataTable.versionCheck('1.10.0')) {
                throw new Error('SearchPane requires DataTables 1.10 or newer');
            }
            // Check that Select is included
            if (!DataTable.select) {
                throw new Error('SearchPane requires Select');
            }
            var table = new DataTable.Api(paneSettings);
            this.classes = $.extend(true, {}, SearchPane.classes);
            // Get options from user
            this.c = $.extend(true, {}, SearchPane.defaults, opts);
            this.customPaneSettings = panes;
            this.s = {
                cascadeRegen: false,
                clearing: false,
                colOpts: [],
                deselect: false,
                displayed: false,
                dt: table,
                dtPane: undefined,
                filteringActive: false,
                index: idx,
                indexes: [],
                lastSelect: false,
                redraw: false,
                rowData: {
                    arrayFilter: [],
                    arrayOriginal: [],
                    arrayTotals: [],
                    bins: {},
                    binsOriginal: {},
                    binsTotal: {},
                    filterMap: new Map()
                },
                searchFunction: undefined,
                selectPresent: false,
                updating: false
            };
            var rowLength = table.columns().eq(0).toArray().length;
            this.colExists = this.s.index < rowLength;
            // Add extra elements to DOM object including clear and hide buttons
            this.c.layout = layout;
            var layVal = parseInt(layout.split('-')[1], 10);
            this.dom = {
                buttonGroup: $('<div/>').addClass(this.classes.buttonGroup),
                clear: $('<button type="button">&#215;</button>')
                    .addClass(this.classes.dull)
                    .addClass(this.classes.paneButton)
                    .addClass(this.classes.clearButton),
                container: $('<div/>').addClass(this.classes.container).addClass(this.classes.layout +
                    (layVal < 7 ? layout : layout.split('-')[0] + '-6')),
                countButton: $('<button type="button"></button>')
                    .addClass(this.classes.paneButton)
                    .addClass(this.classes.countButton),
                dtP: $('<table><thead><tr><th>' +
                    (this.colExists
                        ? $(table.column(this.colExists ? this.s.index : 0).header()).text()
                        : this.customPaneSettings.header || 'Custom Pane') + '</th><th/></tr></thead></table>'),
                lower: $('<div/>').addClass(this.classes.subRow2).addClass(this.classes.narrowButton),
                nameButton: $('<button type="button"></button>').addClass(this.classes.paneButton).addClass(this.classes.nameButton),
                searchBox: $('<input/>').addClass(this.classes.paneInputButton).addClass(this.classes.search),
                searchButton: $('<button type = "button" class="' + this.classes.searchIcon + '"></button>')
                    .addClass(this.classes.paneButton),
                searchCont: $('<div/>').addClass(this.classes.searchCont),
                searchLabelCont: $('<div/>').addClass(this.classes.searchLabelCont),
                topRow: $('<div/>').addClass(this.classes.topRow),
                upper: $('<div/>').addClass(this.classes.subRow1).addClass(this.classes.narrowSearch)
            };
            this.s.displayed = false;
            table = this.s.dt;
            this.selections = [];
            this.s.colOpts = this.colExists ? this._getOptions() : this._getBonusOptions();
            var colOpts = this.s.colOpts;
            var clear = $('<button type="button">X</button>').addClass(this.classes.paneButton);
            $(clear).text(table.i18n('searchPanes.clearPane', 'X'));
            this.dom.container.addClass(colOpts.className);
            this.dom.container.addClass((this.customPaneSettings !== null && this.customPaneSettings.className !== undefined)
                ? this.customPaneSettings.className
                : '');
            $(panesContainer).append(this.dom.container);
            var tableNode = table.table(0).node();
            // Custom search function for table
            this.s.searchFunction = function (settings, searchData, dataIndex, origData) {
                // If no data has been selected then show all
                if (_this.selections.length === 0) {
                    return true;
                }
                if (settings.nTable !== tableNode) {
                    return true;
                }
                var filter = '';
                if (_this.colExists) {
                    // Get the current filtered data
                    filter = searchData[_this.s.index];
                    if (colOpts.orthogonal.filter !== 'filter') {
                        // get the filter value from the map
                        filter = _this.s.rowData.filterMap.get(dataIndex);
                        if (filter instanceof $.fn.dataTable.Api) {
                            filter = filter.toArray();
                        }
                    }
                }
                return _this._search(filter, dataIndex);
            };
            $.fn.dataTable.ext.search.push(this.s.searchFunction);
            // If the clear button for this pane is clicked clear the selections
            if (this.c.clear) {
                $(clear).on('click', function () {
                    var searches = _this.dom.container.find(_this.classes.search);
                    searches.each(function () {
                        $(this).val('');
                        $(this).trigger('input');
                    });
                    _this.clearPane();
                });
            }
            // Sometimes the top row of the panes containing the search box and ordering buttons appears
            //  weird if the width of the panes is lower than expected, this fixes the design.
            // Equally this may occur when the table is resized.
            table.on('draw.dtsp', function () {
                _this._adjustTopRow();
            });
            $(window).on('resize.dtsp', DataTable.util.throttle(function () {
                _this._adjustTopRow();
            }));
            // When column-reorder is present and the columns are moved, it is necessary to
            //  reassign all of the panes indexes to the new index of the column.
            table.on('column-reorder.dtsp', function (e, settings, details) {
                _this.s.index = details.mapping[_this.s.index];
            });
            return this;
        }
        /**
         * In the case of a rebuild there is potential for new data to have been included or removed
         * so all of the rowData must be reset as a precaution.
         */
        SearchPane.prototype.clearData = function () {
            this.s.rowData = {
                arrayFilter: [],
                arrayOriginal: [],
                arrayTotals: [],
                bins: {},
                binsOriginal: {},
                binsTotal: {},
                filterMap: new Map()
            };
        };
        /**
         * Clear the selections in the pane
         */
        SearchPane.prototype.clearPane = function () {
            // Deselect all rows which are selected and update the table and filter count.
            this.s.dtPane.rows({ selected: true }).deselect();
            this.updateTable();
            return this;
        };
        /**
         * Strips all of the SearchPanes elements from the document and turns all of the listeners for the buttons off
         */
        SearchPane.prototype.destroy = function () {
            $(this.s.dtPane).off('.dtsp');
            $(this.s.dt).off('.dtsp');
            $(this.dom.nameButton).off('.dtsp');
            $(this.dom.countButton).off('.dtsp');
            $(this.dom.clear).off('.dtsp');
            $(this.dom.searchButton).off('.dtsp');
            $(this.dom.container).remove();
            var searchIdx = $.fn.dataTable.ext.search.indexOf(this.s.searchFunction);
            while (searchIdx !== -1) {
                $.fn.dataTable.ext.search.splice(searchIdx, 1);
                searchIdx = $.fn.dataTable.ext.search.indexOf(this.s.searchFunction);
            }
            // If the datatables have been defined for the panes then also destroy these
            if (this.s.dtPane !== undefined) {
                this.s.dtPane.destroy();
            }
        };
        /**
         * Updates the number of filters that have been applied in the title
         */
        SearchPane.prototype.getPaneCount = function () {
            return this.s.dtPane !== undefined ?
                this.s.dtPane.rows({ selected: true }).data().toArray().length :
                0;
        };
        /**
         * Rebuilds the panes from the start having deleted the old ones
         */
        SearchPane.prototype.rebuildPane = function () {
            this.clearData();
            // When rebuilding strip all of the HTML Elements out of the container and start from scratch
            if (this.s.dtPane !== undefined) {
                this.s.dtPane.clear().destroy();
            }
            this.dom.container.removeClass(this.classes.hidden);
            this.s.displayed = false;
            this._buildPane();
            return this;
        };
        /**
         * removes the pane from the page and sets the displayed property to false.
         */
        SearchPane.prototype.removePane = function () {
            this.s.displayed = false;
            $(this.dom.container).hide();
        };
        /**
         * Sets the cascadeRegen property of the pane. Accessible from above because as SearchPanes.ts deals with the rebuilds.
         * @param val the boolean value that the cascadeRegen property is to be set to
         */
        SearchPane.prototype.setCascadeRegen = function (val) {
            this.s.cascadeRegen = val;
        };
        /**
         * This function allows the clearing property to be assigned. This is used when implementing cascadePane.
         * In setting this to true for the clearing of the panes selection on the deselects it forces the pane to
         * repopulate from the entire dataset not just the displayed values.
         * @param val the boolean value which the clearing property is to be assigned
         */
        SearchPane.prototype.setClear = function (val) {
            this.s.clearing = val;
        };
        /**
         * Updates the values of all of the panes
         * @param draw whether this has been triggered by a draw event or not
         */
        SearchPane.prototype.updatePane = function (draw) {
            if (draw === void 0) { draw = false; }
            this.s.updating = true;
            this._updateCommon(draw);
            this.s.updating = false;
        };
        /**
         * Updates the panes if one of the options to do so has been set to true
         *   rather than the filtered message when using viewTotal.
         */
        SearchPane.prototype.updateTable = function () {
            var selectedRows = this.s.dtPane.rows({ selected: true }).data().toArray();
            this.selections = selectedRows;
            this._searchExtras();
            // If either of the options that effect how the panes are displayed are selected then update the Panes
            if (this.c.cascadePanes || this.c.viewTotal) {
                this.updatePane();
            }
        };
        /**
         * Takes in potentially undetected rows and adds them to the array if they are not yet featured
         * @param filter the filter value of the potential row
         * @param display the display value of the potential row
         * @param sort the sort value of the potential row
         * @param type the type value of the potential row
         * @param arrayFilter the array to be populated
         * @param bins the bins to be populated
         */
        SearchPane.prototype._addOption = function (filter, display, sort, type, arrayFilter, bins) {
            // If the filter is an array then take a note of this, and add the elements to the arrayFilter array
            if (Array.isArray(filter) || filter instanceof DataTable.Api) {
                // Convert to an array so that we can work with it
                if (filter instanceof DataTable.Api) {
                    filter = filter.toArray();
                    display = display.toArray();
                }
                if (filter.length === display.length) {
                    for (var i = 0; i < filter.length; i++) {
                        // If we haven't seen this row before add it
                        if (!bins[filter[i]]) {
                            bins[filter[i]] = 1;
                            arrayFilter.push({
                                display: display[i],
                                filter: filter[i],
                                sort: sort,
                                type: type
                            });
                        }
                        // Otherwise just increment the count
                        else {
                            bins[filter[i]]++;
                        }
                    }
                    return;
                }
                else {
                    throw new Error('display and filter not the same length');
                }
            }
            // If the values were affected by othogonal data and are not an array then check if it is already present
            else if (typeof this.s.colOpts.orthogonal === 'string') {
                if (!bins[filter]) {
                    bins[filter] = 1;
                    arrayFilter.push({
                        display: display,
                        filter: filter,
                        sort: sort,
                        type: type
                    });
                }
                else {
                    bins[filter]++;
                    return;
                }
            }
            // Otherwise we must just be adding an option
            else {
                arrayFilter.push({
                    display: display,
                    filter: filter,
                    sort: sort,
                    type: type
                });
            }
        };
        /**
         * Adds a row to the panes table
         * @param display the value to be displayed to the user
         * @param filter the value to be filtered on when searchpanes is implemented
         * @param shown the number of rows in the table that are currently visible matching this criteria
         * @param total the total number of rows in the table that match this criteria
         * @param sort the value to be sorted in the pane table
         * @param type the value of which the type is to be derived from
         */
        SearchPane.prototype._addRow = function (display, filter, shown, total, sort, type) {
            var index;
            for (var _i = 0, _a = this.s.indexes; _i < _a.length; _i++) {
                var entry = _a[_i];
                if (entry.filter === filter) {
                    index = entry.index;
                }
            }
            if (index === undefined) {
                index = this.s.indexes.length;
                this.s.indexes.push({ filter: filter, index: index });
            }
            return this.s.dtPane.row.add({
                display: display !== '' ? display : this.c.emptyMessage,
                filter: filter,
                index: index,
                shown: shown,
                sort: sort !== '' ? sort : this.c.emptyMessage,
                total: total,
                type: type
            });
        };
        /**
         * Adjusts the layout of the top row when the screen is resized
         */
        SearchPane.prototype._adjustTopRow = function () {
            var subContainers = this.dom.container.find('.' + this.classes.subRowsContainer);
            var subRow1 = this.dom.container.find('.dtsp-subRow1');
            var subRow2 = this.dom.container.find('.dtsp-subRow2');
            var topRow = this.dom.container.find('.' + this.classes.topRow);
            // If the width is 0 then it is safe to assume that the pane has not yet been displayed.
            //  Even if it has, if the width is 0 it won't make a difference if it has the narrow class or not
            if (($(subContainers[0]).width() < 252 || $(topRow[0]).width() < 252) && $(subContainers[0]).width() !== 0) {
                $(subContainers[0]).addClass(this.classes.narrow);
                $(subRow1[0]).addClass(this.classes.narrowSub).removeClass(this.classes.narrowSearch);
                $(subRow2[0]).addClass(this.classes.narrowSub).removeClass(this.classes.narrowButton);
            }
            else {
                $(subContainers[0]).removeClass(this.classes.narrow);
                $(subRow1[0]).removeClass(this.classes.narrowSub).addClass(this.classes.narrowSearch);
                $(subRow2[0]).removeClass(this.classes.narrowSub).addClass(this.classes.narrowButton);
            }
        };
        /**
         * Method to construct the actual pane.
         */
        SearchPane.prototype._buildPane = function () {
            var _this = this;
            // Aliases
            this.selections = [];
            var table = this.s.dt;
            var column = table.column(this.colExists ? this.s.index : 0);
            var colOpts = this.s.colOpts;
            var rowData = this.s.rowData;
            // Other Variables
            var countMessage = table.i18n('searchPanes.count', '{total}');
            var filteredMessage = table.i18n('searchPanes.countFiltered', '{shown} ({total})');
            var loadedFilter = table.state.loaded();
            // If it is not a custom pane in place
            if (this.colExists) {
                var idx = -1;
                if (loadedFilter && loadedFilter.searchPanes && loadedFilter.searchPanes.panes) {
                    for (var i = 0; i < loadedFilter.searchPanes.panes.length; i++) {
                        if (loadedFilter.searchPanes.panes[i].id === this.s.index) {
                            idx = i;
                            break;
                        }
                    }
                }
                // Perform checks that do not require populate pane to run
                if ((colOpts.show === false
                    || (colOpts.show !== undefined && colOpts.show !== true)) &&
                    idx === -1) {
                    this.dom.container.addClass(this.classes.hidden);
                    this.s.displayed = false;
                    return false;
                }
                else if (colOpts.show === true || idx !== -1) {
                    this.s.displayed = true;
                }
                // Only run populatePane if the data has not been collected yet
                if (rowData.arrayFilter.length === 0) {
                    this._populatePane();
                    if (loadedFilter && loadedFilter.searchPanes && loadedFilter.searchPanes.panes) {
                        // If the index is not found then no data has been added to the state for this pane,
                        //  which will only occur if it has previously failed to meet the criteria to be
                        //  displayed, therefore we can just hide it again here
                        if (idx !== -1) {
                            rowData.binsOriginal = loadedFilter.searchPanes.panes[idx].bins;
                            rowData.arrayOriginal = loadedFilter.searchPanes.panes[idx].arrayFilter;
                        }
                        else {
                            this.dom.container.addClass(this.classes.hidden);
                            this.s.displayed = false;
                            return;
                        }
                    }
                    else {
                        rowData.arrayOriginal = rowData.arrayFilter;
                        rowData.binsOriginal = rowData.bins;
                    }
                }
                var binLength = Object.keys(rowData.binsOriginal).length;
                var uniqueRatio = this._uniqueRatio(binLength, table.rows()[0].length);
                // Don't show the pane if there isn't enough variance in the data, or there is only 1 entry for that pane
                if (this.s.displayed === false && ((colOpts.show === undefined && colOpts.threshold === null ?
                    uniqueRatio > this.c.threshold :
                    uniqueRatio > colOpts.threshold)
                    || (colOpts.show !== true && binLength <= 1))) {
                    this.dom.container.addClass(this.classes.hidden);
                    this.s.displayed = false;
                    return;
                }
                // If the option viewTotal is true then find
                // the total count for the whole table to display alongside the displayed count
                if (this.c.viewTotal && rowData.arrayTotals.length === 0) {
                    this._detailsPane();
                }
                else {
                    rowData.binsTotal = rowData.bins;
                }
                this.dom.container.addClass(this.classes.show);
                this.s.displayed = true;
            }
            else {
                this.s.displayed = true;
            }
            // If the variance is accceptable then display the search pane
            this._displayPane();
            // Here, when the state is loaded if the data object on the original table is empty,
            //  then a state.clear() must have occurred, so delete all of the panes tables state objects too.
            this.dom.dtP.on('stateLoadParams.dt', function (e, settings, data) {
                if ($.isEmptyObject(table.state.loaded())) {
                    $.each(data, function (index, value) {
                        delete data[index];
                    });
                }
            });
            // Declare the datatable for the pane
            var errMode = $.fn.dataTable.ext.errMode;
            $.fn.dataTable.ext.errMode = 'none';
            var haveScroller = DataTable.Scroller;
            this.s.dtPane = $(this.dom.dtP).DataTable($.extend(true, {
                dom: 't',
                columnDefs: [
                    {
                        className: 'dtsp-nameColumn',
                        data: 'display',
                        render: function (data, type, row) {
                            if (type === 'sort') {
                                return row.sort;
                            }
                            else if (type === 'type') {
                                return row.type;
                            }
                            var message;
                            _this.s.filteringActive && _this.c.viewTotal
                                ? message = filteredMessage.replace(/{total}/, row.total)
                                : message = countMessage.replace(/{total}/, row.total);
                            message = message.replace(/{shown}/, row.shown);
                            while (message.indexOf('{total}') !== -1) {
                                message = message.replace(/{total}/, row.total);
                            }
                            while (message.indexOf('{shown}') !== -1) {
                                message = message.replace(/{shown}/, row.shown);
                            }
                            // We are displaying the count in the same columne as the name of the search option.
                            // This is so that there is not need to call columns.adjust(), which in turn speeds up the code
                            var displayMessage = '';
                            var pill = '<span class="' + _this.classes.pill + '">' + message + '</span>';
                            if (_this.c.hideCount || colOpts.hideCount) {
                                pill = '';
                            }
                            if (!_this.c.dataLength) {
                                displayMessage = '<span class="' + _this.classes.name + '">' + data + '</span>' + pill;
                            }
                            else if (data.length > _this.c.dataLength) {
                                displayMessage = '<span class="' + _this.classes.name + '">'
                                    + data.substr(0, _this.c.dataLength) + '...'
                                    + '</span>'
                                    + pill;
                            }
                            else {
                                displayMessage = '<span class="' + _this.classes.name + '">' + data + '</span>' + pill;
                            }
                            return displayMessage;
                        },
                        targets: 0,
                        // Accessing the private datatables property to set type based on the original table.
                        // This is null if not defined by the user, meaning that automatic type detection would take place
                        type: table.settings()[0].aoColumns[this.s.index] !== undefined ?
                            table.settings()[0].aoColumns[this.s.index]._sManualType :
                            null
                    },
                    {
                        className: 'dtsp-countColumn ' + this.classes.badgePill,
                        data: 'total',
                        targets: 1,
                        visible: false
                    }
                ],
                deferRender: true,
                info: false,
                paging: haveScroller ? true : false,
                scrollY: '200px',
                scroller: haveScroller ? true : false,
                select: true,
                stateSave: table.settings()[0].oFeatures.bStateSave ? true : false
            }, this.c.dtOpts, colOpts !== undefined ? colOpts.dtOpts : {}, (this.customPaneSettings !== null && this.customPaneSettings.dtOpts !== undefined)
                ? this.customPaneSettings.dtOpts
                : {}));
            $(this.dom.dtP).addClass(this.classes.table);
            // This is hacky but necessary for when datatables is generating the column titles automatically
            $(this.dom.searchBox).attr('placeholder', colOpts.header !== undefined
                ? colOpts.header
                : this.colExists
                    ? table.settings()[0].aoColumns[this.s.index].sTitle
                    : this.customPaneSettings.header || 'Custom Pane');
            // As the pane table is not in the document yet we must initialise select ourselves
            $.fn.dataTable.select.init(this.s.dtPane);
            $.fn.dataTable.ext.errMode = errMode;
            // If it is not a custom pane
            if (this.colExists) {
                // On initialisation, do we need to set a filtering value from a
                // saved state or init option?
                var search = column.search();
                search = search ? search.substr(1, search.length - 2).split('|') : [];
                // Count the number of empty cells
                var count_1 = 0;
                rowData.arrayFilter.forEach(function (element) {
                    if (element.filter === '') {
                        count_1++;
                    }
                });
                // Add all of the search options to the pane
                for (var i = 0, ien = rowData.arrayFilter.length; i < ien; i++) {
                    if (rowData.arrayFilter[i] && (rowData.bins[rowData.arrayFilter[i].filter] !== undefined || !this.c.cascadePanes)) {
                        var row = this._addRow(rowData.arrayFilter[i].display, rowData.arrayFilter[i].filter, rowData.bins[rowData.arrayFilter[i].filter], rowData.binsTotal[rowData.arrayFilter[i].filter], rowData.arrayFilter[i].sort, rowData.arrayFilter[i].type);
                        if (colOpts.preSelect !== undefined && colOpts.preSelect.indexOf(rowData.arrayFilter[i].filter) !== -1) {
                            row.select();
                        }
                    }
                    else {
                        this._addRow(this.c.emptyMessage, count_1, count_1, this.c.emptyMessage, this.c.emptyMessage, this.c.emptyMessage);
                    }
                }
            }
            // If there are custom options set or it is a custom pane then get them
            if (colOpts.options !== undefined ||
                (this.customPaneSettings !== null && this.customPaneSettings.options !== undefined)) {
                this._getComparisonRows();
            }
            DataTable.select.init(this.s.dtPane);
            // Display the pane
            this.s.dtPane.draw();
            // When an item is selected on the pane, add these to the array which holds selected items.
            // Custom search will perform.
            this.s.dtPane.on('select.dtsp', function () {
                clearTimeout(t0);
                $(_this.dom.clear).removeClass(_this.classes.dull);
                _this.s.selectPresent = true;
                if (!_this.s.updating) {
                    _this._makeSelection();
                }
                _this.s.selectPresent = false;
            });
            // When saving the state store all of the selected rows for preselection next time around
            this.s.dt.on('stateSaveParams.dtsp', function (e, settings, data) {
                // If the data being passed in is empty then a state clear must have occured so clear the panes state as well
                if ($.isEmptyObject(data)) {
                    _this.s.dtPane.state.clear();
                    return;
                }
                var selected = [];
                var searchTerm;
                var order;
                var bins;
                var arrayFilter;
                // Get all of the data needed for the state save from the pane
                if (_this.s.dtPane !== undefined) {
                    selected = _this.s.dtPane.rows({ selected: true }).data().map(function (item) { return item.filter.toString(); }).toArray();
                    searchTerm = $(_this.dom.searchBox).val();
                    order = _this.s.dtPane.order();
                    bins = rowData.binsOriginal;
                    arrayFilter = rowData.arrayOriginal;
                }
                if (data.searchPanes === undefined) {
                    data.searchPanes = {};
                }
                if (data.searchPanes.panes === undefined) {
                    data.searchPanes.panes = [];
                }
                // Add the panes data to the state object
                data.searchPanes.panes.push({
                    arrayFilter: arrayFilter,
                    bins: bins,
                    id: _this.s.index,
                    order: order,
                    searchTerm: searchTerm,
                    selected: selected
                });
            });
            // Reload the selection, searchbox entry and ordering from the previous state
            if (loadedFilter && loadedFilter.searchPanes && loadedFilter.searchPanes.panes) {
                if (!this.c.cascadePanes) {
                    this._reloadSelect(loadedFilter);
                }
                for (var _i = 0, _a = loadedFilter.searchPanes.panes; _i < _a.length; _i++) {
                    var pane = _a[_i];
                    if (pane.id === this.s.index) {
                        $(this.dom.searchBox).val(pane.searchTerm);
                        this.s.dt.order(pane.order);
                    }
                }
            }
            this.s.dtPane.on('user-select.dtsp', function (e, _dt, type, cell, originalEvent) {
                originalEvent.stopPropagation();
            });
            // When the button to order by the name of the options is clicked then
            //  change the ordering to whatever it isn't currently
            $(this.dom.nameButton).on('click.dtsp', function () {
                var currentOrder = _this.s.dtPane.order()[0][1];
                _this.s.dtPane.order([0, currentOrder === 'asc' ? 'desc' : 'asc']).draw();
            });
            // When the button to order by the number of entries in the column is clicked then
            //  change the ordering to whatever it isn't currently
            $(this.dom.countButton).on('click.dtsp', function () {
                var currentOrder = _this.s.dtPane.order()[0][1];
                _this.s.dtPane.order([1, currentOrder === 'asc' ? 'desc' : 'asc']).draw();
            });
            // When the clear button is clicked reset the pane
            $(this.dom.clear).on('click.dtsp', function () {
                var searches = _this.dom.container.find('.' + _this.classes.search);
                searches.each(function () {
                    // set the value of the search box to be an empty string and then search on that, effectively reseting
                    $(this).val('');
                    $(this).trigger('input');
                });
                _this.clearPane();
            });
            // When the search button is clicked then draw focus to the search box
            $(this.dom.searchButton).on('click.dtsp', function () {
                $(_this.dom.searchBox).focus();
            });
            // When a character is inputted into the searchbox search the pane for matching values.
            // Doing it this way means that no button has to be clicked to trigger a search, it is done asynchronously
            $(this.dom.searchBox).on('input.dtsp', function () {
                _this.s.dtPane.search($(_this.dom.searchBox).val()).draw();
                _this.s.dt.state.save();
            });
            // Declare timeout Variable
            var t0;
            // When an item is deselected on the pane, re add the currently selected items to the array
            // which holds selected items. Custom search will be performed.
            this.s.dtPane.on('deselect.dtsp', function () {
                t0 = setTimeout(function () {
                    _this.s.deselect = true;
                    if (_this.s.dtPane.rows({ selected: true }).data().toArray().length === 0) {
                        $(_this.dom.clear).addClass(_this.classes.dull);
                    }
                    _this._makeSelection();
                    _this.s.deselect = false;
                    _this.s.dt.state.save();
                }, 50);
            });
            // Make sure to save the state once the pane has been built
            this.s.dt.state.save();
            return true;
        };
        /**
         * Update the array which holds the display and filter values for the table
         */
        SearchPane.prototype._detailsPane = function () {
            var _this = this;
            var table = this.s.dt;
            this.s.rowData.arrayTotals = [];
            this.s.rowData.binsTotal = {};
            var settings = this.s.dt.settings()[0];
            table.rows().every(function (rowIdx) {
                _this._populatePaneArray(rowIdx, _this.s.rowData.arrayTotals, settings, _this.s.rowData.binsTotal);
            });
        };
        /**
         * Appends all of the HTML elements to their relevant parent Elements
         */
        SearchPane.prototype._displayPane = function () {
            var container = this.dom.container;
            var colOpts = this.s.colOpts;
            var layVal = parseInt(this.c.layout.split('-')[1], 10);
            //  Empty everything to start again
            $(this.dom.topRow).empty();
            $(this.dom.dtP).empty();
            $(this.dom.topRow).addClass(this.classes.topRow);
            // If there are more than 3 columns defined then make there be a smaller gap between the panes
            if (layVal > 3) {
                $(this.dom.container).addClass(this.classes.smallGap);
            }
            $(this.dom.topRow).addClass(this.classes.subRowsContainer);
            $(this.dom.upper).appendTo(this.dom.topRow);
            $(this.dom.lower).appendTo(this.dom.topRow);
            $(this.dom.searchCont).appendTo(this.dom.upper);
            $(this.dom.buttonGroup).appendTo(this.dom.lower);
            // If no selections have been made in the pane then disable the clear button
            if (this.c.dtOpts.searching === false ||
                (colOpts.dtOpts !== undefined &&
                    colOpts.dtOpts.searching === false) ||
                (!this.c.controls || !colOpts.controls) ||
                (this.customPaneSettings !== null &&
                    this.customPaneSettings.dtOpts !== undefined &&
                    this.customPaneSettings.dtOpts.searching !== undefined &&
                    !this.customPaneSettings.dtOpts.searching)) {
                $(this.dom.searchBox).attr('disabled', 'disabled')
                    .removeClass(this.classes.paneInputButton)
                    .addClass(this.classes.disabledButton);
            }
            $(this.dom.searchBox).appendTo(this.dom.searchCont);
            // Create the contents of the searchCont div. Worth noting that this function will change when using semantic ui
            this._searchContSetup();
            // If the clear button is allowed to show then display it
            if (this.c.clear && this.c.controls && colOpts.controls) {
                $(this.dom.clear).appendTo(this.dom.buttonGroup);
            }
            if (this.c.orderable && colOpts.orderable && this.c.controls && colOpts.controls) {
                $(this.dom.nameButton).appendTo(this.dom.buttonGroup);
            }
            // If the count column is hidden then don't display the ordering button for it
            if (!this.c.hideCount &&
                !colOpts.hideCount &&
                this.c.orderable &&
                colOpts.orderable &&
                this.c.controls &&
                colOpts.controls) {
                $(this.dom.countButton).appendTo(this.dom.buttonGroup);
            }
            $(this.dom.topRow).prependTo(this.dom.container);
            $(container).append(this.dom.dtP);
            $(container).show();
        };
        /**
         * Find the unique filter values in an array
         * @param data empty array to populate with data which has not yet been found
         * @param arrayFilter the array of all of the display and filter values for the table
         */
        SearchPane.prototype._findUnique = function (data, arrayFilter) {
            var prev = [];
            for (var _i = 0, arrayFilter_1 = arrayFilter; _i < arrayFilter_1.length; _i++) {
                var filterEl = arrayFilter_1[_i];
                // If the data has not already been processed then add it to the unique array and the previously processed array.
                if (prev.indexOf(filterEl.filter) === -1) {
                    data.push({
                        display: filterEl.display,
                        filter: filterEl.filter,
                        sort: filterEl.sort,
                        type: filterEl.type
                    });
                    prev.push(filterEl.filter);
                }
            }
        };
        /**
         * Gets the options for the row for the customPanes
         * @returns {object} The options for the row extended to include the options from the user.
         */
        SearchPane.prototype._getBonusOptions = function () {
            // We need to reset the thresholds as if they have a value in colOpts then that value will be used
            var defaultMutator = {
                orthogonal: {
                    threshold: null
                },
                threshold: null
            };
            return $.extend(true, {}, SearchPane.defaults, defaultMutator, this.c !== undefined ? this.c : {});
        };
        /**
         * Adds the custom options to the pane
         * @returns {Array} Returns the array of rows which have been added to the pane
         */
        SearchPane.prototype._getComparisonRows = function () {
            var colOpts = this.s.colOpts;
            // Find the appropriate options depending on whether this is a pane for a specific column or a custom pane
            var options = colOpts.options !== undefined
                ? colOpts.options
                : this.customPaneSettings !== null && this.customPaneSettings.options !== undefined
                    ? this.customPaneSettings.options
                    : undefined;
            if (options === undefined) {
                return;
            }
            var tableVals = this.s.dt.rows({ search: 'applied' }).data().toArray();
            var appRows = this.s.dt.rows({ search: 'applied' });
            var tableValsTotal = this.s.dt.rows().data().toArray();
            var allRows = this.s.dt.rows();
            var rows = [];
            // Clear all of the other rows from the pane, only custom options are to be displayed when they are defined
            this.s.dtPane.clear();
            for (var _i = 0, options_1 = options; _i < options_1.length; _i++) {
                var comp = options_1[_i];
                // Initialise the object which is to be placed in the row
                var insert = comp.label !== '' ? comp.label : this.c.emptyMessage;
                var comparisonObj = {
                    display: insert,
                    filter: typeof comp.value === 'function' ? comp.value : [],
                    shown: 0,
                    sort: insert,
                    total: 0,
                    type: insert
                };
                // If a custom function is in place
                if (typeof comp.value === 'function') {
                    // Count the number of times the function evaluates to true for the data currently being displayed
                    for (var tVal = 0; tVal < tableVals.length; tVal++) {
                        if (comp.value.call(this.s.dt, tableVals[tVal], appRows[0][tVal])) {
                            comparisonObj.shown++;
                        }
                    }
                    // Count the number of times the function evaluates to true for the original data in the Table
                    for (var i = 0; i < tableValsTotal.length; i++) {
                        if (comp.value.call(this.s.dt, tableValsTotal[i], allRows[0][i])) {
                            comparisonObj.total++;
                        }
                    }
                    // Update the comparisonObj
                    if (typeof comparisonObj.filter !== 'function') {
                        comparisonObj.filter.push(comp.filter);
                    }
                }
                // If cascadePanes is not active or if it is and the comparisonObj should be shown then add it to the pane
                if (!this.c.cascadePanes || (this.c.cascadePanes && comparisonObj.shown !== 0)) {
                    rows.push(this._addRow(comparisonObj.display, comparisonObj.filter, comparisonObj.shown, comparisonObj.total, comparisonObj.sort, comparisonObj.type));
                }
            }
            return rows;
        };
        /**
         * Gets the options for the row for the customPanes
         * @returns {object} The options for the row extended to include the options from the user.
         */
        SearchPane.prototype._getOptions = function () {
            var table = this.s.dt;
            // We need to reset the thresholds as if they have a value in colOpts then that value will be used
            var defaultMutator = {
                orthogonal: {
                    threshold: null
                },
                threshold: null
            };
            return $.extend(true, {}, SearchPane.defaults, defaultMutator, table.settings()[0].aoColumns[this.s.index].searchPanes);
        };
        /**
         * This method allows for changes to the panes and table to be made when a selection or a deselection occurs
         * @param select Denotes whether a selection has been made or not
         */
        SearchPane.prototype._makeSelection = function () {
            this.updateTable();
            this.s.updating = true;
            this.s.dt.draw();
            this.s.updating = false;
        };
        /**
         * Fill the array with the values that are currently being displayed in the table
         */
        SearchPane.prototype._populatePane = function () {
            var table = this.s.dt;
            this.s.rowData.arrayFilter = [];
            this.s.rowData.bins = {};
            var settings = this.s.dt.settings()[0];
            // If cascadePanes or viewTotal are active it is necessary to get the data which is currently
            //  being displayed for their functionality.
            var indexArray = (this.c.cascadePanes || this.c.viewTotal) && !this.s.clearing ?
                table.rows({ search: 'applied' }).indexes() :
                table.rows().indexes();
            for (var _i = 0, indexArray_1 = indexArray; _i < indexArray_1.length; _i++) {
                var index = indexArray_1[_i];
                this._populatePaneArray(index, this.s.rowData.arrayFilter, settings);
            }
        };
        /**
         * Populates an array with all of the data for the table
         * @param rowIdx The current row index to be compared
         * @param arrayFilter The array that is to be populated with row Details
         * @param bins The bins object that is to be populated with the row counts
         */
        SearchPane.prototype._populatePaneArray = function (rowIdx, arrayFilter, settings, bins) {
            if (bins === void 0) { bins = this.s.rowData.bins; }
            var colOpts = this.s.colOpts;
            // Retrieve the rendered data from the cell using the fnGetCellData function
            //  rather than the cell().render API method for optimisation
            if (typeof colOpts.orthogonal === 'string') {
                var rendered = settings.oApi._fnGetCellData(settings, rowIdx, this.s.index, colOpts.orthogonal);
                this.s.rowData.filterMap.set(rowIdx, rendered);
                this._addOption(rendered, rendered, rendered, rendered, arrayFilter, bins);
            }
            else {
                var filter = settings.oApi._fnGetCellData(settings, rowIdx, this.s.index, colOpts.orthogonal.search);
                this.s.rowData.filterMap.set(rowIdx, filter);
                if (!bins[filter]) {
                    bins[filter] = 1;
                    this._addOption(filter, settings.oApi._fnGetCellData(settings, rowIdx, this.s.index, colOpts.orthogonal.display), settings.oApi._fnGetCellData(settings, rowIdx, this.s.index, colOpts.orthogonal.sort), settings.oApi._fnGetCellData(settings, rowIdx, this.s.index, colOpts.orthogonal.type), arrayFilter, bins);
                }
                else {
                    bins[filter]++;
                    return;
                }
            }
        };
        /**
         * Reloads all of the previous selects into the panes
         * @param loadedFilter The loaded filters from a previous state
         */
        SearchPane.prototype._reloadSelect = function (loadedFilter) {
            // If the state was not saved don't selected any
            if (loadedFilter === undefined) {
                return;
            }
            var idx;
            // For each pane, check that the loadedFilter list exists and is not null,
            // find the id of each search item and set it to be selected.
            for (var i = 0; i < loadedFilter.searchPanes.panes.length; i++) {
                if (loadedFilter.searchPanes.panes[i].id === this.s.index) {
                    idx = i;
                    break;
                }
            }
            if (idx !== undefined) {
                var table = this.s.dtPane;
                var rows = table.rows({ order: 'index' }).data().map(function (item) { return item.filter !== null ?
                    item.filter.toString() :
                    null; }).toArray();
                for (var _i = 0, _a = loadedFilter.searchPanes.panes[idx].selected; _i < _a.length; _i++) {
                    var filter = _a[_i];
                    var id = -1;
                    if (filter !== null) {
                        id = rows.indexOf(filter.toString());
                    }
                    if (id > -1) {
                        table.row(id).select();
                        this.s.dt.state.save();
                    }
                }
            }
        };
        /**
         * This method decides whether a row should contribute to the pane or not
         * @param filter the value that the row is to be filtered on
         * @param dataIndex the row index
         */
        SearchPane.prototype._search = function (filter, dataIndex) {
            var colOpts = this.s.colOpts;
            var table = this.s.dt;
            // For each item selected in the pane, check if it is available in the cell
            for (var _i = 0, _a = this.selections; _i < _a.length; _i++) {
                var colSelect = _a[_i];
                // if the filter is an array then is the column present in it
                if (Array.isArray(filter)) {
                    if (filter.indexOf(colSelect.filter) !== -1) {
                        return true;
                    }
                }
                // if the filter is a function then does it meet the criteria of that function or not
                else if (typeof colSelect.filter === 'function') {
                    if (colSelect.filter.call(table, table.row(dataIndex).data(), dataIndex)) {
                        if (!this.s.redraw) {
                            this.updatePane();
                        }
                        if (colOpts.combiner === 'or') {
                            return true;
                        }
                    }
                    // If the combiner is an "and" then we need to check against all possible selections
                    //  so if it fails here then the and is not met and return false
                    else if (colOpts.combiner === 'and') {
                        return false;
                    }
                }
                // otherwise if the two filter values are equal then return true
                else if (filter === colSelect.filter) {
                    return true;
                }
            }
            // If the combiner is an and then we need to check against all possible selections
            //  so return true here if so because it would have returned false earlier if it had failed
            if (colOpts.combiner === 'and') {
                return true;
            }
            // Otherwise it hasn't matched with anything by this point so it must be false
            else {
                return false;
            }
        };
        /**
         * Creates the contents of the searchCont div
         *
         * NOTE This is overridden when semantic ui styling in order to integrate the search button into the text box.
         */
        SearchPane.prototype._searchContSetup = function () {
            if (this.c.controls && this.s.colOpts.controls) {
                $(this.dom.searchButton).appendTo(this.dom.searchLabelCont);
            }
            if (!(this.c.dtOpts.searching === false ||
                this.s.colOpts.dtOpts.searching === false ||
                (this.customPaneSettings !== null &&
                    this.customPaneSettings.dtOpts !== undefined &&
                    this.customPaneSettings.dtOpts.searching !== undefined &&
                    !this.customPaneSettings.dtOpts.searching))) {
                $(this.dom.searchLabelCont).appendTo(this.dom.searchCont);
            }
        };
        /**
         * Adds outline to the pane when a selection has been made
         */
        SearchPane.prototype._searchExtras = function () {
            var updating = this.s.updating;
            this.s.updating = true;
            var filters = this.s.dtPane.rows({ selected: true }).data().pluck('filter').toArray();
            var nullIndex = filters.indexOf(this.c.emptyMessage);
            var container = $(this.s.dtPane.table().container());
            // If null index is found then search for empty cells as a filter.
            if (nullIndex > -1) {
                filters[nullIndex] = '';
            }
            // If a filter has been applied then outline the respective pane, remove it when it no longer is.
            if (filters.length > 0) {
                container.addClass(this.classes.selected);
            }
            else if (filters.length === 0) {
                container.removeClass(this.classes.selected);
            }
            this.s.updating = updating;
        };
        /**
         * Finds the ratio of the number of different options in the table to the number of rows
         * @param bins the number of different options in the table
         * @param rowCount the total number of rows in the table
         * @returns {number} returns the ratio
         */
        SearchPane.prototype._uniqueRatio = function (bins, rowCount) {
            if (rowCount > 0) {
                return bins / rowCount;
            }
            else {
                return 1;
            }
        };
        /**
         * updates the options within the pane
         * @param draw a flag to define whether this has been called due to a draw event or not
         */
        SearchPane.prototype._updateCommon = function (draw) {
            if (draw === void 0) { draw = false; }
            // Update the panes if doing a deselect. if doing a select then
            // update all of the panes except for the one causing the change
            if (this.s.dtPane !== undefined &&
                ((!this.s.filteringActive || this.c.cascadePanes) || draw === true) &&
                (this.c.cascadePanes !== true || this.s.selectPresent !== true) && !this.s.lastSelect) {
                var colOpts = this.s.colOpts;
                var selected = this.s.dtPane.rows({ selected: true }).data().toArray();
                var scrollTop = $(this.s.dtPane.table().node()).parent()[0].scrollTop;
                var rowData = this.s.rowData;
                // Clear the pane in preparation for adding the updated search options
                this.s.dtPane.clear();
                // If it is not a custom pane
                if (this.colExists) {
                    // Only run populatePane if the data has not been collected yet
                    if (rowData.arrayFilter.length === 0) {
                        this._populatePane();
                    }
                    // If cascadePanes is active and the table has returned to its default state then
                    //  there is a need to update certain parts ofthe rowData.
                    else if (this.c.cascadePanes
                        && this.s.dt.rows().data().toArray().length === this.s.dt.rows({ search: 'applied' }).data().toArray().length) {
                        rowData.arrayFilter = rowData.arrayOriginal;
                        rowData.bins = rowData.binsOriginal;
                    }
                    // Otherwise if viewTotal or cascadePanes is active then the data from the table must be read.
                    else if (this.c.viewTotal || this.c.cascadePanes) {
                        this._populatePane();
                    }
                    // If the viewTotal option is selected then find the totals for the table
                    if (this.c.viewTotal) {
                        this._detailsPane();
                    }
                    else {
                        rowData.binsTotal = rowData.bins;
                    }
                    if (this.c.viewTotal && !this.c.cascadePanes) {
                        rowData.arrayFilter = rowData.arrayTotals;
                    }
                    var _loop_1 = function (dataP) {
                        // If both view Total and cascadePanes have been selected and the count of the row is not 0 then add it to pane
                        // Do this also if the viewTotal option has been selected and cascadePanes has not
                        if (dataP && ((rowData.bins[dataP.filter] !== undefined && rowData.bins[dataP.filter] !== 0 && this_1.c.cascadePanes)
                            || !this_1.c.cascadePanes
                            || this_1.s.clearing)) {
                            var row = this_1._addRow(dataP.display, dataP.filter, !this_1.c.viewTotal
                                ? rowData.bins[dataP.filter]
                                : rowData.bins[dataP.filter] !== undefined
                                    ? rowData.bins[dataP.filter]
                                    : 0, this_1.c.viewTotal
                                ? String(rowData.binsTotal[dataP.filter])
                                : rowData.bins[dataP.filter], dataP.sort, dataP.type);
                            // Find out if the filter was selected in the previous search, if so select it and remove from array.
                            var selectIndex = selected.findIndex(function (element) {
                                return element.filter === dataP.filter;
                            });
                            if (selectIndex !== -1) {
                                row.select();
                                selected.splice(selectIndex, 1);
                            }
                        }
                    };
                    var this_1 = this;
                    for (var _i = 0, _a = rowData.arrayFilter; _i < _a.length; _i++) {
                        var dataP = _a[_i];
                        _loop_1(dataP);
                    }
                }
                if ((colOpts.searchPanes !== undefined && colOpts.searchPanes.options !== undefined) ||
                    colOpts.options !== undefined ||
                    (this.customPaneSettings !== null && this.customPaneSettings.options !== undefined)) {
                    var rows = this._getComparisonRows();
                    var _loop_2 = function (row) {
                        var selectIndex = selected.findIndex(function (element) {
                            if (element.display === row.data().display) {
                                return true;
                            }
                        });
                        if (selectIndex !== -1) {
                            row.select();
                            selected.splice(selectIndex, 1);
                        }
                    };
                    for (var _b = 0, rows_1 = rows; _b < rows_1.length; _b++) {
                        var row = rows_1[_b];
                        _loop_2(row);
                    }
                }
                // Add search options which were previously selected but whos results are no
                // longer present in the resulting data set.
                for (var _c = 0, selected_1 = selected; _c < selected_1.length; _c++) {
                    var selectedEl = selected_1[_c];
                    var row = this._addRow(selectedEl.display, selectedEl.filter, 0, this.c.viewTotal
                        ? selectedEl.total
                        : 0, selectedEl.filter, selectedEl.filter);
                    row.select();
                }
                this.s.dtPane.draw();
                this.s.dtPane.table().node().parentNode.scrollTop = scrollTop;
            }
        };
        SearchPane.version = '1.0.1';
        SearchPane.classes = {
            buttonGroup: 'dtsp-buttonGroup',
            buttonSub: 'dtsp-buttonSub',
            clear: 'dtsp-clear',
            clearAll: 'dtsp-clearAll',
            clearButton: 'clearButton',
            container: 'dtsp-searchPane',
            countButton: 'dtsp-countButton',
            disabledButton: 'dtsp-disabledButton',
            dull: 'dtsp-dull',
            hidden: 'dtsp-hidden',
            hide: 'dtsp-hide',
            layout: 'dtsp-',
            name: 'dtsp-name',
            nameButton: 'dtsp-nameButton',
            narrow: 'dtsp-narrow',
            paneButton: 'dtsp-paneButton',
            paneInputButton: 'dtsp-paneInputButton',
            pill: 'dtsp-pill',
            search: 'dtsp-search',
            searchCont: 'dtsp-searchCont',
            searchIcon: 'dtsp-searchIcon',
            searchLabelCont: 'dtsp-searchButtonCont',
            selected: 'dtsp-selected',
            smallGap: 'dtsp-smallGap',
            subRow1: 'dtsp-subRow1',
            subRow2: 'dtsp-subRow2',
            subRowsContainer: 'dtsp-subRowsContainer',
            title: 'dtsp-title',
            topRow: 'dtsp-topRow'
        };
        // Define SearchPanes default options
        SearchPane.defaults = {
            cascadePanes: false,
            clear: true,
            combiner: 'or',
            controls: true,
            container: function (dt) {
                return dt.table().container();
            },
            dataLength: 30,
            dtOpts: {},
            emptyMessage: '<i>No Data</i>',
            hideCount: false,
            layout: 'columns-3',
            orderable: true,
            orthogonal: {
                display: 'display',
                hideCount: false,
                search: 'filter',
                show: undefined,
                sort: 'sort',
                threshold: 0.6,
                type: 'type'
            },
            preSelect: [],
            threshold: 0.6,
            viewTotal: false
        };
        return SearchPane;
    }());

    var DataTable$1 = $.fn.dataTable;
    var SearchPanes = /** @class */ (function () {
        function SearchPanes(paneSettings, opts, fromInit) {
            var _this = this;
            if (fromInit === void 0) { fromInit = false; }
            this.regenerating = false;
            // Check that the required version of DataTables is included
            if (!DataTable$1 || !DataTable$1.versionCheck || !DataTable$1.versionCheck('1.10.0')) {
                throw new Error('SearchPane requires DataTables 1.10 or newer');
            }
            // Check that Select is included
            if (!DataTable$1.select) {
                throw new Error('SearchPane requires Select');
            }
            var table = new DataTable$1.Api(paneSettings);
            this.classes = $.extend(true, {}, SearchPanes.classes);
            // Get options from user
            this.c = $.extend(true, {}, SearchPanes.defaults, opts);
            // Add extra elements to DOM object including clear
            this.dom = {
                clearAll: $('<button type="button">Clear All</button>').addClass(this.classes.clearAll),
                container: $('<div/>').addClass(this.classes.panes).text(table.i18n('searchPanes.loadMessage', 'Loading Search Panes...')),
                emptyMessage: $('<div/>').addClass(this.classes.emptyMessage),
                options: $('<div/>').addClass(this.classes.container),
                panes: $('<div/>').addClass(this.classes.container),
                title: $('<div/>').addClass(this.classes.title),
                titleRow: $('<div/>').addClass(this.classes.titleRow),
                wrapper: $('<div/>')
            };
            this.s = {
                colOpts: [],
                dt: table,
                filterPane: -1,
                panes: [],
                selectionList: [],
                updating: false
            };
            table.settings()[0]._searchPanes = this;
            this.dom.clearAll.text(table.i18n('searchPanes.clearMessage', 'Clear All'));
            this._getState();
            if (this.s.dt.settings()[0]._bInitComplete || fromInit) {
                this._paneDeclare(table, paneSettings, opts);
            }
            else {
                table.on('preInit.dt', function () {
                    _this._paneDeclare(table, paneSettings, opts);
                });
            }
        }
        /**
         * Clear the selections of all of the panes
         */
        SearchPanes.prototype.clearSelections = function () {
            // Load in all of the searchBoxes in the documents
            var searches = this.dom.container.find(this.classes.search);
            // For each searchBox set the input text to be empty and then trigger
            //  an input on them so that they no longer filter the panes
            searches.each(function () {
                $(this).val('');
                $(this).trigger('input');
            });
            var returnArray = [];
            // For every pane, clear the selections in the pane
            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {
                var pane = _a[_i];
                if (pane.s.dtPane !== undefined) {
                    returnArray.push(pane.clearPane());
                }
            }
            this.s.dt.draw();
            return returnArray;
        };
        /**
         * returns the container node for the searchPanes
         */
        SearchPanes.prototype.getNode = function () {
            return this.dom.container;
        };
        /**
         * rebuilds all of the panes
         */
        SearchPanes.prototype.rebuild = function (targetIdx) {
            if (targetIdx === void 0) { targetIdx = false; }
            $(this.dom.emptyMessage).remove();
            // As a rebuild from scratch is required, empty the searchpanes container.
            var returnArray = [];
            this.clearSelections();
            // Rebuild each pane individually, if a specific pane has been selected then only rebuild that one
            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {
                var pane = _a[_i];
                if (targetIdx !== false && pane.s.index !== targetIdx) {
                    continue;
                }
                pane.clearData();
                returnArray.push(pane.rebuildPane());
            }
            // Attach panes, clear buttons, and title bar to the document
            this._updateFilterCount();
            this._attachPaneContainer();
            // If a single pane has been rebuilt then return only that pane
            if (returnArray.length === 1) {
                return returnArray[0];
            }
            // Otherwise return all of the panes that have been rebuilt
            else {
                return returnArray;
            }
        };
        /**
         * Redraws all of the panes
         */
        SearchPanes.prototype.redrawPanes = function () {
            var table = this.s.dt;
            // Only do this if the redraw isn't being triggered by the panes updating themselves
            if (!this.s.updating) {
                var filterActive = true;
                var filterPane = this.s.filterPane;
                // If the number of rows currently visible is equal to the number of rows in the table
                //  then there can't be any filtering taking place
                if (table.rows({ search: 'applied' }).data().toArray().length === table.rows().data().toArray().length) {
                    filterActive = false;
                }
                // Otherwise if viewTotal is active then it is necessary to determine which panes a select is present in.
                //  If there is only one pane with a selection present then it should not show the filtered message as
                //  more selections may be made in that pane.
                else if (this.c.viewTotal) {
                    for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {
                        var pane = _a[_i];
                        if (pane.s.dtPane !== undefined) {
                            var selectLength = pane.s.dtPane.rows({ selected: true }).data().toArray().length;
                            // If filterPane === -1 then a pane with a selection has not been found yet, so set filterPane to that panes index
                            if (selectLength > 0 && filterPane === -1) {
                                filterPane = pane.s.index;
                            }
                            // Then if another pane is found with a selection then set filterPane to null to
                            //  show that multiple panes have selections present
                            else if (selectLength > 0) {
                                filterPane = null;
                            }
                        }
                    }
                }
                var deselectIdx = void 0;
                var newSelectionList = [];
                // Don't run this if it is due to the panes regenerating
                if (!this.regenerating) {
                    for (var _b = 0, _c = this.s.panes; _b < _c.length; _b++) {
                        var pane = _c[_b];
                        // Identify the pane where a selection or deselection has been made and add it to the list.
                        if (pane.s.selectPresent) {
                            this.s.selectionList.push({ index: pane.s.index, rows: pane.s.dtPane.rows({ selected: true }).data().toArray(), protect: false });
                            table.state.save();
                            break;
                        }
                        else if (pane.s.deselect) {
                            deselectIdx = pane.s.index;
                            var selectedData = pane.s.dtPane.rows({ selected: true }).data().toArray();
                            if (selectedData.length > 0) {
                                this.s.selectionList.push({ index: pane.s.index, rows: selectedData, protect: true });
                            }
                        }
                    }
                    if (this.s.selectionList.length > 0) {
                        var last = this.s.selectionList[this.s.selectionList.length - 1].index;
                        for (var _d = 0, _e = this.s.panes; _d < _e.length; _d++) {
                            var pane = _e[_d];
                            pane.s.lastSelect = (pane.s.index === last && this.s.selectionList.length === 1);
                        }
                    }
                    // Remove selections from the list from the pane where a deselect has taken place
                    for (var i = 0; i < this.s.selectionList.length; i++) {
                        if (this.s.selectionList[i].index !== deselectIdx || this.s.selectionList[i].protect === true) {
                            var further = false;
                            // Find out if this selection is the last one in the list for that pane
                            for (var j = i + 1; j < this.s.selectionList.length; j++) {
                                if (this.s.selectionList[j].index === this.s.selectionList[i].index) {
                                    further = true;
                                }
                            }
                            // If there are no selections for this pane in the list then just push this one
                            if (!further) {
                                newSelectionList.push(this.s.selectionList[i]);
                                this.s.selectionList[i].protect = false;
                            }
                        }
                    }
                    // Update all of the panes to reflect the current state of the filters
                    for (var _f = 0, _g = this.s.panes; _f < _g.length; _f++) {
                        var pane = _g[_f];
                        if (pane.s.dtPane !== undefined) {
                            var tempFilter = true;
                            pane.s.filteringActive = true;
                            if ((filterPane !== -1 && filterPane !== null && filterPane === pane.s.index) || filterActive === false) {
                                tempFilter = false;
                                pane.s.filteringActive = false;
                            }
                            pane.updatePane(!tempFilter ? false : filterActive);
                        }
                    }
                    // Update the label that shows how many filters are in place
                    this._updateFilterCount();
                    // If the length of the selections are different then some of them have been removed and a deselect has occured
                    if (newSelectionList.length > 0 && newSelectionList.length < this.s.selectionList.length) {
                        this._cascadeRegen(newSelectionList);
                        var last = newSelectionList[newSelectionList.length - 1].index;
                        for (var _h = 0, _j = this.s.panes; _h < _j.length; _h++) {
                            var pane = _j[_h];
                            pane.s.lastSelect = (pane.s.index === last && this.s.selectionList.length === 1);
                        }
                    }
                    else if (newSelectionList.length > 0) {
                        // Update all of the other panes as you would just making a normal selection
                        for (var _k = 0, _l = this.s.panes; _k < _l.length; _k++) {
                            var paneUpdate = _l[_k];
                            if (paneUpdate.s.dtPane !== undefined) {
                                var tempFilter = true;
                                paneUpdate.s.filteringActive = true;
                                if ((filterPane !== -1 && filterPane !== null && filterPane === paneUpdate.s.index) || filterActive === false) {
                                    tempFilter = false;
                                    paneUpdate.s.filteringActive = false;
                                }
                                paneUpdate.updatePane(!tempFilter ? tempFilter : filterActive);
                            }
                        }
                    }
                }
                else {
                    for (var _m = 0, _o = this.s.panes; _m < _o.length; _m++) {
                        var pane = _o[_m];
                        if (pane.s.dtPane !== undefined) {
                            var tempFilter = true;
                            pane.s.filteringActive = true;
                            if ((filterPane !== -1 && filterPane !== null && filterPane === pane.s.index) || filterActive === false) {
                                tempFilter = false;
                                pane.s.filteringActive = false;
                            }
                            pane.updatePane(!tempFilter ? tempFilter : filterActive);
                        }
                    }
                    // Update the label that shows how many filters are in place
                    this._updateFilterCount();
                }
                if (!filterActive) {
                    this.s.selectionList = [];
                }
            }
        };
        /**
         * Attach the panes, buttons and title to the document
         */
        SearchPanes.prototype._attach = function () {
            $(this.dom.container).removeClass(this.classes.hide);
            $(this.dom.titleRow).removeClass(this.classes.hide);
            $(this.dom.titleRow).remove();
            $(this.dom.title).appendTo(this.dom.titleRow);
            // If the clear button is permitted attach it
            if (this.c.clear) {
                $(this.dom.clearAll).appendTo(this.dom.titleRow);
            }
            $(this.dom.titleRow).appendTo(this.dom.container);
            // Attach the container for each individual pane to the overall container
            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {
                var pane = _a[_i];
                $(pane.dom.container).appendTo(this.dom.panes);
            }
            // Attach everything to the document
            $(this.dom.panes).appendTo(this.dom.container);
            if ($('div.' + this.classes.container).length === 0) {
                $(this.dom.container).prependTo(this.s.dt);
            }
            return this.dom.container;
        };
        /**
         * Attach the top row containing the filter count and clear all button
         */
        SearchPanes.prototype._attachExtras = function () {
            $(this.dom.container).removeClass(this.classes.hide);
            $(this.dom.titleRow).removeClass(this.classes.hide);
            $(this.dom.titleRow).remove();
            $(this.dom.title).appendTo(this.dom.titleRow);
            // If the clear button is permitted attach it
            if (this.c.clear) {
                $(this.dom.clearAll).appendTo(this.dom.titleRow);
            }
            $(this.dom.titleRow).appendTo(this.dom.container);
            return this.dom.container;
        };
        /**
         * If there are no panes to display then this method is called to either
         *   display a message in their place or hide them completely.
         */
        SearchPanes.prototype._attachMessage = function () {
            // Create a message to display on the screen
            var message;
            try {
                message = this.s.dt.i18n('searchPanes.emptyPanes', 'No SearchPanes');
            }
            catch (error) {
                message = null;
            }
            // If the message is an empty string then searchPanes.emptyPanes is undefined,
            //  therefore the pane container should be removed from the display
            if (message === null) {
                $(this.dom.container).addClass(this.classes.hide);
                $(this.dom.titleRow).removeClass(this.classes.hide);
                return;
            }
            else {
                $(this.dom.container).removeClass(this.classes.hide);
                $(this.dom.titleRow).addClass(this.classes.hide);
            }
            // Otherwise display the message
            $(this.dom.emptyMessage).text(message);
            this.dom.emptyMessage.appendTo(this.dom.container);
            return this.dom.container;
        };
        /**
         * Attaches the panes to the document and displays a message or hides if there are none
         */
        SearchPanes.prototype._attachPaneContainer = function () {
            // If a pane is to be displayed then attach the normal pane output
            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {
                var pane = _a[_i];
                if (pane.s.displayed === true) {
                    return this._attach();
                }
            }
            // Otherwise attach the custom message or remove the container from the display
            return this._attachMessage();
        };
        /**
         * Prepares the panes for selections to be made when cascade is active and a deselect has occured
         * @param newSelectionList the list of selections which are to be made
         */
        SearchPanes.prototype._cascadeRegen = function (newSelectionList) {
            // Set this to true so that the actions taken do not cause this to run until it is finished
            this.regenerating = true;
            // If only one pane has been selected then take note of its index
            var solePane = -1;
            if (newSelectionList.length === 1) {
                solePane = newSelectionList[0].index;
            }
            // Let the pane know that a cascadeRegen is taking place to avoid unexpected behaviour
            //  and clear all of the previous selections in the pane
            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {
                var pane = _a[_i];
                pane.setCascadeRegen(true);
                pane.setClear(true);
                // If this is the same as the pane with the only selection then pass it as a parameter into clearPane
                if ((pane.s.dtPane !== undefined && pane.s.index === solePane) || pane.s.dtPane !== undefined) {
                    pane.clearPane();
                }
                pane.setClear(false);
            }
            // Remake Selections
            this._makeCascadeSelections(newSelectionList);
            // Set the selection list property to be the list without the selections from the deselect pane
            this.s.selectionList = newSelectionList;
            // The regeneration of selections is over so set it back to false
            for (var _b = 0, _c = this.s.panes; _b < _c.length; _b++) {
                var pane = _c[_b];
                pane.setCascadeRegen(false);
            }
            this.regenerating = false;
        };
        /**
         * Attaches the message to the document but does not add any panes
         */
        SearchPanes.prototype._checkMessage = function () {
            // If a pane is to be displayed then attach the normal pane output
            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {
                var pane = _a[_i];
                if (pane.s.displayed === true) {
                    return;
                }
            }
            // Otherwise attach the custom message or remove the container from the display
            return this._attachMessage();
        };
        /**
         * Gets the selection list from the previous state and stores it in the selectionList Property
         */
        SearchPanes.prototype._getState = function () {
            var loadedFilter = this.s.dt.state.loaded();
            if (loadedFilter && loadedFilter.searchPanes && loadedFilter.searchPanes.selectionList !== undefined) {
                this.s.selectionList = loadedFilter.searchPanes.selectionList;
            }
        };
        /**
         * Makes all of the selections when cascade is active
         * @param newSelectionList the list of selections to be made, in the order they were originally selected
         */
        SearchPanes.prototype._makeCascadeSelections = function (newSelectionList) {
            // make selections in the order they were made previously, excluding those from the pane where a deselect was made
            for (var _i = 0, newSelectionList_1 = newSelectionList; _i < newSelectionList_1.length; _i++) {
                var selection = newSelectionList_1[_i];
                var _loop_1 = function (pane) {
                    if (pane.s.index === selection.index && pane.s.dtPane !== undefined) {
                        // if there are any selections currently in the pane then deselect them as we are about to make our new selections
                        if (pane.s.dtPane.rows({ selected: true }).data().toArray().length > 0 && pane.s.dtPane !== undefined) {
                            pane.setClear(true);
                            pane.clearPane();
                            pane.setClear(false);
                        }
                        var _loop_2 = function (row) {
                            pane.s.dtPane.rows().every(function (rowIdx) {
                                if (pane.s.dtPane.row(rowIdx).data().filter === row.filter) {
                                    pane.s.dtPane.row(rowIdx).select();
                                }
                            });
                        };
                        // select every row in the pane that was selected previously
                        for (var _i = 0, _a = selection.rows; _i < _a.length; _i++) {
                            var row = _a[_i];
                            _loop_2(row);
                        }
                        // Update the label that shows how many filters are in place
                        this_1._updateFilterCount();
                    }
                };
                var this_1 = this;
                // As the selections may have been made across the panes in a different order to the pane index we must identify
                //  which pane has the index of the selection. This is also important for colreorder etc
                for (var _a = 0, _b = this.s.panes; _a < _b.length; _a++) {
                    var pane = _b[_a];
                    _loop_1(pane);
                }
            }
            // Make sure that the state is saved after all of these selections
            this.s.dt.state.save();
        };
        /**
         * Declares the instances of individual searchpanes dependant on the number of columns.
         * It is necessary to run this once preInit has completed otherwise no panes will be
         *  created as the column count will be 0.
         * @param table the DataTable api for the parent table
         * @param paneSettings the settings passed into the constructor
         * @param opts the options passed into the constructor
         */
        SearchPanes.prototype._paneDeclare = function (table, paneSettings, opts) {
            var _this = this;
            // Create Panes
            table
                .columns(this.c.columns.length > 0 ? this.c.columns : undefined)
                .eq(0)
                .each(function (idx) {
                _this.s.panes.push(new SearchPane(paneSettings, opts, idx, _this.c.layout, _this.dom.panes));
            });
            // If there is any extra custom panes defined then create panes for them too
            var rowLength = table.columns().eq(0).toArray().length;
            var paneLength = this.c.panes.length;
            for (var i = 0; i < paneLength; i++) {
                var id = rowLength + i;
                this.s.panes.push(new SearchPane(paneSettings, opts, id, this.c.layout, this.dom.panes, this.c.panes[i]));
            }
            // If this internal property is true then the DataTable has been initialised already
            if (this.s.dt.settings()[0]._bInitComplete) {
                this._paneStartup(table);
            }
            else {
                // Otherwise add the paneStartup function to the list of functions that are to be run when the table is initialised
                // This will garauntee that the panes are initialised before the init event and init Complete callback is fired
                this.s.dt.settings()[0].aoInitComplete.push({ fn: function () {
                        _this._paneStartup(table);
                    } });
            }
        };
        /**
         * Runs the start up functions for the panes to enable listeners and populate panes
         * @param table the DataTable api for the parent Table
         */
        SearchPanes.prototype._paneStartup = function (table) {
            var _this = this;
            // Magic number of 500 is a guess at what will be fast
            if (this.s.dt.page.info().recordsTotal <= 500) {
                this._startup(table);
            }
            else {
                setTimeout(function () {
                    _this._startup(table);
                }, 100);
            }
        };
        /**
         * Initialises the tables previous/preset selections and initialises callbacks for events
         * @param table the parent table for which the searchPanes are being created
         */
        SearchPanes.prototype._startup = function (table) {
            var _this = this;
            $(this.dom.container).text('');
            // Attach clear button and title bar to the document
            this._attachExtras();
            $(this.dom.container).append(this.dom.panes);
            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {
                var pane = _a[_i];
                pane.rebuildPane();
            }
            this._updateFilterCount();
            this._checkMessage();
            // When a draw is called on the DataTable, update all of the panes incase the data in the DataTable has changed
            table.on('draw.dtsps', function () {
                _this._updateFilterCount();
                if (_this.c.cascadePanes || _this.c.viewTotal) {
                    _this.redrawPanes();
                }
                _this.s.filterPane = -1;
            });
            // Whenever a state save occurs store the selection list in the state object
            this.s.dt.on('stateSaveParams.dtsp', function (e, settings, data) {
                if (data.searchPanes === undefined) {
                    data.searchPanes = {};
                }
                data.searchPanes.selectionList = _this.s.selectionList;
            });
            // If cascadePanes is active then make the previous selections in the order they were previously
            if (this.s.selectionList.length > 0 && this.c.cascadePanes) {
                this._cascadeRegen(this.s.selectionList);
            }
            // PreSelect any selections which have been defined using the preSelect option
            table
                .columns(this.c.columns.length > 0 ? this.c.columns : undefined)
                .eq(0)
                .each(function (idx) {
                if (_this.s.panes[idx] !== undefined &&
                    _this.s.panes[idx].s.dtPane !== undefined &&
                    _this.s.panes[idx].s.colOpts.preSelect !== undefined) {
                    var tableLength = _this.s.panes[idx].s.dtPane.rows().data().toArray().length;
                    for (var i = 0; i < tableLength; i++) {
                        if (_this.s.panes[idx].s.colOpts.preSelect.indexOf(_this.s.panes[idx].s.dtPane.cell(i, 0).data()) !== -1) {
                            _this.s.panes[idx].s.dtPane.row(i).select();
                            _this.s.panes[idx].updateTable();
                        }
                    }
                }
            });
            // Update the title bar to show how many filters have been selected
            this._updateFilterCount();
            // If the table is destroyed and restarted then clear the selections so that they do not persist.
            table.on('destroy.dtsps', function () {
                for (var _i = 0, _a = _this.s.panes; _i < _a.length; _i++) {
                    var pane = _a[_i];
                    pane.destroy();
                }
                table.off('.dtsps');
                $(_this.dom.clearAll).off('.dtsps');
                $(_this.dom.container).remove();
                _this.clearSelections();
            });
            // When the clear All button has been pressed clear all of the selections in the panes
            if (this.c.clear) {
                $(this.dom.clearAll).on('click.dtsps', function () {
                    _this.clearSelections();
                });
            }
            table.settings()[0]._searchPanes = this;
        };
        /**
         * Updates the number of filters that have been applied in the title
         */
        SearchPanes.prototype._updateFilterCount = function () {
            var filterCount = 0;
            // Add the number of all of the filters throughout the panes
            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {
                var pane = _a[_i];
                if (pane.s.dtPane !== undefined) {
                    filterCount += pane.getPaneCount();
                }
            }
            // Run the message through the internationalisation method to improve readability
            var message = this.s.dt.i18n('searchPanes.title', 'Filters Active - %d', filterCount);
            $(this.dom.title).text(message);
        };
        SearchPanes.version = '1.0.1';
        SearchPanes.classes = {
            clear: 'dtsp-clear',
            clearAll: 'dtsp-clearAll',
            container: 'dtsp-searchPanes',
            emptyMessage: 'dtsp-emptyMessage',
            hide: 'dtsp-hidden',
            panes: 'dtsp-panesContainer',
            search: 'dtsp-search',
            title: 'dtsp-title',
            titleRow: 'dtsp-titleRow'
        };
        // Define SearchPanes default options
        SearchPanes.defaults = {
            cascadePanes: false,
            clear: true,
            container: function (dt) {
                return dt.table().container();
            },
            columns: [],
            layout: 'columns-3',
            panes: [],
            viewTotal: false
        };
        return SearchPanes;
    }());

    /*! SearchPanes 1.0.1
     * 2019-2020 SpryMedia Ltd - datatables.net/license
     */
    // DataTables extensions common UMD. Note that this allows for AMD, CommonJS
    // (with window and jQuery being allowed as parameters to the returned
    // function) or just default browser loading.
    (function (factory) {
        if (typeof define === 'function' && define.amd) {
            // AMD
            define(['jquery', 'datatables.net'], function ($) {
                return factory($, window, document);
            });
        }
        else if (typeof exports === 'object') {
            // CommonJS
            module.exports = function (root, $) {
                if (!root) {
                    root = window;
                }
                if (!$ || !$.fn.dataTable) {
                    $ = require('datatables.net')(root, $).$;
                }
                return factory($, root, root.document);
            };
        }
        else {
            // Browser - assume jQuery has already been loaded
            factory(window.jQuery, window, document);
        }
    }(function ($, window, document) {
        var DataTable = $.fn.dataTable;
        $.fn.dataTable.SearchPanes = SearchPanes;
        $.fn.DataTable.SearchPanes = SearchPanes;
        $.fn.dataTable.SearchPane = SearchPane;
        $.fn.DataTable.SearchPane = SearchPane;
        DataTable.Api.register('searchPanes.rebuild()', function () {
            return this.iterator('table', function () {
                if (this.searchPanes) {
                    this.searchPanes.rebuild();
                }
            });
        });
        DataTable.Api.register('column().paneOptions()', function (options) {
            return this.iterator('column', function (idx) {
                var col = this.aoColumns[idx];
                if (!col.searchPanes) {
                    col.searchPanes = {};
                }
                col.searchPanes.values = options;
                if (this.searchPanes) {
                    this.searchPanes.rebuild();
                }
            });
        });
        var apiRegister = $.fn.dataTable.Api.register;
        apiRegister('searchPanes()', function () {
            return this;
        });
        apiRegister('searchPanes.clearSelections()', function () {
            var ctx = this.context[0];
            ctx._searchPanes.clearSelections();
            return this;
        });
        apiRegister('searchPanes.rebuildPane()', function (targetIdx) {
            var ctx = this.context[0];
            ctx._searchPanes.rebuild(targetIdx);
            return this;
        });
        apiRegister('searchPanes.container()', function () {
            var ctx = this.context[0];
            return ctx._searchPanes.getNode();
        });
        $.fn.dataTable.ext.buttons.searchPanesClear = {
            text: 'Clear Panes',
            action: function (e, dt, node, config) {
                dt.searchPanes.clearSelections();
            }
        };
        $.fn.dataTable.ext.buttons.searchPanes = {
            text: 'Search Panes',
            init: function (dt, node, config) {
                var panes = new $.fn.dataTable.SearchPanes(dt, {
                    filterChanged: function (count) {
                        dt.button(node).text(dt.i18n('searchPanes.collapse', { 0: 'SearchPanes', _: 'SearchPanes (%d)' }, count));
                    }
                });
                var message = dt.i18n('searchPanes.collapse', 'SearchPanes');
                dt.button(node).text(message);
                config._panes = panes;
            },
            action: function (e, dt, node, config) {
                e.stopPropagation();
                this.popover(config._panes.getNode(), {
                    align: 'dt-container'
                });
                config._panes.adjust();
            }
        };
        function _init(settings, fromPre) {
            if (fromPre === void 0) { fromPre = false; }
            var api = new DataTable.Api(settings);
            var opts = api.init().searchPanes || DataTable.defaults.searchPanes;
            var searchPanes = new SearchPanes(api, opts, fromPre);
            var node = searchPanes.getNode();
            return node;
        }
        // Attach a listener to the document which listens for DataTables initialisation
        // events so we can automatically initialise
        $(document).on('preInit.dt.dtsp', function (e, settings, json) {
            if (e.namespace !== 'dt') {
                return;
            }
            if (settings.oInit.searchPanes ||
                DataTable.defaults.searchPanes) {
                if (!settings._searchPanes) {
                    _init(settings, true);
                }
            }
        });
        // DataTables `dom` feature option
        DataTable.ext.feature.push({
            cFeature: 'P',
            fnInit: _init
        });
        // DataTables 2 layout feature
        if (DataTable.ext.features) {
            DataTable.ext.features.register('searchPanes', _init);
        }
    }));

}());


(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define(['jquery', 'datatables.net-bs4', 'datatables.net-searchPanes'], function ($) {
            return factory($, window, document);
        });
    }
    else if (typeof exports === 'object') {
        // CommonJS
        module.exports = function (root, $) {
            if (!root) {
                root = window;
            }
            if (!$ || !$.fn.dataTable) {
                $ = require('datatables.net-bs4')(root, $).$;
            }
            if (!$.fn.dataTable.searchPanes) {
                require('datatables.net-searchPanes')(root, $);
            }
            return factory($, root, root.document);
        };
    }
    else {
        // Browser
        factory(jQuery, window, document);
    }
}(function ($, window, document) {
    'use strict';
    var DataTable = $.fn.dataTable;
    $.extend(true, DataTable.SearchPane.classes, {
        buttonGroup: 'btn-group col justify-content-end',
        disabledButton: 'disabled',
        dull: '',
        narrow: 'col',
        pane: {
            container: 'table'
        },
        paneButton: 'btn btn-light',
        pill: 'pill badge badge-pill badge-secondary',
        search: 'col-sm form-control search',
        searchCont: 'input-group col-sm',
        searchLabelCont: 'input-group-append',
        subRow1: 'dtsp-subRow1',
        subRow2: 'dtsp-subRow2',
        table: 'table table-sm table-borderless',
        topRow: 'dtsp-topRow row'
    });
    $.extend(true, DataTable.SearchPanes.classes, {
        clearAll: 'dtsp-clearAll col-1 btn btn-light',
        container: 'dtsp-searchPanes',
        panes: 'dtsp-panes dtsp-container',
        title: 'dtsp-title col-10',
        titleRow: 'dtsp-titleRow row'
    });
    return DataTable.searchPanes;
}));


/*! Select for DataTables 1.3.1
 * 2015-2019 SpryMedia Ltd - datatables.net/license/mit
 */

/**
 * @summary     Select for DataTables
 * @description A collection of API methods, events and buttons for DataTables
 *   that provides selection options of the items in a DataTable
 * @version     1.3.1
 * @file        dataTables.select.js
 * @author      SpryMedia Ltd (www.sprymedia.co.uk)
 * @contact     datatables.net/forums
 * @copyright   Copyright 2015-2019 SpryMedia Ltd.
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license/mit
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net/extensions/select
 */
(function( factory ){
	if ( typeof define === 'function' && define.amd ) {
		// AMD
		define( ['jquery', 'datatables.net'], function ( $ ) {
			return factory( $, window, document );
		} );
	}
	else if ( typeof exports === 'object' ) {
		// CommonJS
		module.exports = function (root, $) {
			if ( ! root ) {
				root = window;
			}

			if ( ! $ || ! $.fn.dataTable ) {
				$ = require('datatables.net')(root, $).$;
			}

			return factory( $, root, root.document );
		};
	}
	else {
		// Browser
		factory( jQuery, window, document );
	}
}(function( $, window, document, undefined ) {
'use strict';
var DataTable = $.fn.dataTable;


// Version information for debugger
DataTable.select = {};

DataTable.select.version = '1.3.1';

DataTable.select.init = function ( dt ) {
	var ctx = dt.settings()[0];
	var init = ctx.oInit.select;
	var defaults = DataTable.defaults.select;
	var opts = init === undefined ?
		defaults :
		init;

	// Set defaults
	var items = 'row';
	var style = 'api';
	var blurable = false;
	var toggleable = true;
	var info = true;
	var selector = 'td, th';
	var className = 'selected';
	var setStyle = false;

	ctx._select = {};

	// Initialisation customisations
	if ( opts === true ) {
		style = 'os';
		setStyle = true;
	}
	else if ( typeof opts === 'string' ) {
		style = opts;
		setStyle = true;
	}
	else if ( $.isPlainObject( opts ) ) {
		if ( opts.blurable !== undefined ) {
			blurable = opts.blurable;
		}
		
		if ( opts.toggleable !== undefined ) {
			toggleable = opts.toggleable;
		}

		if ( opts.info !== undefined ) {
			info = opts.info;
		}

		if ( opts.items !== undefined ) {
			items = opts.items;
		}

		if ( opts.style !== undefined ) {
			style = opts.style;
			setStyle = true;
		}
		else {
			style = 'os';
			setStyle = true;
		}

		if ( opts.selector !== undefined ) {
			selector = opts.selector;
		}

		if ( opts.className !== undefined ) {
			className = opts.className;
		}
	}

	dt.select.selector( selector );
	dt.select.items( items );
	dt.select.style( style );
	dt.select.blurable( blurable );
	dt.select.toggleable( toggleable );
	dt.select.info( info );
	ctx._select.className = className;


	// Sort table based on selected rows. Requires Select Datatables extension
	$.fn.dataTable.ext.order['select-checkbox'] = function ( settings, col ) {
		return this.api().column( col, {order: 'index'} ).nodes().map( function ( td ) {
			if ( settings._select.items === 'row' ) {
				return $( td ).parent().hasClass( settings._select.className );
			} else if ( settings._select.items === 'cell' ) {
				return $( td ).hasClass( settings._select.className );
			}
			return false;
		});
	};

	// If the init options haven't enabled select, but there is a selectable
	// class name, then enable
	if ( ! setStyle && $( dt.table().node() ).hasClass( 'selectable' ) ) {
		dt.select.style( 'os' );
	}
};

/*

Select is a collection of API methods, event handlers, event emitters and
buttons (for the `Buttons` extension) for DataTables. It provides the following
features, with an overview of how they are implemented:

## Selection of rows, columns and cells. Whether an item is selected or not is
   stored in:

* rows: a `_select_selected` property which contains a boolean value of the
  DataTables' `aoData` object for each row
* columns: a `_select_selected` property which contains a boolean value of the
  DataTables' `aoColumns` object for each column
* cells: a `_selected_cells` property which contains an array of boolean values
  of the `aoData` object for each row. The array is the same length as the
  columns array, with each element of it representing a cell.

This method of using boolean flags allows Select to operate when nodes have not
been created for rows / cells (DataTables' defer rendering feature).

## API methods

A range of API methods are available for triggering selection and de-selection
of rows. Methods are also available to configure the selection events that can
be triggered by an end user (such as which items are to be selected). To a large
extent, these of API methods *is* Select. It is basically a collection of helper
functions that can be used to select items in a DataTable.

Configuration of select is held in the object `_select` which is attached to the
DataTables settings object on initialisation. Select being available on a table
is not optional when Select is loaded, but its default is for selection only to
be available via the API - so the end user wouldn't be able to select rows
without additional configuration.

The `_select` object contains the following properties:

```
{
	items:string       - Can be `rows`, `columns` or `cells`. Defines what item 
	                     will be selected if the user is allowed to activate row
	                     selection using the mouse.
	style:string       - Can be `none`, `single`, `multi` or `os`. Defines the
	                     interaction style when selecting items
	blurable:boolean   - If row selection can be cleared by clicking outside of
	                     the table
	toggleable:boolean - If row selection can be cancelled by repeated clicking
	                     on the row
	info:boolean       - If the selection summary should be shown in the table
	                     information elements
}
```

In addition to the API methods, Select also extends the DataTables selector
options for rows, columns and cells adding a `selected` option to the selector
options object, allowing the developer to select only selected items or
unselected items.

## Mouse selection of items

Clicking on items can be used to select items. This is done by a simple event
handler that will select the items using the API methods.

 */


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Local functions
 */

/**
 * Add one or more cells to the selection when shift clicking in OS selection
 * style cell selection.
 *
 * Cell range is more complicated than row and column as we want to select
 * in the visible grid rather than by index in sequence. For example, if you
 * click first in cell 1-1 and then shift click in 2-2 - cells 1-2 and 2-1
 * should also be selected (and not 1-3, 1-4. etc)
 * 
 * @param  {DataTable.Api} dt   DataTable
 * @param  {object}        idx  Cell index to select to
 * @param  {object}        last Cell index to select from
 * @private
 */
function cellRange( dt, idx, last )
{
	var indexes;
	var columnIndexes;
	var rowIndexes;
	var selectColumns = function ( start, end ) {
		if ( start > end ) {
			var tmp = end;
			end = start;
			start = tmp;
		}
		
		var record = false;
		return dt.columns( ':visible' ).indexes().filter( function (i) {
			if ( i === start ) {
				record = true;
			}
			
			if ( i === end ) { // not else if, as start might === end
				record = false;
				return true;
			}

			return record;
		} );
	};

	var selectRows = function ( start, end ) {
		var indexes = dt.rows( { search: 'applied' } ).indexes();

		// Which comes first - might need to swap
		if ( indexes.indexOf( start ) > indexes.indexOf( end ) ) {
			var tmp = end;
			end = start;
			start = tmp;
		}

		var record = false;
		return indexes.filter( function (i) {
			if ( i === start ) {
				record = true;
			}
			
			if ( i === end ) {
				record = false;
				return true;
			}

			return record;
		} );
	};

	if ( ! dt.cells( { selected: true } ).any() && ! last ) {
		// select from the top left cell to this one
		columnIndexes = selectColumns( 0, idx.column );
		rowIndexes = selectRows( 0 , idx.row );
	}
	else {
		// Get column indexes between old and new
		columnIndexes = selectColumns( last.column, idx.column );
		rowIndexes = selectRows( last.row , idx.row );
	}

	indexes = dt.cells( rowIndexes, columnIndexes ).flatten();

	if ( ! dt.cells( idx, { selected: true } ).any() ) {
		// Select range
		dt.cells( indexes ).select();
	}
	else {
		// Deselect range
		dt.cells( indexes ).deselect();
	}
}

/**
 * Disable mouse selection by removing the selectors
 *
 * @param {DataTable.Api} dt DataTable to remove events from
 * @private
 */
function disableMouseSelection( dt )
{
	var ctx = dt.settings()[0];
	var selector = ctx._select.selector;

	$( dt.table().container() )
		.off( 'mousedown.dtSelect', selector )
		.off( 'mouseup.dtSelect', selector )
		.off( 'click.dtSelect', selector );

	$('body').off( 'click.dtSelect' + _safeId(dt.table().node()) );
}

/**
 * Attach mouse listeners to the table to allow mouse selection of items
 *
 * @param {DataTable.Api} dt DataTable to remove events from
 * @private
 */
function enableMouseSelection ( dt )
{
	var container = $( dt.table().container() );
	var ctx = dt.settings()[0];
	var selector = ctx._select.selector;
	var matchSelection;

	container
		.on( 'mousedown.dtSelect', selector, function(e) {
			// Disallow text selection for shift clicking on the table so multi
			// element selection doesn't look terrible!
			if ( e.shiftKey || e.metaKey || e.ctrlKey ) {
				container
					.css( '-moz-user-select', 'none' )
					.one('selectstart.dtSelect', selector, function () {
						return false;
					} );
			}

			if ( window.getSelection ) {
				matchSelection = window.getSelection();
			}
		} )
		.on( 'mouseup.dtSelect', selector, function() {
			// Allow text selection to occur again, Mozilla style (tested in FF
			// 35.0.1 - still required)
			container.css( '-moz-user-select', '' );
		} )
		.on( 'click.dtSelect', selector, function ( e ) {
			var items = dt.select.items();
			var idx;

			// If text was selected (click and drag), then we shouldn't change
			// the row's selected state
			if ( matchSelection ) {
				var selection = window.getSelection();

				// If the element that contains the selection is not in the table, we can ignore it
				// This can happen if the developer selects text from the click event
				if ( ! selection.anchorNode || $(selection.anchorNode).closest('table')[0] === dt.table().node() ) {
					if ( selection !== matchSelection ) {
						return;
					}
				}
			}

			var ctx = dt.settings()[0];
			var wrapperClass = $.trim(dt.settings()[0].oClasses.sWrapper).replace(/ +/g, '.');

			// Ignore clicks inside a sub-table
			if ( $(e.target).closest('div.'+wrapperClass)[0] != dt.table().container() ) {
				return;
			}

			var cell = dt.cell( $(e.target).closest('td, th') );

			// Check the cell actually belongs to the host DataTable (so child
			// rows, etc, are ignored)
			if ( ! cell.any() ) {
				return;
			}

			var event = $.Event('user-select.dt');
			eventTrigger( dt, event, [ items, cell, e ] );

			if ( event.isDefaultPrevented() ) {
				return;
			}

			var cellIndex = cell.index();
			if ( items === 'row' ) {
				idx = cellIndex.row;
				typeSelect( e, dt, ctx, 'row', idx );
			}
			else if ( items === 'column' ) {
				idx = cell.index().column;
				typeSelect( e, dt, ctx, 'column', idx );
			}
			else if ( items === 'cell' ) {
				idx = cell.index();
				typeSelect( e, dt, ctx, 'cell', idx );
			}

			ctx._select_lastCell = cellIndex;
		} );

	// Blurable
	$('body').on( 'click.dtSelect' + _safeId(dt.table().node()), function ( e ) {
		if ( ctx._select.blurable ) {
			// If the click was inside the DataTables container, don't blur
			if ( $(e.target).parents().filter( dt.table().container() ).length ) {
				return;
			}

			// Ignore elements which have been removed from the DOM (i.e. paging
			// buttons)
			if ( $(e.target).parents('html').length === 0 ) {
			 	return;
			}

			// Don't blur in Editor form
			if ( $(e.target).parents('div.DTE').length ) {
				return;
			}

			clear( ctx, true );
		}
	} );
}

/**
 * Trigger an event on a DataTable
 *
 * @param {DataTable.Api} api      DataTable to trigger events on
 * @param  {boolean}      selected true if selected, false if deselected
 * @param  {string}       type     Item type acting on
 * @param  {boolean}      any      Require that there are values before
 *     triggering
 * @private
 */
function eventTrigger ( api, type, args, any )
{
	if ( any && ! api.flatten().length ) {
		return;
	}

	if ( typeof type === 'string' ) {
		type = type +'.dt';
	}

	args.unshift( api );

	$(api.table().node()).trigger( type, args );
}

/**
 * Update the information element of the DataTable showing information about the
 * items selected. This is done by adding tags to the existing text
 * 
 * @param {DataTable.Api} api DataTable to update
 * @private
 */
function info ( api )
{
	var ctx = api.settings()[0];

	if ( ! ctx._select.info || ! ctx.aanFeatures.i ) {
		return;
	}

	if ( api.select.style() === 'api' ) {
		return;
	}

	var rows    = api.rows( { selected: true } ).flatten().length;
	var columns = api.columns( { selected: true } ).flatten().length;
	var cells   = api.cells( { selected: true } ).flatten().length;

	var add = function ( el, name, num ) {
		el.append( $('<span class="select-item"/>').append( api.i18n(
			'select.'+name+'s',
			{ _: '%d '+name+'s selected', 0: '', 1: '1 '+name+' selected' },
			num
		) ) );
	};

	// Internal knowledge of DataTables to loop over all information elements
	$.each( ctx.aanFeatures.i, function ( i, el ) {
		el = $(el);

		var output  = $('<span class="select-info"/>');
		add( output, 'row', rows );
		add( output, 'column', columns );
		add( output, 'cell', cells  );

		var exisiting = el.children('span.select-info');
		if ( exisiting.length ) {
			exisiting.remove();
		}

		if ( output.text() !== '' ) {
			el.append( output );
		}
	} );
}

/**
 * Initialisation of a new table. Attach event handlers and callbacks to allow
 * Select to operate correctly.
 *
 * This will occur _after_ the initial DataTables initialisation, although
 * before Ajax data is rendered, if there is ajax data
 *
 * @param  {DataTable.settings} ctx Settings object to operate on
 * @private
 */
function init ( ctx ) {
	var api = new DataTable.Api( ctx );

	// Row callback so that classes can be added to rows and cells if the item
	// was selected before the element was created. This will happen with the
	// `deferRender` option enabled.
	// 
	// This method of attaching to `aoRowCreatedCallback` is a hack until
	// DataTables has proper events for row manipulation If you are reviewing
	// this code to create your own plug-ins, please do not do this!
	ctx.aoRowCreatedCallback.push( {
		fn: function ( row, data, index ) {
			var i, ien;
			var d = ctx.aoData[ index ];

			// Row
			if ( d._select_selected ) {
				$( row ).addClass( ctx._select.className );
			}

			// Cells and columns - if separated out, we would need to do two
			// loops, so it makes sense to combine them into a single one
			for ( i=0, ien=ctx.aoColumns.length ; i<ien ; i++ ) {
				if ( ctx.aoColumns[i]._select_selected || (d._selected_cells && d._selected_cells[i]) ) {
					$(d.anCells[i]).addClass( ctx._select.className );
				}
			}
		},
		sName: 'select-deferRender'
	} );

	// On Ajax reload we want to reselect all rows which are currently selected,
	// if there is an rowId (i.e. a unique value to identify each row with)
	api.on( 'preXhr.dt.dtSelect', function () {
		// note that column selection doesn't need to be cached and then
		// reselected, as they are already selected
		var rows = api.rows( { selected: true } ).ids( true ).filter( function ( d ) {
			return d !== undefined;
		} );

		var cells = api.cells( { selected: true } ).eq(0).map( function ( cellIdx ) {
			var id = api.row( cellIdx.row ).id( true );
			return id ?
				{ row: id, column: cellIdx.column } :
				undefined;
		} ).filter( function ( d ) {
			return d !== undefined;
		} );

		// On the next draw, reselect the currently selected items
		api.one( 'draw.dt.dtSelect', function () {
			api.rows( rows ).select();

			// `cells` is not a cell index selector, so it needs a loop
			if ( cells.any() ) {
				cells.each( function ( id ) {
					api.cells( id.row, id.column ).select();
				} );
			}
		} );
	} );

	// Update the table information element with selected item summary
	api.on( 'draw.dtSelect.dt select.dtSelect.dt deselect.dtSelect.dt info.dt', function () {
		info( api );
	} );

	// Clean up and release
	api.on( 'destroy.dtSelect', function () {
		disableMouseSelection( api );
		api.off( '.dtSelect' );
	} );
}

/**
 * Add one or more items (rows or columns) to the selection when shift clicking
 * in OS selection style
 *
 * @param  {DataTable.Api} dt   DataTable
 * @param  {string}        type Row or column range selector
 * @param  {object}        idx  Item index to select to
 * @param  {object}        last Item index to select from
 * @private
 */
function rowColumnRange( dt, type, idx, last )
{
	// Add a range of rows from the last selected row to this one
	var indexes = dt[type+'s']( { search: 'applied' } ).indexes();
	var idx1 = $.inArray( last, indexes );
	var idx2 = $.inArray( idx, indexes );

	if ( ! dt[type+'s']( { selected: true } ).any() && idx1 === -1 ) {
		// select from top to here - slightly odd, but both Windows and Mac OS
		// do this
		indexes.splice( $.inArray( idx, indexes )+1, indexes.length );
	}
	else {
		// reverse so we can shift click 'up' as well as down
		if ( idx1 > idx2 ) {
			var tmp = idx2;
			idx2 = idx1;
			idx1 = tmp;
		}

		indexes.splice( idx2+1, indexes.length );
		indexes.splice( 0, idx1 );
	}

	if ( ! dt[type]( idx, { selected: true } ).any() ) {
		// Select range
		dt[type+'s']( indexes ).select();
	}
	else {
		// Deselect range - need to keep the clicked on row selected
		indexes.splice( $.inArray( idx, indexes ), 1 );
		dt[type+'s']( indexes ).deselect();
	}
}

/**
 * Clear all selected items
 *
 * @param  {DataTable.settings} ctx Settings object of the host DataTable
 * @param  {boolean} [force=false] Force the de-selection to happen, regardless
 *     of selection style
 * @private
 */
function clear( ctx, force )
{
	if ( force || ctx._select.style === 'single' ) {
		var api = new DataTable.Api( ctx );
		
		api.rows( { selected: true } ).deselect();
		api.columns( { selected: true } ).deselect();
		api.cells( { selected: true } ).deselect();
	}
}

/**
 * Select items based on the current configuration for style and items.
 *
 * @param  {object}             e    Mouse event object
 * @param  {DataTables.Api}     dt   DataTable
 * @param  {DataTable.settings} ctx  Settings object of the host DataTable
 * @param  {string}             type Items to select
 * @param  {int|object}         idx  Index of the item to select
 * @private
 */
function typeSelect ( e, dt, ctx, type, idx )
{
	var style = dt.select.style();
	var toggleable = dt.select.toggleable();
	var isSelected = dt[type]( idx, { selected: true } ).any();
	
	if ( isSelected && ! toggleable ) {
		return;
	}

	if ( style === 'os' ) {
		if ( e.ctrlKey || e.metaKey ) {
			// Add or remove from the selection
			dt[type]( idx ).select( ! isSelected );
		}
		else if ( e.shiftKey ) {
			if ( type === 'cell' ) {
				cellRange( dt, idx, ctx._select_lastCell || null );
			}
			else {
				rowColumnRange( dt, type, idx, ctx._select_lastCell ?
					ctx._select_lastCell[type] :
					null
				);
			}
		}
		else {
			// No cmd or shift click - deselect if selected, or select
			// this row only
			var selected = dt[type+'s']( { selected: true } );

			if ( isSelected && selected.flatten().length === 1 ) {
				dt[type]( idx ).deselect();
			}
			else {
				selected.deselect();
				dt[type]( idx ).select();
			}
		}
	} else if ( style == 'multi+shift' ) {
		if ( e.shiftKey ) {
			if ( type === 'cell' ) {
				cellRange( dt, idx, ctx._select_lastCell || null );
			}
			else {
				rowColumnRange( dt, type, idx, ctx._select_lastCell ?
					ctx._select_lastCell[type] :
					null
				);
			}
		}
		else {
			dt[ type ]( idx ).select( ! isSelected );
		}
	}
	else {
		dt[ type ]( idx ).select( ! isSelected );
	}
}

function _safeId( node ) {
	return node.id.replace(/[^a-zA-Z0-9\-\_]/g, '-');
}



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * DataTables selectors
 */

// row and column are basically identical just assigned to different properties
// and checking a different array, so we can dynamically create the functions to
// reduce the code size
$.each( [
	{ type: 'row', prop: 'aoData' },
	{ type: 'column', prop: 'aoColumns' }
], function ( i, o ) {
	DataTable.ext.selector[ o.type ].push( function ( settings, opts, indexes ) {
		var selected = opts.selected;
		var data;
		var out = [];

		if ( selected !== true && selected !== false ) {
			return indexes;
		}

		for ( var i=0, ien=indexes.length ; i<ien ; i++ ) {
			data = settings[ o.prop ][ indexes[i] ];

			if ( (selected === true && data._select_selected === true) ||
			     (selected === false && ! data._select_selected )
			) {
				out.push( indexes[i] );
			}
		}

		return out;
	} );
} );

DataTable.ext.selector.cell.push( function ( settings, opts, cells ) {
	var selected = opts.selected;
	var rowData;
	var out = [];

	if ( selected === undefined ) {
		return cells;
	}

	for ( var i=0, ien=cells.length ; i<ien ; i++ ) {
		rowData = settings.aoData[ cells[i].row ];

		if ( (selected === true && rowData._selected_cells && rowData._selected_cells[ cells[i].column ] === true) ||
		     (selected === false && ( ! rowData._selected_cells || ! rowData._selected_cells[ cells[i].column ] ) )
		) {
			out.push( cells[i] );
		}
	}

	return out;
} );



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * DataTables API
 *
 * For complete documentation, please refer to the docs/api directory or the
 * DataTables site
 */

// Local variables to improve compression
var apiRegister = DataTable.Api.register;
var apiRegisterPlural = DataTable.Api.registerPlural;

apiRegister( 'select()', function () {
	return this.iterator( 'table', function ( ctx ) {
		DataTable.select.init( new DataTable.Api( ctx ) );
	} );
} );

apiRegister( 'select.blurable()', function ( flag ) {
	if ( flag === undefined ) {
		return this.context[0]._select.blurable;
	}

	return this.iterator( 'table', function ( ctx ) {
		ctx._select.blurable = flag;
	} );
} );

apiRegister( 'select.toggleable()', function ( flag ) {
	if ( flag === undefined ) {
		return this.context[0]._select.toggleable;
	}

	return this.iterator( 'table', function ( ctx ) {
		ctx._select.toggleable = flag;
	} );
} );

apiRegister( 'select.info()', function ( flag ) {
	if ( info === undefined ) {
		return this.context[0]._select.info;
	}

	return this.iterator( 'table', function ( ctx ) {
		ctx._select.info = flag;
	} );
} );

apiRegister( 'select.items()', function ( items ) {
	if ( items === undefined ) {
		return this.context[0]._select.items;
	}

	return this.iterator( 'table', function ( ctx ) {
		ctx._select.items = items;

		eventTrigger( new DataTable.Api( ctx ), 'selectItems', [ items ] );
	} );
} );

// Takes effect from the _next_ selection. None disables future selection, but
// does not clear the current selection. Use the `deselect` methods for that
apiRegister( 'select.style()', function ( style ) {
	if ( style === undefined ) {
		return this.context[0]._select.style;
	}

	return this.iterator( 'table', function ( ctx ) {
		ctx._select.style = style;

		if ( ! ctx._select_init ) {
			init( ctx );
		}

		// Add / remove mouse event handlers. They aren't required when only
		// API selection is available
		var dt = new DataTable.Api( ctx );
		disableMouseSelection( dt );
		
		if ( style !== 'api' ) {
			enableMouseSelection( dt );
		}

		eventTrigger( new DataTable.Api( ctx ), 'selectStyle', [ style ] );
	} );
} );

apiRegister( 'select.selector()', function ( selector ) {
	if ( selector === undefined ) {
		return this.context[0]._select.selector;
	}

	return this.iterator( 'table', function ( ctx ) {
		disableMouseSelection( new DataTable.Api( ctx ) );

		ctx._select.selector = selector;

		if ( ctx._select.style !== 'api' ) {
			enableMouseSelection( new DataTable.Api( ctx ) );
		}
	} );
} );



apiRegisterPlural( 'rows().select()', 'row().select()', function ( select ) {
	var api = this;

	if ( select === false ) {
		return this.deselect();
	}

	this.iterator( 'row', function ( ctx, idx ) {
		clear( ctx );

		ctx.aoData[ idx ]._select_selected = true;
		$( ctx.aoData[ idx ].nTr ).addClass( ctx._select.className );
	} );

	this.iterator( 'table', function ( ctx, i ) {
		eventTrigger( api, 'select', [ 'row', api[i] ], true );
	} );

	return this;
} );

apiRegisterPlural( 'columns().select()', 'column().select()', function ( select ) {
	var api = this;

	if ( select === false ) {
		return this.deselect();
	}

	this.iterator( 'column', function ( ctx, idx ) {
		clear( ctx );

		ctx.aoColumns[ idx ]._select_selected = true;

		var column = new DataTable.Api( ctx ).column( idx );

		$( column.header() ).addClass( ctx._select.className );
		$( column.footer() ).addClass( ctx._select.className );

		column.nodes().to$().addClass( ctx._select.className );
	} );

	this.iterator( 'table', function ( ctx, i ) {
		eventTrigger( api, 'select', [ 'column', api[i] ], true );
	} );

	return this;
} );

apiRegisterPlural( 'cells().select()', 'cell().select()', function ( select ) {
	var api = this;

	if ( select === false ) {
		return this.deselect();
	}

	this.iterator( 'cell', function ( ctx, rowIdx, colIdx ) {
		clear( ctx );

		var data = ctx.aoData[ rowIdx ];

		if ( data._selected_cells === undefined ) {
			data._selected_cells = [];
		}

		data._selected_cells[ colIdx ] = true;

		if ( data.anCells ) {
			$( data.anCells[ colIdx ] ).addClass( ctx._select.className );
		}
	} );

	this.iterator( 'table', function ( ctx, i ) {
		eventTrigger( api, 'select', [ 'cell', api[i] ], true );
	} );

	return this;
} );


apiRegisterPlural( 'rows().deselect()', 'row().deselect()', function () {
	var api = this;

	this.iterator( 'row', function ( ctx, idx ) {
		ctx.aoData[ idx ]._select_selected = false;
		$( ctx.aoData[ idx ].nTr ).removeClass( ctx._select.className );
	} );

	this.iterator( 'table', function ( ctx, i ) {
		eventTrigger( api, 'deselect', [ 'row', api[i] ], true );
	} );

	return this;
} );

apiRegisterPlural( 'columns().deselect()', 'column().deselect()', function () {
	var api = this;

	this.iterator( 'column', function ( ctx, idx ) {
		ctx.aoColumns[ idx ]._select_selected = false;

		var api = new DataTable.Api( ctx );
		var column = api.column( idx );

		$( column.header() ).removeClass( ctx._select.className );
		$( column.footer() ).removeClass( ctx._select.className );

		// Need to loop over each cell, rather than just using
		// `column().nodes()` as cells which are individually selected should
		// not have the `selected` class removed from them
		api.cells( null, idx ).indexes().each( function (cellIdx) {
			var data = ctx.aoData[ cellIdx.row ];
			var cellSelected = data._selected_cells;

			if ( data.anCells && (! cellSelected || ! cellSelected[ cellIdx.column ]) ) {
				$( data.anCells[ cellIdx.column  ] ).removeClass( ctx._select.className );
			}
		} );
	} );

	this.iterator( 'table', function ( ctx, i ) {
		eventTrigger( api, 'deselect', [ 'column', api[i] ], true );
	} );

	return this;
} );

apiRegisterPlural( 'cells().deselect()', 'cell().deselect()', function () {
	var api = this;

	this.iterator( 'cell', function ( ctx, rowIdx, colIdx ) {
		var data = ctx.aoData[ rowIdx ];

		data._selected_cells[ colIdx ] = false;

		// Remove class only if the cells exist, and the cell is not column
		// selected, in which case the class should remain (since it is selected
		// in the column)
		if ( data.anCells && ! ctx.aoColumns[ colIdx ]._select_selected ) {
			$( data.anCells[ colIdx ] ).removeClass( ctx._select.className );
		}
	} );

	this.iterator( 'table', function ( ctx, i ) {
		eventTrigger( api, 'deselect', [ 'cell', api[i] ], true );
	} );

	return this;
} );



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Buttons
 */
function i18n( label, def ) {
	return function (dt) {
		return dt.i18n( 'buttons.'+label, def );
	};
}

// Common events with suitable namespaces
function namespacedEvents ( config ) {
	var unique = config._eventNamespace;

	return 'draw.dt.DT'+unique+' select.dt.DT'+unique+' deselect.dt.DT'+unique;
}

function enabled ( dt, config ) {
	if ( $.inArray( 'rows', config.limitTo ) !== -1 && dt.rows( { selected: true } ).any() ) {
		return true;
	}

	if ( $.inArray( 'columns', config.limitTo ) !== -1 && dt.columns( { selected: true } ).any() ) {
		return true;
	}

	if ( $.inArray( 'cells', config.limitTo ) !== -1 && dt.cells( { selected: true } ).any() ) {
		return true;
	}

	return false;
}

var _buttonNamespace = 0;

$.extend( DataTable.ext.buttons, {
	selected: {
		text: i18n( 'selected', 'Selected' ),
		className: 'buttons-selected',
		limitTo: [ 'rows', 'columns', 'cells' ],
		init: function ( dt, node, config ) {
			var that = this;
			config._eventNamespace = '.select'+(_buttonNamespace++);

			// .DT namespace listeners are removed by DataTables automatically
			// on table destroy
			dt.on( namespacedEvents(config), function () {
				that.enable( enabled(dt, config) );
			} );

			this.disable();
		},
		destroy: function ( dt, node, config ) {
			dt.off( config._eventNamespace );
		}
	},
	selectedSingle: {
		text: i18n( 'selectedSingle', 'Selected single' ),
		className: 'buttons-selected-single',
		init: function ( dt, node, config ) {
			var that = this;
			config._eventNamespace = '.select'+(_buttonNamespace++);

			dt.on( namespacedEvents(config), function () {
				var count = dt.rows( { selected: true } ).flatten().length +
				            dt.columns( { selected: true } ).flatten().length +
				            dt.cells( { selected: true } ).flatten().length;

				that.enable( count === 1 );
			} );

			this.disable();
		},
		destroy: function ( dt, node, config ) {
			dt.off( config._eventNamespace );
		}
	},
	selectAll: {
		text: i18n( 'selectAll', 'Select all' ),
		className: 'buttons-select-all',
		action: function () {
			var items = this.select.items();
			this[ items+'s' ]().select();
		}
	},
	selectNone: {
		text: i18n( 'selectNone', 'Deselect all' ),
		className: 'buttons-select-none',
		action: function () {
			clear( this.settings()[0], true );
		},
		init: function ( dt, node, config ) {
			var that = this;
			config._eventNamespace = '.select'+(_buttonNamespace++);

			dt.on( namespacedEvents(config), function () {
				var count = dt.rows( { selected: true } ).flatten().length +
				            dt.columns( { selected: true } ).flatten().length +
				            dt.cells( { selected: true } ).flatten().length;

				that.enable( count > 0 );
			} );

			this.disable();
		},
		destroy: function ( dt, node, config ) {
			dt.off( config._eventNamespace );
		}
	}
} );

$.each( [ 'Row', 'Column', 'Cell' ], function ( i, item ) {
	var lc = item.toLowerCase();

	DataTable.ext.buttons[ 'select'+item+'s' ] = {
		text: i18n( 'select'+item+'s', 'Select '+lc+'s' ),
		className: 'buttons-select-'+lc+'s',
		action: function () {
			this.select.items( lc );
		},
		init: function ( dt ) {
			var that = this;

			dt.on( 'selectItems.dt.DT', function ( e, ctx, items ) {
				that.active( items === lc );
			} );
		}
	};
} );



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Initialisation
 */

// DataTables creation - check if select has been defined in the options. Note
// this required that the table be in the document! If it isn't then something
// needs to trigger this method unfortunately. The next major release of
// DataTables will rework the events and address this.
$(document).on( 'preInit.dt.dtSelect', function (e, ctx) {
	if ( e.namespace !== 'dt' ) {
		return;
	}

	DataTable.select.init( new DataTable.Api( ctx ) );
} );


return DataTable.select;
}));


